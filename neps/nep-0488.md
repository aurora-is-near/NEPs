---
NEP: 488
Title: Host Functions for BLS12-381 Curve Operations
Authors: Olga Kuniavskaia <olga.kunyavskaya@aurora.dev>
Status: Draft
DiscussionsTo: https://github.com/nearprotocol/neps/pull/488
Type: Runtime Spec
Version: 0.0.1
Created: 2023-07-17
LastUpdated: 2023-10-09
---

## Summary

Native NEAR runtime functions for operations on BLS12-381 curve. This NEP introduces a minimal set of functions to efficiently verify BLS signatures  and zkSNARKs.

## Motivation

The BLS12-381[^1][^11][^52] is a widely used[^2][^3][^4][^5][^6][^7] elliptic curve with 120+ bits security level[^8], which supports *the pairing operation*. It is an alternative for BN254 elliptic curve[^9][^12], which also supports the aggregation, and has been already implemented on NEAR as host functions[^10]. Recent research shows that BN254 security level is lower than 100-bit[^13]. Also, there is a tendency to switch from BN254 to BLS12-381 in the industry – ZCash[^14], Ethereum[^15][^3], Tezos[^16][^5] or just use it – Filecoin[^6].

The host functions implementation for the BLS12-381 curve operations from this NEP will allow to efficiently verify the BLS signature and zkSNARKs. At the moment, BLS signature verification for BLS12-381 is impossible due to the 300 TGas gas limit per one transaction on Near.

As we have seen above, other blockchains are using the BLS12-381 signature. In the context of cross-chain interactions we want to have a possibility to verify transactions from these blockchains on Near. Usually, it is done by implementing the on-chain client on Near, which will verify the corresponding BLS signatures. It is especially important for the Rainbow Bridge[^17] to send trustless transfers from Ethereum to Near.

zkSNARKs are useful to work with the user's private information[^18][^19]. Zeropool[^20] is a project, which implements zkSNARKs verifier on Near and is currently based on Alt-BN128. Implementation of the host functions for BLS12-381 can make the projects like that more secure. zkSNARKs are also used in Rollups[^21][^22][^23] scaling solution.

This proposal is based on a similar proposal for Ethereum: EIP-2537[^15], so you will find similar functions there.
The closest analogues on Near are functions available for BN254 curve, also known as Alt-BN128[^10].

In this NEP we propose to add the following functions as host functions:

- ***bls12381_g1_sum —*** adds an array of the signed points from $G_1$ on an elliptic curve. This function is useful for the aggregation of private keys in BLS Signature. Can be used for simple addition in $G_1$. Separate from the multiexp function due to the gas cost.
- ***bls12381_g2_sum —*** adds an array of the signed points from $G_2$ on an elliptic curve. This function is useful for the aggregation of signatures in BLS Signature. Can be used for simple addition in $G_2$. Separate from the multiexp function due to the gas cost.
- ***bls12381_g1_multiexp —*** for points $g_i \in G_1$ and scalars $s_i$ calculate $\sum g_i s_i$. Can be used to multiply a group element by a scalar. 
- ***bls12381_g2_multiexp —*** for points $g_i \in G_2$ and scalars $s_i$ calculate $\sum g_i s_i$. Can be used to multiply a group element by a scalar.
- ***bls12381_g1_map_to_curve —*** maps base field element into the $G_1$ point. Doesn’t perform mapping of the byte string into field elements. Transfer field element into a curve. It is necessary for signature schemes.
- ***bls12381_g2_map_to_curve —*** maps extension field element into the $G_2$ point. Doesn’t perform mapping of the byte string into extension field elements. 
- ***bls12381_g1_decompress —*** decompresses the points from $G_1$ provided in the compressed form.
- ***bls12381_g2_decompress —*** decompresses the points from $G_2$ provided in the compressed form.
- ***bls12381_pairing —*** verifying that $\prod e(p_i, q_i) = 1$, where $e$ is a pairing operation and $p_i \in G_1 \land q_i \in G_2$. Used to verify BLS-signatures or zkSNARKs. 

Please note that some protocols provide points on the curve in the compressed form (e.g., the light client updates in Ethereum 2.0), and decompressing is a time-consuming operation. That is why we've decided to move it into the separate functions.
All the other functions in this NEP accept only decompressed points to be simple and to have optimized gas consumption.

*multiexp* functions are useful to do zkSNARKs verification. They also could be optimized by using Pippenger algorithm[^25]. 

By using the functions introduced above, we can reproduce all functionality from EIP-2537[^15]. Which is useful for Aurora[^24] to support Ethereum functionality on Near.


## Specification

### BLS12-381 Curve Specification

#### Elliptic Curve

**Definition:** The field $F_p$ for some *prime* $p$ is a set of integer elements $\textbraceleft 0, 1, \ldots, p - 1 \textbraceright$ with two operations: multiplication $\cdot$ and addition $+$. These operations are performed as multiplication/addition for integers number and then taking the remainder modulo $p$.

**Definition:** The elliptic curve $E(F_p)$  is a set of all pairs $(x, y) \in F_p$:

$$
y^2 \equiv x^3 + Ax + B \mod p
$$

together with an imaginary point at infinity 0, where: $A, B \in F_p$, p is prime > 3, and $4A^3 + 27B^2 \not \equiv 0 \mod p$

In the case of BLS12-381 equation is $y^2 \equiv x^3 + 4 \mod p$[^15][^51][^14][^11]

**Parameters for our case:**

- $A = 0$
- $B = 4$
- $p = 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559787$

**Definition:** Let’s $P \in E(F_q)$ have coordinates (x, y), define $-P$  as a point on a curve with coordinates (x, -y).

**Definition:** The addition operation for Elliptic Curve is a function $+\colon E(F_p) \times E(F_p) \rightarrow E(F_p)$ defined with following rules: let’s P and Q $\in E(F_p)$

- if  $P \ne Q$ and $P \ne -Q$
  - draw a line passing through P and Q. This line intersects the curve at a third point R
  - reflect the point R about the x-axis by changing the sign of the y-coordinate. The resulting point is P+Q.
- if $P=Q$
  - draw a tangent line throw P for an elliptic curve. The line will intersect the curve at the second point R.
  - reflect the point R about the x-axis the same way to get point 2P
- $P = -Q$
  - $P + Q = P + (-P) = 0$ — the point on infinity
- Q = 0
  - $P + Q = P + 0 = P$

With the addition operation, Elliptic Curve forms a **group**.

#### Subgroups

**Definition:**  Subgroup H is a subset of the group G with the following properties:

- $\forall h_1, h_2 \in H\colon h_1 + h_2 \in H$
- $0 \in H$
- $\forall h \in H \colon -h \in H$

Notation: $H \subseteq G$

**Definition:** group/subgroup **order** is the number of elements in group/subgroup.

Notation: |G|  or #G, where G is group

For some technical reason (for `pairing` operation which we will define later), we will work not with the hole $E(F_p)$, but only with the two subgroups $G_1$ and $G_2$ with the same **order** $r$. $G_1$ is a subset of $E(F_p)$, $G_2$ is a subgroup of another group, which we will define later. The $r$ should be prime and $G1 \ne G2$

For our BLS12-381 Elliptic Curve, **the order r** of $G1$  and $G2$[^15][^51]:

- $r = 52435875175126190479447740508185965837690552500527637822603658699938581184513$

#### Field extension

**Definition:**  The field extension $F_{p^k}$ is a set of all polynomials with degree < k and coefficients from $F_p$ and defined operations $\cdot$ , $+$

$$
a_{k - 1}x^{k - 1} + \ldots + a_1x + a_0 = A(x) \in F_{p^k} \vert a_i \in F_p
$$

The $+$ operation is defined as a regular addition for polynomials:

$$
A(x) + B(x) = C(x)
$$

$$
\sum a_i x^i + \sum b_i x^i = \sum c_i x^i
$$

$$
c_i = (a_i + b_i) \mod p
$$

The multiplication $\cdot$ is defined as a regular polynomials’ multiplication by modulo M(x), where M(x) is an ***irreducible*** polynomial of degree k with coefficients from $F_p$

$$
C(x) = A(x) \cdot B(x)\mod M(x)
$$

Notation: $F_{p^k} = F_{p}[x] / M(x)$

In BLS12-381 we will need $F_{p^{12}}$ and we will build this field not as an extension from $F_p$ directly, but first we will build $F_{p^2}$ as a quadratic extension of field $F_p$, second we will build $F_{p^6}$ as a cubic extension of $F_{p^2}$, and finally we will build  $F_{p^{12}}$ the quadratic extension of field $F_{p^6}$.

For defining these fields, we will need to set up three $M(x)$ irreducible polynomials[^51]:

- $F_{p^2} = F_p[u] / (u^2 + 1)$
- $F_{p^6} = F_{p^2}[v] / (v^3 - u - 1)$
- $F_{p^{12}} = F_{p^6}[w]/(w^2 - v)$

Our second subgroup of order r, which we will use, is a subgroup of the same Elliptic Curve but with elements from $F_{p^{12}}$.   $G_2 \subset E(F_{p^{12}})$, where $E: y^2 = x^3 + 4$

#### Twist

Store elements from $E(F_{p^{12}})$ takes a lot of memory. ***The twist*** operation transforms the origin curve $E(F_{p^{12}})$ into another curve under another space $E'(F_{p^2})$. It is important that the new curve also has a $G'_2$  subgroup with order r and we can easily transform it to origin $G_2$.

We want to have $\psi \colon E'(F_{p^2}) \rightarrow E(F_{p^{12}})$, such as

- $\forall a, b \in E'(F_{p^2}) \colon \psi(a + b) = \psi(a) + \psi(b)$
- $\forall a, b \in E'(F_{p^2}) \colon \psi(a) = \psi(b) \Rightarrow a = b$

It is called injective group homomorphism.

For BLS12-381 E’ is defined as[^51]:

$$
E'\colon y^2 = x^3 + 4(u + 1)
$$

In most cases we will work with points from $G_2' \subset E'(F_{p^2})$ and use for this subgroup just the notation $G_2$.

#### Generators

**Definition:** if in the group $G$ exists element g, such as $\textbraceleft g, 2g, 3g, \ldots, |G|g \textbraceright = G$, the group G called ***cyclic group*** and g called ***generator***



$G_1$ and $G_2$ are cyclic subgroups with the following generators[^15][^51]:

$G_1$:

- $x = 3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507$
- $y = 1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569$

For $(x', y') \in G_2 \subset E'(F_{p^2}):$
$$x' = x_0 + x_1u$$

$$y' = y_0 + y_1u$$

$G_2$:

- $x_0 = 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160$
- $x_1 = 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758$
- $y_0 = 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905$
- $y_1 = 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582$


**Definition:** ***Cofactor*** is the ratio of the size of the whole group G to the size of subgroup H:

$$
|G|/|H|
$$

Cofactor $G_1\colon h = |E(F_p)|/r$[^51]

$$h = 76329603384216526031706109802092473003$$

Cofactor $G_2\colon h' = |E'(F_{p^2})|/r$[^51]

$$h' = 305502333931268344200999753193121504214466019254188142667664032982267604182971884026507427359259977847832272839041616661285803823378372096355777062779109$$

#### Pairing

Pairing is an operation, which we will need for digital signature verification. Pairing operation $e\colon G_1 \times G_2 \rightarrow G_T$, where $G_T \subset F_{p^{12}}$.

The main  pairing properties is:

- $e(P, Q + R) = e(P, Q) \cdot e(P, R)$
- $e(P  + S, R) = e(P, R)\cdot e(S, R)$

For calculating this function we will need the algorithm, called Miller Loop, and to effectively perform this algorithm we will need to know the key parameter for BLS curve $x$

$$ x = -15132376222941642752$$

You can find this parameter in:

- [^15] section specification, pairing parameters, miller loop scalar
- [^51] section 4.2.1 Parameter t
- [^14] section BLS12-381, parameter u
- [^11] section Curve equation and parameters, parameter x

#### Summary

The  parameters for the BLS12-381:

Base field modulus $p = 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559787$

$$
E\colon y^2 \equiv x^3 + 4
$$

$$
E'\colon y^2 \equiv x^3 + 4(u + 1)
$$

Main subgroup order $r = 52435875175126190479447740508185965837690552500527637822603658699938581184513$

$$
F_{p^2} = F_p[u] / (u^2 + 1)
$$

$$
F_{p^6} = F_{p^2}[v] / (v^3 - u - 1)
$$

$$
F_{p^{12}} = F_{p^6}[w] / (w^2 - v)
$$

Generator for G1:

- $x = 3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507$
- $y = 1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569$

Generator for G2:

- $x_0 = 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160$
- $x_1 = 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758$
- $y_0 = 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905$
- $y_1 = 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582$


Cofactor for G1:
$$h = 76329603384216526031706109802092473003$$

Cofactor for G2:
$$h' = 30550233393126834420099975319312150421446601925418814266766403298226760418297188402650742735925997784783227283904\\
1616661285803823378372096355777062779109$$

Key  BLS12-381 parameter used in Miller Loop:
$$x = -15132376222941642752$$

All parameters were taken from[^15][^51] and [^14], all of them consistent between sources.

### Map to curve specification

In this section we explain how to map the element $a \in F_p$ to the $G_1 \subset E(F_p)$ and how to map $b \in F_{p^2}$ to the $G_2 \subset E'(F_{p^2})$. 
This section will explain how functions `bls12381_map_fp_to_g1` and `bls12381_map_fp2_to_g2` work. 
It mostly duplicates the correspondent section in EIP-2537[^49].

#### Mapping algorithm

The general elliptic curve equation is $y^2 = x^3 + A \cdot x + B$. In our case $A \cdot B = 0$, so the mapping algorithm
will consist of the following steps: 

1. Field element (from $F_p$ or $F_{p^2}$) will map to some curve with $A \cdot B \ne 0$
2. Points from this curve will map to the target curve (E(Fp) or E'(Fp2)) by isomorphism
3. For mapping points to subgroup ($G_1$ or $G_2$) the cofactor will be cleared

First, we will describe the general algorithm and, next, we will provide the concrete parameters.

***Step 1: Map field element to the curve with AB != 0***

In this section we will describe `map_to_curve_simple_swu(u)` function. 
It is simplification of the Shallue-van de Woestijne-Ulas mapping described by Brier et al.[^56], which they call the “simplified SWU” map. 
Wahby and Boneh[^57] generalize and optimize this mapping.

A Weierstrass curve is $y^2 = g(x) = x^3 + A \cdot x + B$, where $A \ne 0$ and $B \ne 0$.

Constants, which we will define in the following sections:

- $A$, $B$ -- the parameters of Weierstress curve
- $Z$ the element of the field $F$ (in our case $F_p$ or $F_{p^2}$), which meeting the below criteria:
  - Z is non-square in F
  - $Z \ne -1$ in F
  - The polynomial $g(x) - Z$ is irreducible over F
  - $g(\frac{B}{Z \cdot A})$ is square in $F$.

For points $u$ and $-u$ we will get the same $x$-coordinate. We will define the $y$ sign the same as $u$ sign(see the definition of sign in sections "Compressed points on curve E(Fp)" and "Compressed points on curve E'(Fp2))".

The case when $Z^2 \cdot u^4 + Z \cdot u^2 = 0$ should be handled separately. In that case set $x_1 = \frac{B}{X \cdot A}$,
which guarantees that $g(x_1)$ is square by the condition on Z given above.

The algorithm:

```text
fn map_to_curve_simple_swu(u) {
    let tv1 = 1 / (Z^2 * u^4 + Z * u^2);
    let x1 = (-B / A) * (1 + tv1);
    if tv1 == 0 {
        x1 = B/(Z*A);
    }
    
    let gx1 = x1^3 + A*x1 + B;
    let x2 = Z * u^2 + x1;
    let gx2 = x2^3 + A*x2 + B;
    let (x, y) = if is_squere(gx1) {
        (x1, sqrt(gx1));
    } else {
        (x2, sqrt(gx2));
    }
    
    if sign(u) != sign(y) {
       y = -y;
    }
    
    return (x, y);
}

```

***Step 2: Map to target curve***

The function `iso_map(x_inner, y_inner)` map the points from isogenous curve E_inner with no-zero coefficients to our
target elliptic curve E. 

Wahby and Boneh[^57] show how to adopt the algorithm for case when elliptic curve have zero A or B. The idea: map
the F element to isogenous elliptic curve E_inner by the method from previous section, and then transform E_inner curve
to our target curve E by knowing isogeny. 

E_inner curve with isogeny will be defined in the "Parameters" section.

Note that `iso_map` is a group homomorphism. This mean `iso_map(p) + iso_map(q) = iso_map(p + q)`. So, the correspondent optimization can be applied.

If any denominator in rational functions used in `iso_map` function equal to zero, the `iso_map` function
must return identity point on E.

***Step 3: Map to subgroup(cofactor cleaning)***

In this section we will describe the function `clear_cofactor((x, y))`. This function transfer a point from $E(F_p)$ or $E'(F_{p^2})$ 
into a point in $G_1 \subset E(F_p)$ or $G_2 \subset E'(F_{p^2})$ respectively. 

To do that, we should multiply the point on the curve by effective cofactor `h_eff`. Multiplication on `h_eff` gives the
results in the same subset as multiplication on cofactor, but can be executed must faster. The value of `h_eff` will be given in
the following sections.

```text
fn clear_cofactor(P) {
    h_eff * P
}

```

***Full algorithm***

In this section, the pseudocode for the full mapping algorithm is shown. All the functions are described in the sections above.

```text
1. (x_inner, y_inner) = map_to_curve_simple_swu(u)    # (x_inner, y_inner) is on E_inner - the helper elliptic curve with AB != 0
2. (x, y) = iso_map(x_inner, y_inner)                 # (x, y) is on E
3. (x, y) = clear_cofactor((x, y))                    # clears cofactor for point (x, y) on E
4. return (x, y)
```

#### Parameters

***Fp-to-G1 mapping***

**Step 1:** E_inner: $y^2 = x^3 + A \cdot x + B$ parameters:

- $A = 12190336318893619529228877361869031420615612348429846051986726275283378313155663745811710833465465981901188123677$
- $B = 2906670324641927570491258158026293881577086121416628140204402091718288198173574630967936031029026176254968826637280$
- Z = 11

**Step 2:** Isogeny from E_inner to curve $E(F_p)$:

Let's we have the point on E_inner with coordinates $(x_{inner}, y_{inner})$ and
we would like to calculate the correspondent coordinates $(x, y) \in E(F_p)$.  

- $x = \frac{x_{num}}{x_{den}}$ where
  
  $$x_{num} = \sum_{i=0}^{11} k_{(1, i)} \cdot x_{inner}^i$$
  
  $$x_{den} = x_{inner}^{10} + \sum_{i=0}^{9} k_{(2, i)} \cdot x_{inner}^i$$

- $y = y_{inner} \cdot \frac{y_{num}}{y_{den}}$:

  $$y_{num} = \sum_{i=0}^{15} k_{(3, i)} \cdot x_{inner}^i$$
  
  $$y_{den} = x_{inner}^{15} + \sum_{i=0}^{14} k_{(4, i)} \cdot x_{inner}^i$$

The constants to compute $x_{num}$:

- $k_{(1,0)} = 2712959285290305970661081772124144179193819192423276218370281158706191519995889425075952244140278856085036081760695$
- $k_{(1,1)} = 3564859427549639835253027846704205725951033235539816243131874237388832081954622352624080767121604606753339903542203$
- $k_{(1,2)} = 2051387046688339481714726479723076305756384619135044672831882917686431912682625619320120082313093891743187631791280$
- $k_{(1,3)} = 3612713941521031012780325893181011392520079402153354595775735142359240110423346445050803899623018402874731133626465$
- $k_{(1,4)} = 2247053637822768981792833880270996398470828564809439728372634811976089874056583714987807553397615562273407692740057$
- $k_{(1,5)} = 3415427104483187489859740871640064348492611444552862448295571438270821994900526625562705192993481400731539293415811$
- $k_{(1,6)} = 2067521456483432583860405634125513059912765526223015704616050604591207046392807563217109432457129564962571408764292$
- $k_{(1,7)} = 3650721292069012982822225637849018828271936405382082649291891245623305084633066170122780668657208923883092359301262$
- $k_{(1,8)} = 1239271775787030039269460763652455868148971086016832054354147730155061349388626624328773377658494412538595239256855$
- $k_{(1,9)} = 3479374185711034293956731583912244564891370843071137483962415222733470401948838363051960066766720884717833231600798$
- $k_{(1,10)} = 2492756312273161536685660027440158956721981129429869601638362407515627529461742974364729223659746272460004902959995$
- $k_{(1,11)} = 1058488477413994682556770863004536636444795456512795473806825292198091015005841418695586811009326456605062948114985$

The constants to compute $x_{den}$:

- $k_{(2,0)} = 1353092447850172218905095041059784486169131709710991428415161466575141675351394082965234118340787683181925558786844$
- $k_{(2,1)} = 2822220997908397120956501031591772354860004534930174057793539372552395729721474912921980407622851861692773516917759$
- $k_{(2,2)} = 1717937747208385987946072944131378949849282930538642983149296304709633281382731764122371874602115081850953846504985$
- $k_{(2,3)} = 501624051089734157816582944025690868317536915684467868346388760435016044027032505306995281054569109955275640941784$
- $k_{(2,4)} = 3025903087998593826923738290305187197829899948335370692927241015584233559365859980023579293766193297662657497834014$
- $k_{(2,5)} = 2224140216975189437834161136818943039444741035168992629437640302964164227138031844090123490881551522278632040105125$
- $k_{(2,6)} = 1146414465848284837484508420047674663876992808692209238763293935905506532411661921697047880549716175045414621825594$
- $k_{(2,7)} = 3179090966864399634396993677377903383656908036827452986467581478509513058347781039562481806409014718357094150199902$
- $k_{(2,8)} = 1549317016540628014674302140786462938410429359529923207442151939696344988707002602944342203885692366490121021806145$
- $k_{(2,9)} = 1442797143427491432630626390066422021593505165588630398337491100088557278058060064930663878153124164818522816175370$


The constants used to compute $y_{num}$:

- $k_{(3,0)} = 1393399195776646641963150658816615410692049723305861307490980409834842911816308830479576739332720113414154429643571$
- $k_{(3,1)} = 2968610969752762946134106091152102846225411740689724909058016729455736597929366401532929068084731548131227395540630$
- $k_{(3,2)} = 122933100683284845219599644396874530871261396084070222155796123161881094323788483360414289333111221370374027338230$
- $k_{(3,3)} = 303251954782077855462083823228569901064301365507057490567314302006681283228886645653148231378803311079384246777035$
- $k_{(3,4)} = 1353972356724735644398279028378555627591260676383150667237975415318226973994509601413730187583692624416197017403099$
- $k_{(3,5)} = 3443977503653895028417260979421240655844034880950251104724609885224259484262346958661845148165419691583810082940400$
- $k_{(3,6)} = 718493410301850496156792713845282235942975872282052335612908458061560958159410402177452633054233549648465863759602$
- $k_{(3,7)} = 1466864076415884313141727877156167508644960317046160398342634861648153052436926062434809922037623519108138661903145$
- $k_{(3,8)} = 1536886493137106337339531461344158973554574987550750910027365237255347020572858445054025958480906372033954157667719$
- $k_{(3,9)} = 2171468288973248519912068884667133903101171670397991979582205855298465414047741472281361964966463442016062407908400$
- $k_{(3,10)} = 3915937073730221072189646057898966011292434045388986394373682715266664498392389619761133407846638689998746172899634$
- $k_{(3,11)} = 3802409194827407598156407709510350851173404795262202653149767739163117554648574333789388883640862266596657730112910$
- $k_{(3,12)} = 1707589313757812493102695021134258021969283151093981498394095062397393499601961942449581422761005023512037430861560$
- $k_{(3,13)} = 349697005987545415860583335313370109325490073856352967581197273584891698473628451945217286148025358795756956811571$
- $k_{(3,14)} = 885704436476567581377743161796735879083481447641210566405057346859953524538988296201011389016649354976986251207243$
- $k_{(3,15)} = 3370924952219000111210625390420697640496067348723987858345031683392215988129398381698161406651860675722373763741188$


The constants to compute $y_{den}$:

- $k_{(4,0)} = 3396434800020507717552209507749485772788165484415495716688989613875369612529138640646200921379825018840894888371137$
- $k_{(4,1)} = 3907278185868397906991868466757978732688957419873771881240086730384895060595583602347317992689443299391009456758845$
- $k_{(4,2)} = 854914566454823955479427412036002165304466268547334760894270240966182605542146252771872707010378658178126128834546$
- $k_{(4,3)} = 3496628876382137961119423566187258795236027183112131017519536056628828830323846696121917502443333849318934945158166$
- $k_{(4,4)} = 1828256966233331991927609917644344011503610008134915752990581590799656305331275863706710232159635159092657073225757$
- $k_{(4,5)} = 1362317127649143894542621413133849052553333099883364300946623208643344298804722863920546222860227051989127113848748$
- $k_{(4,6)} = 3443845896188810583748698342858554856823966611538932245284665132724280883115455093457486044009395063504744802318172$
- $k_{(4,7)} = 3484671274283470572728732863557945897902920439975203610275006103818288159899345245633896492713412187296754791689945$
- $k_{(4,8)} = 3755735109429418587065437067067640634211015783636675372165599470771975919172394156249639331555277748466603540045130$
- $k_{(4,9)} = 3459661102222301807083870307127272890283709299202626530836335779816726101522661683404130556379097384249447658110805$
- $k_{(4,10)} = 742483168411032072323733249644347333168432665415341249073150659015707795549260947228694495111018381111866512337576$
- $k_{(4,11)} = 1662231279858095762833829698537304807741442669992646287950513237989158777254081548205552083108208170765474149568658$
- $k_{(4,12)} = 1668238650112823419388205992952852912407572045257706138925379268508860023191233729074751042562151098884528280913356$
- $k_{(4,13)} = 369162719928976119195087327055926326601627748362769544198813069133429557026740823593067700396825489145575282378487$
- $k_{(4,14)} = 2164195715141237148945939585099633032390257748382945597506236650132835917087090097395995817229686247227784224263055$

**Step 3:** Effective cofactor:

$$h_{eff} = 15132376222941642753$$

***Fp2-to-G2 mapping***

**Step 1:** E_inner: $y^2 = x^3 + A \cdot x + B$ parameters:

- A = $240 \cdot I$
- B = $1012 \cdot (1 + I)$
- Z = $-(2 + I)$

Note: $I$ means a non-residue used to make an extension field $F_{p^2}$

**Step 2:** Isogeny from E_inner to curve $E'(F_{p^2})$:

Let's we have the point on E_inner with coordinates $(x_{inner}, y_{inner})$ and
we would like to calculate the correspondent coordinates $(x, y) \in E'(F_{p^2})$.

- $x = \frac{x_{num}}{x_{den}}$ where

  $$x_{num} = \sum_{i = 0}^{3} k_{1, i} \cdot x_{inner}^i$$
  
  $$x_{den} = x_{inner}^2 + \sum_{i=0}^{1} k_{2, i} \cdot x_{inner}^i$$

- $y = y_{inner} \cdot \frac{y_num}{y_den}$:
  
  $$y_{num} = \sum_{i = 0}^{3} k_{3, i} \cdot x_{inner}^i$$
  
  $$y_{den} = x_{inner}^{3} + \sum_{i = 0}^{2} k_{4, i} \cdot x_{inner}^i$$

The constants used to compute $x_{num}$ are as follows:

- $$k_{(1,0)} = 889424345604814976315064405719089812568196182208668418962679585805340366775741747653930584250892369786198727235542 + 
             889424345604814976315064405719089812568196182208668418962679585805340366775741747653930584250892369786198727235542 \cdot I$$

- $$k_{(1,1)} = 2668273036814444928945193217157269437704588546626005256888038757416021100327225242961791752752677109358596181706522 \cdot I$$

- $$k_{(1,2)} = 2668273036814444928945193217157269437704588546626005256888038757416021100327225242961791752752677109358596181706526 +
             1334136518407222464472596608578634718852294273313002628444019378708010550163612621480895876376338554679298090853261 \cdot I$$

- $$k_{(1,3)} = 3557697382419259905260257622876359250272784728834673675850718343221361467102966990615722337003569479144794908942033$$

The constants used to compute $x_{den}$ are as follows:

- $$k_{(2,0)} = 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559715 \cdot I$$

- $$k_{(2,1)} = 12 + 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559775 \cdot I$$

The constants used to compute $y_{num}$ are as follows:

- $$k_{(3,0)} = 3261222600550988246488569487636662646083386001431784202863158481286248011511053074731078808919938689216061999863558 +\\
             3261222600550988246488569487636662646083386001431784202863158481286248011511053074731078808919938689216061999863558 \cdot I$$

- $$k_{(3,1)} = 889424345604814976315064405719089812568196182208668418962679585805340366775741747653930584250892369786198727235518 \cdot I$$

- $$k_{(3,2)} = 2668273036814444928945193217157269437704588546626005256888038757416021100327225242961791752752677109358596181706524 +
             1334136518407222464472596608578634718852294273313002628444019378708010550163612621480895876376338554679298090853263 \cdot I$$

- $$k_{(3,3)} = 2816510427748580758331037284777117739799287910327449993381818688383577828123182200904113516794492504322962636245776$$

The constants used to compute $y_{den}$ are as follows:

- $$k_{(4,0)} = 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559355 + 
             4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559355 \cdot I$$

- $$k_{(4,1)} = 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559571 \cdot I$$

- $$k_{(4,2)} = 18 + 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559769 \cdot I$$

**Step 3:** Effective cofactor:

- $$h_{eff} = 209869847837335686905080341498658477663839067235703451875306851526599783796572738804459333109033834234622528588876978987822447936461846631641690358257586228683615991308971558879306463436166481$$

### Curve points encoding

#### Bool as output

The bool is encoded as a little-endian `u64` type in Rust. The `true` value is encoded as `1` and `false` is encoded as `0`. All other values of `u64` are not allowed and should be interpreted as incorrect. Encoding is the same as for Alt-BN128 implementation in nearcore[^50].

#### Sign

The sign of the point on the elliptic curve is encoded as `u8` type in Rust with two possible values: `0` and `1`. `0` for positive sign, and `1` for negative sign. All other value of `u8` is not allowed and should be interpreted as incorrect.

#### Scalar

The scalar value is encoded as a big-endian `[u8;32]`. All possible bytes combination is allowed. Encoding is similar with Alt-BN128 implementation in nearcore[^50], but `big-endian` encoding is used instead of `little-endian` as in EIP-2537[^15].

#### Fields elements Fp

The value from $F_p$ is encoded as a big-endian `[u8; 48]`. Only values less than `p` are allowed. If the value is equal to or bigger than `p` the error should be returned.

The rule of encoding is consistent with zkcrypto[^53], with implementation in milagro lib[^29].

#### Extension fields elements Fp2

The $q \in F_{p^{2}}$ could be written as $q = c_0 + c_1 v$, where $c_0, c_1 \in F_p$ The element from $F_{p^2}$ encoded in `[u8; 96]` as a bytes’ concatenation of $c_1$ and $c_0$. The $c_1$ and $c_0$ are encoded by the rule described in the previous section.

$q \in F_{p^2}$, $q = c_0 + c_1 v$ encoded as `[u8; 96]`:

- $c_1 \in F_p$ `[u8; 48]`
- $c_0 \in F_p$ `[u8; 48]`

The rule of encoding is consistent with zkcrypto[^53] and with implementation in milagro lib[^29].

#### Uncompressed points on curve E(Fp)

The points on the curve represent by affine coordinates: `(x: Fp, y: Fp)`. The elements from $E(F_p)$ encoded in `[u8; 96]` as bytes’ concatenation of `x` and `y` point coordinates, where $x, y \in F_p$. The $x, y$ are encoded according to the rules described in the section “Fields elements $F_p$” .

$E(F_p)$  is encoded as `[u8; 96]`:

- $x \in F_p$ `[u8; 48]`
- $y \in F_p$ `[u8; 48]`

*The second bit* is used to mark a point on infinity, if the second bit is set to 1 — it is an infinity point.

Encoding point on infinity:

```bash
let x: [u8; 96] = [0; 96];
x[0] = x[0] | 0x40;
```

The rule of encoding is consistent with zkcrypto[^53] and with implementation in milagro lib[^29].

#### Compressed points on curve E(Fp)

The points on the curve represent by affine coordinates: `(x: Fp, y: Fp)`. The elements from $E(F_p)$ in compressed form are encoded in `[u8; 48]` as *big-endian* encoded $x \in F_p$. The $y$  coordinate can be detected by the formula: $y = \pm \sqrt{x^3 + 4}$.

*The first bit* should be set as 1. This bit indicates that point is encoded in compressed form.

*The second bit* is used to mark a point on infinity, if the second bit is set to 1 — it is an infinity point.

To represent the sign of the $y$ *the third bit* of x encoding is used. If the first bit = 0 the $y$ is positive, if the first bit = 1 the $y$ is negative. We will consider the number positive the smallest between $y$  and $-y = p - y$.

The $x \in F_p$ encoded as `[u8; 48]` bytes according to the rules from section  “Extension fields elements $F_{p}$” .

The point on $E(F_p)$ with negative $y$ coordinate encoded as `[u8; 48]` bytes:

```rust
let x: [u8; 48] = encodeFp(x)
x[0] = x[0] | 0x80;
x[0] = x[0] | 0x20;
```

For encoding point of infinity:

```rust
let x: [u8; 48] = [0; 48];
x[0] = x[0] | 0x80;
x[0] = x[0] | 0x40;
```

The rule of encoding is consistent with zkcrypto[^53] and with implementation in milagro lib[^29].

#### Uncompressed points on twisted curve E'(Fp2)

The points on the curve represent by affine coordinates: `(x: Fp2, y: Fp2)`. The elements from $E'(F_{p^2})$ encoded in `[u8; 192]` as bytes’ concatenation of `x` and `y` point coordinates, where $x, y \in F_{p^2}$. The $x, y$ are encoded according to the rules described in the section “Extension fields elements $F_{p^2}$” .

$E'(F_{p^2})$  is encoded as `[u8; 192]`:

- $x \in F_{p^2}$ `[u8; 96]`:
  - $c_1 \in F_p$ `[u8; 48]`
  - $c_0 \in F_p$ `[u8; 48]`
- $y \in F_{p^2}$ `[u8; 96]`:
  - $c_1 \in F_p$ `[u8; 48]`
  - $c_0 \in F_p$ `[u8; 48]`

*The second bit* is used to mark a point on infinity, if the second bit is set to 1 — it is an infinity point.

Encoding point on infinity:

```bash
let x: [u8; 192] = [0; 192];
x[0] = x[0] | 0x40;
```

The rule of encoding is consistent with zkcrypto[^53] and with implementation in milagro lib[^29].

#### Compressed points on twisted curve E'(Fp2)

The points on the curve represent by affine coordinates: `(x: Fp2, y: Fp2)`. The elements from $E'(F_{p^2})$ in compressed form are encoded in `[u8; 96]` as *big-endian* encoded $x \in F_{p^2}$. The $y$  coordinate can be detected by the formula: $y = \pm \sqrt{x^3 + 4}$.

*The first bit* should be set as 1. This bit indicates that point is encoded in compressed form.

*The second bit* is used to mark a point on infinity, if the second bit is set to 1 — it is an infinity point.

To represent the sign of the $y$ *the third bit* of x encoding is used. If the first bit = 0 the $y$ is positive, if the first bit = 1 the $y$ is negative. We will consider the number positive the smallest between $y$  and $-y$: first compare $c_1$ and second $c_0$.

The $x \in F_{p^2}$ encoded as `[u8; 96]` bytes according to the rules from section  “Extension fields elements $F_{p^2}$” .

The point on $E'(F_{p^2})$ with negative $y$ coordinate encoded as `[u8; 96]` bytes:

```rust
let x: [u8; 96] = encodeFp2(x);
x[0] = x[0] | 0x80;
x[0] = x[0] | 0x20;
```

Encoding point of infinity:

```rust
let x: [u8; 96] = [0; 96];
x[0] = x[0] | 0x80;
x[0] = x[0] | 0x40;
```

The rule of encoding is consistent with zkcrypto[^53] and with implementation in milagro lib[^29].

### Host functions

#### bls12381_g1_sum

***Description:***

The function computes the sum of the signed elements of the BLS12-381 curve. The input is an arbitrary number of pairs $(p_i, s_i)$, where $p_i \in E(F_p)$ is point on elliptic curve and $s_i \in \textbraceleft 0, 1 \textbraceright$ is the point sign. The output is one point from $E(F_p)$ equal to $\sum (-1)^{s_i}p_i$.

The $E(F_p)$ curve,  points on the curve, multiplication on -1,  and the addition operation are defined in the BLS12-381 Curve Specification section.

Note: we take as input any points on the curve, not only from   $G_1$

***Input:*** the sequence of pairs $(p_i, s_i)$, where $p_i \in E(F_p)$ is point and $s_i \in \textbraceleft 0, 1 \textbraceright$ is sign, each point encoded in decompress form as $(x\colon F_p, y\colon F_p)$ and sign encoded in one byte with only two allowed values: 0, 1. Expected `97*k` bytes as an input that is interpreted as byte concatenation of `k` slices, each slice is the uncompressed point from $E(F_p)$ and a bool value for point sign. More details are in the Curve Points Encoding section.

***Output:*** the output is 96 bytes — the one point $\in E(F_p)$ in decompressed form. For empty input it returns point on infinity(see  Curve Points Encoding section).

***Gas Estimation:***

The algorithm has a linear complexity of the number of elements. The gas can be calculated by the next formula

```rust
let k = (input_bytes + item_size - 1)/item_size
let gas_consumed = A + B * k
```

A and B are constants calculated empirically.

Here you can find benchmark test vectors for EIP-2537[^46]. It doesn’t contain a sum function, but we can adopt the test vector for addition by duplicating it many times.

***Test cases:***

- Correct points in G1 group
- One of the points is 0
- One of the points is not in G1 group but on the curve
- The result is 0
- Correct addition with one point
- Point not on the curve
- The coding of field elements is incorrect, but if take only the suffix it will be the correct point on the curve
- The coding of field elements is incorrect, but by modulo p it is a correct element on the curve
- The coding of field elements is incorrect, an incorrect extra bit, which shows that it is decompressed encoding.
- Sum with the maximum number of elements
- Too many points for sum
- Incorrect len of input
- Empty input
- Generate points on the curve and check that the result doesn’t depend on permutation
- Generate points and cross-test the result with multiexp function.
- Correct input with negative signs
- Incorrect sign value (not 0 or 1)
- Correct input with negative signs for points with $y > \frac{p}{2}$
- Sum of the two equal points with opposite sign

***Tests References:***

We can use all the tests for addition for Ethereum([^47], [^48]) to check the case with k = 2. Also, we can reuse the `error` points. Can use the vectors for multiexp functions if separately perform multiplication.

***Error cases:***

- The input length is not divided by 97
- Too much memory is used
- Field elements encoded incorrectly (see Curve points encoded section)
- Any points not on the curve
- The sign value is not 0 or 1

***Annotation:***

```rust
/// Computes sum for signed elements on BLS12-381 curve 
/// \sum_i (-1)^{s_i} p_i should be the equal result.
///
/// # Arguments
///
/// * `value` - sequence of (pi, si) where pi is point(x:Fp, y:Fp) on BLS-381 curve and si is sign (0 for +, and 1 for -)
///    BLS12-381 is Y^2 = X^3 + 4 curve over Fp.
///
///   `value` is encoded as packed, big-endian
///   `[([u8; 48], [u8; 48])]` slice.
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory or the registers
/// use more memory than the limit, the function returns `MemoryAccessViolation`.
///
/// If (1) point coordinates are not on curve or (2) `value.len()%97 != 0` or (3) value of sign is not 0 or 1
/// the function returns `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes +
/// bls12381_g1_sum_base + bls12381_g1_sum_element * num_elements`
pub fn bls12381_g1_sum(&mut self, 
                       value_len: u64, 
                       value_ptr: u64, 
                       register_id: u64) -> Result<()>;
```

#### bls12381_g2_sum

***Description:***

The function computes the sum of the signed elements of the BLS12-381 curve. The input is an arbitrary number of pairs $(p_i, s_i)$, where $p_i \in E'(F_{p^2})$ is point on elliptic curve and $s_i \in \textbraceleft 0, 1 \textbraceright$ is the point sign. The output is one point from $E'(F_{p^2})$ equal to $\sum (-1)^{s_i}p_i$.

The $E'(F_{p^2})$ curve,  points on the curve, multiplication on -1, and the addition operation are defined in the BLS12-381 Curve Specification section.

Note: we take as input any points on the curve, not only from $G_2$

***Input:*** the sequence of pairs $(p_i, s_i)$, where $p_i \in E'(F_{p^2})$ is point and $s_i \in \textbraceleft 0, 1 \textbraceright$ is sign, each point encoded in decompress form as $(x\colon F_{p^2}, y\colon F_{p^2})$ and sign encoded in one byte. Expected `193*k` bytes as an input that is interpreted as byte concatenation of `k` slices, each slice is the uncompressed point from $E'(F_{p^2})$ and the point sign. More details are in the Curve Points Encoding section.

***Output:*** the output is 192 bytes — the one point $\in E'(F_{p^2})$ in decompressed form. For empty input it returns point on infinity(see  Curve Points Encoding section).

***Gas Estimation:***

The algorithm has a linear complexity of the number of elements. The gas can be calculated by the next formula

```rust
let k = (input_bytes + item_size - 1)/item_size
let gas_consumed = A + B * k
```

A and B are constants calculated empirically.

Here you can find benchmark test vectors for EIP-2537[^46]. It doesn’t contain a sum function, but we can adopt the test vector for addition by duplicating it many times.

***Test cases:***

The same as for **`bls12381_g1_sum`** only change points from $G_1$ and $E(F_p)$ into $G_2$ and $E'(F_{p^2})$.

***Tests References:***

We can use all the tests for addition for Ethereum[^47][^48] to check the case with k = 2. Also, we can reuse the `error` points. Can use the vectors for multiexp functions if separately perform multiplication.

***Error cases:***

- The input length is not divided by 193
- Too much memory is used
- Extension field elements encoded incorrectly (see Curve points encoded section)
- Any points not on the curve
- The sign value is not 0 or 1

***Annotation:***

```rust
/// Computes sum for signed elements on BLS12-381 curve 
/// \sum_i (-1)^{s_i} p_i should be the equal result.
///
/// # Arguments
///
/// * `value` - sequence of (pi, si), where pi is point(x:Fp^2, y:Fp^2) on BLS-381 curve and si is sign (0 for +, 1 for -) 
///    BLS12-381 is Y^2 = X^3 + 4(i + 1) curve over Fp^2.
///
///   `value` is encoded as packed, big-endian
///   `[(([u8; 96], [u8; 96]), u8)]` slice.
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory or the registers
/// use more memory than the limit, the function returns `MemoryAccessViolation`.
///
/// If (1) point coordinates are not on curve or (2) `value.len()%193 != 0` or (3) sign is not 0 or 1,
/// the function returns `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes +
/// bls12381_g2_sum_base + bls12381_g2_sum_element * num_elements`
pub fn bls12381_g2_sum(&mut self, 
                       value_len: u64, 
                       value_ptr: u64, 
                       register_id: u64) -> Result<()>;
```

#### ***bls12381_g1_multiexp***

***Description:***

The function takes as input the list of pairs $(p_i, s_i)$, where $p_i \in E(F_p)$ is a point on the curve and $s_i \in \mathbb{N}_0$ is a scalar. The function calculates $\sum s_i \cdot p_i$.

The multiplication on the scalar is the addition of that point a scalar number of times:

$$
s \cdot p = \underbrace{p + p + \ldots + p}_{s}
$$

The $E(F_p)$ curve,  points on the curve and the addition operation are defined in the BLS12-381 Curve Specification section.

Note:

- We take as input any points on the curve, not only from   $G_1$.
- The scalar is an arbitrary unsigned integer and can be bigger than the group order.

***Input:*** the sequence of pairs $(p_i, s_i)$, where $p_i \in E(F_p)$ is a point on the curve and $s_i \in \mathbb{N}_0$ is a scalar. Each point is encoded in decompress form as $(x\colon F_p, y\colon F_p)$ and a scalar has a type `u256` and BigEndian encoded in 32 bytes. Expected `128*k` bytes as an input that is interpreted as byte concatenation of `k` slices, each slice is the concatenation of uncompressed point from $E(F_p)$ — `96` bytes and scalar — `32` bytes. More details are in the Curve Points Encoding section.

***Output:*** the output is 96 bytes — the one point $\in E(F_p)$ in decompressed form. For empty input it returns point on infinity(see  Curve Points Encoding section).

***Gas Estimation:***

This function should be calculated by Pippenger’s algorithm[^25]. The Complexity of this algorithm is $O(\frac{k}{\log(k)})$. For gas calculation we will use the formula $\frac{k}{\max(\log_2(k), 1)}$ the same way as in the host function for `Alt-BN128`[^10].

```rust
let k = (input_bytes+item_size-1)/item_size;
let gas_consumed = A + B*k + C * if k > 1 {k / (k as f32).log2().floor()} else {k};
```

A, B and C are constants calculated empirically.

For gas estimation, we can use the benchmark vectors for addition and multiplication for EIP-2537[^46].

***Test cases:***

The same test cases as for the bls12381_g1_sum section.

Addition test cases:

- `group_order * P = 0`
- `(scalar + groupt_order) * P = scalar * P`
- `P + P + P .. + P = N*P`
- `0 * P = 0`
- `1 * P = P`
- Scalar is a MAX_INT

***Tests References:***

The EIP-2537 contains the same function, so we can reuse test vectors from Ethereum[^47][^48].

***Error cases:***

- The input length is not divided by 128
- Too much memory is used
- Field elements encoded incorrectly (see Curve points encoded section)
- Any points not on the curve

***Annotation:***

```rust
/// Computes multiexp on BLS12-381 curve using Pippenger's algorithm 
///\sum_i si*pi should be equal result.
///
/// # Arguments
///
/// * `value` - sequence of (pi, si), where
///    pi is point (x:Fp, y:Fp) on BLS12-381, and si is u256.
///    BLS12-381 is Y^2 = X^3 + 4 curve over Fp.
///
///   `value` is encoded as packed, big-endian
///   `[(([u8; 48], [u8; 48]), u256)]` slice.
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory or the registers
/// use more memory than the limit, the function returns
/// `MemoryAccessViolation`.
///
/// If point coordinates are not on curve, point is not in the subgroup,
/// scalar is not in the field or  `value.len()%128!=0`, the function returns
/// `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes +
///  bls12381_g1_multiexp_base +
///  bls12381_g1_multiexp_element * num_elements + 
///  bls12381_g1_multiexp_element_div_log * num_elements/max(1, log(num_elements))`
pub fn bls12381_g1_multiexp(
        &mut self,
        value_len: u64,
        value_ptr: u64,
        register_id: u64,
) -> Result<()>;
```

#### ***bls12381_g2_multiexp***

***Description:***

The function takes as input the list of pairs $(p_i, s_i)$, where $p_i \in E'(F_{p^2})$ is a point on the curve and $s_i \in \mathbb{N}_0$ is a scalar. The function calculates $\sum s_i \cdot p_i$.

The multiplication on the scalar is the addition of that point a scalar number of times:

$$
s \cdot p = \underbrace{p + p + \ldots + p}_{s}
$$

The $E'(F_{p^2})$ curve,  points on the curve and the addition operation are defined in the BLS12-381 Curve Specification section.

Note:

- We take as input any points on the curve, not only from $G_2$.
- The scalar is an arbitrary unsigned integer and can be bigger than the group order.

***Input:*** the sequence of pairs $(p_i, s_i)$, where $p_i \in E'(F_{p^2})$ is a point on the curve and $s_i \in \mathbb{N}_0$ is a scalar. 

Each point is encoded in decompress form as $(x\colon F_{p^2}, y\colon F_{p^2})$ and a scalar has a type `u256` and BigEndian encoded in 32 bytes. Expected `224*k` bytes as an input that is interpreted as byte concatenation of `k` slices, each slice is the concatenation of uncompressed point from $E'(F_{p^2})$ — `192` bytes and scalar — `32` bytes. More details are in the Curve Points Encoding section.

***Output:*** the output is 192 bytes — the one point $\in E'(F_{p^2})$ in decompressed form. For empty input it returns point on infinity(see Curve Points Encoding section).

***Gas Estimation:***

This function should be calculated by Pippenger’s algorithm[^25]. The Complexity of this algorithm is $O(\frac{k}{\log(k)})$. For gas calculation we will use the formula $\frac{k}{\max(\log_2(k), 1)}$ the same way as in the host function for `Alt-BN128`[^10].

```rust
let k = (input_bytes+item_size-1)/item_size;
let gas_consumed = A + B*k + C * if k > 1 {k / (k as f32).log2().floor()} else {k};
```

A, B and C are constants calculated empirically.

For gas estimation, we can use the benchmark vectors for addition and multiplication for EIP-2537[^46].

***Test cases:***

The same as for **`bls12381_g1_multiexp`** only change points from $G_1$ and $E(F_p)$ into $G_2$ and $E'(F_{p^2})$.

***Tests References:***

The EIP-2537 contains the same function, so we can reuse test vectors from Ethereum[^47][^48].

***Error cases:***

- The input length is not divided by 224
- Too much memory is used
- Field elements encoded incorrectly (see Curve points encoded section)
- Any points not on the curve

***Annotation:***

```rust
/// Computes multiexp on BLS12-381 curve using Pippenger's algorithm 
///\sum_i si*pi should be equal result.
///
/// # Arguments
///
/// * `value` - sequence of (pi, si), where
///    pi is point (x:Fp^2, y:Fp^2) on BLS12-381, and si is u256.
///    BLS12-381 is Y^2 = X^3 + 4(i + 1) curve over Fp^2.
///
///   `value` is encoded as packed, big-endian
///   `[(([u8; 96], [u8; 96]), u256)]` slice.
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory or the registers
/// use more memory than the limit, the function returns
/// `MemoryAccessViolation`.
///
/// If point coordinates are not on curve, point is not in the subgroup,
/// scalar is not in the field or  `value.len()%224!=0`, the function returns
/// `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes +
///  bls12381_g2_multiexp_base +
///  bls12381_g2_multiexp_element * num_elements + 
///  bls12381_g2_multiexp_element_div_log * num_elements/max(1, log(num_elements))`
pub fn bls12381_g2_multiexp(
        &mut self,
        value_len: u64,
        value_ptr: u64,
        register_id: u64,
) -> Result<()>;
```

#### bls12381_map_fp_to_g1

***Description:***

The function takes the element $a \in F_p$ and maps it to the $G_1 \subset E(F_p)$. The specification of the mapping function you can find in the section "Map to curve specification". This function does NOT perform mapping of the byte string into $F_p$, it can be implemented in different ways and this can be performed effectively in contract.

***Input:*** the function takes as input `48` bytes — the element from $F_p$ (one unsigned integer $< p$). More details are in the Curve Points Encoding section.

***Output:*** the output is `96 bytes` — one point $\in G_1 \subset E(F_p)$ in decompressed format. More details are in the Curve Points Encoding section.

***Gas Estimation:***

The gas consumption is a constant calculated empirically.

***Test cases:***

- Correct $F_p$ element
- $a = 0$
- $a \ge p$
- Edge cases for inner algorithms for mapping[^49]

***Tests References:*** The EIP-2537 contains the same function, so we can reuse test vectors from Ethereum[^47][^48].

***Error cases:***

- Incorrect input length
- $a \ge p$

***Annotation:***

```rust
/// Map elements from Fp to G1 subset of BLS12-381 curve
///
/// # Arguments
///
/// * `value` - 48 bytes, the element from Fp -- unsigned integer < p 
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory or the registers
/// use more memory than the limit, the function returns
/// `MemoryAccessViolation`.
///
/// If value_len != 48 or the value >= p the function return `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes +
///  bls12381_map_fp_to_g1_base`
pub fn bls12381_map_fp_to_g1(
        &mut self,
        value_len: u64,
        value_ptr: u64,
        register_id: u64,
) -> Result<()>;
```

#### bls12381_map_fp2_to_g2

***Description:***

The function takes the element $a \in F_{p^2}$ and maps it to the $G_2 \subset E'(F_{p^2})$. The specification of the mapping function you can find in the section "Map to curve specification". This function does NOT perform mapping of the byte string into $F_{p^2}$, it can be implemented in different ways and this can be performed effectively in the contract.

***Input:*** the function takes as input `96 bytes` — the element from $F_{p^2}$ (two unsigned integers $< p$). More details are in the Curve Points Encoding section.

***Output:*** the output is `192 bytes` — one point $\in G_2 \subset E'(F_{p^2})$ in decompressed format. More details are in the Curve Points Encoding section.

***Gas Estimation:***

The gas consumption is a constant calculated empirically.

***Test cases:***

- Correct $F_{p^2}$ element
- $a = 0$
- One of the `a` value $\ge p$
- Edge cases for inner algorithms for mapping[^49]

***Tests References:*** The EIP-2537 contains the same function, so we can reuse test vectors from Ethereum[^47][^48].

***Error cases:***

- Incorrect input length
- Value is not a valid extension field $F_{p^2}$ element

***Annotation:***

```rust
/// Map elements from Fp2 to G2 subset of E'(Fp2) BLS12-381 curve
///
/// # Arguments
///
/// * `value` - 96 bytes, the element from Fp2 -- two unsigned integer < p 
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory or the registers
/// use more memory than the limit, the function returns
/// `MemoryAccessViolation`.
///
/// If value_len != 96 or the value is not correct Fp2 element the function return `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes +
///  bls12381_map_fp2_to_g2_base`
pub fn bls12381_map_fp2_to_g2(
        &mut self,
        value_len: u64,
        value_ptr: u64,
        register_id: u64,
) -> Result<()>;
```

#### bls12381_pairing_check

***Description:***

The pairing function $e\colon G_1 \times G_2 \rightarrow G_T$, where $G_T \subset F_{q^{12}}$. The pairing function has the following properties:

- $e(P, Q + R) = e(P, Q) \cdot e(P, R)$
- $e(P + S, R) = e(P, R)\cdot e(S, R)$

The consequence:

$e([a]P, [b]Q) = e(P, Q)^{ab} = e([b]P, [a]Q)$

We need this function to verify BLS signature.

This function takes as input the sequence of pairs $(p_i, q_i)$, where $p_i \in G_1 \subset E(F_{p})$ and $q_i \in G_2 \subset E'(F_{p^2})$ and check:

$$
\prod e(p_i, q_i) = 1
$$

We don’t calculate the pairing function itself: the result will be in the huge field, and in all known applications only such a check is necessary.

***Input:*** the sequence of pairs $(p_i, q_i)$, where $p_i \in G_1 \subset E(F_{p})$ and $q_i \in G_2 \subset E'(F_{p^2})$. Each point is encoded in decompressed form. Expected `288*k` bytes as an input that is interpreted as byte concatenation of `k` slices, each slice is the concatenation of uncompressed point from $G_1 \subset E(F_p)$ — `96 bytes` and point from $G_2 \subset E'(F_{p^2})$ — `192 bytes`. More details are in the Curve Points Encoding section.

***Output:*** returns `bool` — the result of the pairing check. The `true` value means that the pairing result is equal to multiplicative identity and `false` otherwise. For empty input it returns `true`.

***Gas Estimation:***

The algorithm has a linear complexity of the number of elements. The gas can be calculated by the next formula

```rust
let k = (input_bytes + item_size - 1)/item_size
let gas_consumed = A + B * k
```

A and B are constants calculated empirically.

Here you can find benchmark test vectors for EIP-2537[^46].

***Test cases:***

- The correct input with different lengths with results true
- The correct input with different lengths with results false
- The first point on the curve but not in G1
- The second point on the curve but not in G2
- The input with incorrect length
- The points not on the curve
- Some points = 0
- The field elements are encoded incorrectly
- Empty input

***Tests References:*** The EIP-2537 contains the same function, so we can reuse test vectors from Ethereum[^47][^48].

***Error cases:***

- The input length is not divided by 288
- Too much memory is used
- Field elements encoded incorrectly (see Curve points encoded section)
- Any points not on the curve
- Any points not in $G_1/G_2$

***Annotation:***

```rust
/// Computes pairing check on BLS12-381 curve.
/// \prod_i e(g_{1 i}, g_{2 i}) should be equal one, e(g1, g2) is pairing
///
/// # Arguments
///
/// * `value` - sequence of (g1:G1, g2:G2), where
///   G2 is subgroup point (x:Fp2, y:Fp2) on BLS12-381 twist,
///   BLS12-381 twist is Y^2 = X^3 + 4(i + 1) curve over Fp2
///   Fp2 is complex field element (re: Fp, im: Fp)
///   G1 is point (x:Fp, y:Fp) on BLS12-381,
///   BLS12-381 is Y^2 = X^3 + 4 curve over Fp
///
///   `value` is encoded a as packed, big-endian
///   `[(([u8; 48], [u8; 48]), ([u8; 96], [u8; 96]))]` slice.
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory than
/// the function returns `MemoryAccessViolation`.
///
/// If point coordinates are not on curve, point is not in the subgroup
// or data are wrong serialized, for example,
/// `value.len()%288!=0`, the function returns `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes + 
/// bls12381_pairing_base + bls12381_pairing_element * num_elements`
pub fn bls12381_pairing_check(&mut self, value_len: u64, value_ptr: u64) -> Result<u64> {
```

#### bls12381_decompress_g1

***Description:***  Function decompress compressed points from $E(F_p)$. The input is an arbitrary number of points $p_i \in E(F_p)$ in compressed format, and the output is the same number of points from $E(F_p)$ in decompressed format. More about the decompressed and compressed formats you can read in the Curve Points Encoding section.

***Input:***  the sequence of point $p_i \in E(F_p)$, each point encoded in compressed form. Expected `48*k` bytes as an input that is interpreted as byte concatenation of `k` slices, each slice is the compressed point from $E(F_p)$. More details are in the Curve Points Encoding section.

***Output:*** the sequence of point $p_i \in E(F_p)$, each point encoded in decompressed form. Expected `96*k` bytes as an output that is interpreted as byte concatenation of `k` slices, each slice is the decompressed point from $E(F_p)$. `k` the same as in input. More details are in the Curve Points Encoding section.

***Gas Estimation:*** The algorithm has a linear complexity of the number of elements. The gas can be calculated by the next formula

```rust
let k = (input_bytes + item_size - 1)/item_size
let gas_consumed = A + B * k
```

A and B are constants calculated empirically.

***Test cases:***

- the correct input with different length
- the input with incorrect size
- the points with the negative `y` coordinate
- 0 points
- points not on the curve
- incorrectly encoded points
- very long input

***Tests References:***

- Take the correct points on the curve from Ethereum tests[^47][^48] and check the correctness after decompression
- Randomly generate compressed points and check the equation correctness after decompression.

***Error cases:***

- The input length is not divided by 48
- Too much memory is used
- Field elements encoded incorrectly (see Curve points encoded section)
- Any points not on the curve

***Annotation:***

```rust
/// Decompress points on BLS12-381 curve.
///
/// # Arguments
///
/// * `value` - sequence of pi points (x:Fp) on BLS-381 curve
///    BLS12-381 is Y^2 = X^3 + 4 curve over Fp.
///
///   `value` is encoded as packed `[[u8; 48]]` slice.
///
/// # Output
/// sequence of pi points (x: Fp; y: Fp) in decompress format: [([u8; 48], [u8; 48])]
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory or the registers
/// use more memory than the limit, the function returns `MemoryAccessViolation`.
///
/// If point coordinates are not on curve or `value.len()%48 != 0`,
/// the function returns `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes +
/// bls12381_g1_decompress_base + bls12381_g1_decompress_element * num_elements`
pub fn bls12381_decompress_g1(&mut self, 
                              value_len: u64, 
                              value_ptr: u64, 
                              register_id: u64) -> Result<()>;
```

#### bls12381_decompress_g2

***Description:***  Function decompress compressed points from $E'(F_{p^2})$. The input is an arbitrary number of points $p_i \in E'(F_{p^2})$ in compressed format, and the output is the same number of points from $E'(F_{p^2})$ in decompressed format. More about the decompressed and compressed formats you can read in the Curve Points Encoding section.



***Input:***  the sequence of point $p_i \in E'(F_{p^2})$, each point encoded in compressed form. Expected `96*k` bytes as an input that is interpreted as byte concatenation of `k` slices, each slice is the compressed point from $E'(F_{p^2})$. More details are in the Curve Points Encoding section.

***Output:*** the sequence of point $p_i \in E'(F_{p^2})$, each point encoded in decompressed form. Expected `192*k` bytes as an output that is interpreted as byte concatenation of `k` slices, each slice is the decompressed point from $E'(F_{p^2})$. `k` the same as in input. More details are in the Curve Points Encoding section.

***Gas Estimation:*** The algorithm has a linear complexity of the number of elements. The gas can be calculated by the next formula

```rust
let k = (input_bytes + item_size - 1)/item_size
let gas_consumed = A + B * k
```

A and B are constants calculated empirically.

***Test cases:***

- the correct input with different length
- the input with incorrect size
- the points with the negative `y` coordinate
- 0 points
- points not on the curve
- incorrectly encoded points
- very long input

***Tests References:***

- Take the correct points on the curve from Ethereum tests[^47][^48] and check the correctness after decompression
- Randomly generate compressed points and check the equation correctness after decompression.

***Error cases:***

- The input length is not divided by 96
- Too much memory is used
- Field elements encoded incorrectly (see Curve points encoded section)
- Any points not on the curve

***Annotation:***

```rust
/// Decompress points on twisted BLS12-381 curve.
///
/// # Arguments
///
/// * `value` - sequence of pi points (x:Fp2) on twisted BLS-381 curve
///    BLS12-381 is Y^2 = X^3 + (4 + i) curve over Fp2.
///
///   `value` is encoded as packed `[[u8; 96]]` slice.
///
/// # Output
/// sequence of pi points (x: Fp2; y: Fp2) in decompress format: [([u8; 96], [u8; 96])]
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory or the registers
/// use more memory than the limit, the function returns `MemoryAccessViolation`.
///
/// If point coordinates are not on curve or `value.len()%96 != 0`,
/// the function returns `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes +
/// bls12381_g2_decompress_base + bls12381_g2_decompress_element * num_elements`
pub fn bls12381_decompress_g2(&mut self, 
                              value_len: u64, 
                              value_ptr: u64, 
                              register_id: u64) -> Result<()>;
```

## Reference Implementation

First of all, for integration with nearcore, we are interested in libraries in the Rust language. The existing BLS12-381 implementations on Rust:

1. ***Milagro Library*** [^29].
2. ***BLST***  [^30][^31].
3. ***Matter labs EIP-1962 implementation*** [^32]
4. ***zCash origin implementation*** [^33]
5. ***MCL Library*** [^34]
6. ***FileCoin implementation*** [^35]
7. ***zkCrypto*** [^36]

To compile the list, we used the links from EIP-2537[^43], pairing-curves specification[^44], and an article with benchmarks[^45]. This list may be incomplete but should cover the core BLS12-381 implementations. In any case, to implement host functions from that NEP we will need to modify any of that libraries.

In addition, there are implementations in other languages that are not so interesting to us in this context, but can be used as references:

1. C++, ETH2.0 Client, ***Chia library***[^37]
2. Haskell, ***Adjoint Lib***[^38]
3. Go, ***Go-Ethereum***[^39]
4. JavaScript, ***Noble JS***[^40]
5. Go, ***Matter Labs Go EIP-1962 implementation***[^41]
6. C++, ***Matter Labs Go EIP-1962 implementation***[^42]

The draft implementation to nearcore you can find by this link[^54]. This implementation is based on *blst* library[^30]. This library one of the fastest[^45] and the most audited[^55].

## Security Implications

The implementation security relies on the security of the chosen library, which supports operations with BLS curves.

In this NEP, we do not require a constant execution time for all operations. This is not a problem if you use host functions to verify the BLS signature. These host functions should not be used if you need a constant-time algorithm.

The BLS12-381 has more security bits than the already existing pairing-friendly curve BN254, as a result, the security of the projects which need the pairing-friendly curve will improve.

## Alternatives

In the nearcore the host functions for another pairing-friendly curve Alt-BN128 are already implemented[^10]. For some projects[^20] the alternative is just to use the supported curve. However, according to the recent research, this curve contains less than 100 bits of security and is not recommended to use[^13]. Moreover, projects with cross-chain interactions, such as Rainbow Bridge, must use the same curve as in a target protocol, and for Ethereun it is BLS12-381[^3] nowadays. As a result, there is no alternative to using another pairing-friendly curve.

Another alternative is to create one simple host function in nearcore for BLS-signature verification. It was the first suggested solution[^26]. However, this solution is not flexible enough[^28]: (1) projects can use different hash functions; (2) some projects can use G1 subgroup for the public keys, and others – G2; (3) the specification for Ethereum 2.0 continue to be in the draft and details can change, (4) we have one big function instead of a more diverse and flexible set of functions (inspired by EIP-2537's precompiles).

The next alternative is to execute BLS12-381 operations off-chain. In that case, the applications which are using the BLS curve will not be trustless anymore.

## Future possibilities

In the future, it is possible to support work with other curves, not only BLS12-381. In Ethereum, before EIP-2537[^15], EIP-1962 was proposed[^27]. In EIP-1962 was proposed to implement pairing-friendly elliptic curves in a generic format and support not only BLS curves but many others. However, this proposal wasn't accepted due to its large scope and complexity. I don't think it makes sense to implement every possible curve, but it could be a possible extension.

## Consequences

### Positive

- Projects, which are using BN254 will be able to switch on BLS12-381 curve, and it will improve their security.
- The trustless cross-chain interactions with blockchains using BLS12-381 in protocols (such as Ethereum 2.0) will become possible.

### Neutral

### Negative

- The appearance of dependence on the library which supports BLS12-381 curves operations.

### Backward Compatibility

There are no backward compatibility questions.

## Changelog

The previous NEP for supporting BLS signature based on BLS12-381[^26]

[^1]: BLS 2002 [https://www.researchgate.net/publication/2894224_Constructing_Elliptic_Curves_with_Prescribed_Embedding_Degrees](https://www.researchgate.net/publication/2894224_Constructing_Elliptic_Curves_with_Prescribed_Embedding_Degrees)
[^2]: ZCash protocol: [https://zips.z.cash/protocol/protocol.pdf](https://zips.z.cash/protocol/protocol.pdf)
[^3]: Ethereum 2 specification: [https://github.com/ethereum/consensus-specs/blob/master/specs/phase0/beacon-chain.md](https://github.com/ethereum/consensus-specs/blob/master/specs/phase0/beacon-chain.md)
[^4]: Dfinity: [https://internetcomputer.org/docs/current/references/ic-interface-spec#certificate](https://internetcomputer.org/docs/current/references/ic-interface-spec#certificate)
[^5]: Tezos: [https://wiki.tezosagora.org/learn/futuredevelopments/layer2#zkchannels](https://wiki.tezosagora.org/learn/futuredevelopments/layer2#zkchannels)
[^6]: Filecoin: [https://spec.filecoin.io/](https://spec.filecoin.io/)
[^7]: Specification of pairing friendly curves with a list of applications in the table: [https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#name-adoption-status-of-pairing-](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#name-adoption-status-of-pairing-)
[^8]: Specification of pairing friendly curves, the security level for BLS12-381: [https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#section-4.2.1](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#section-4.2.1)
[^9]: BN2005: [https://eprint.iacr.org/2005/133](https://eprint.iacr.org/2005/133)
[^10]: NEP-98 for BN254 host functions on NEAR: [https://github.com/near/NEPs/issues/98](https://github.com/near/NEPs/issues/98)
[^11]: BLS12-381 for the Rest of Us: [https://hackmd.io/@benjaminion/bls12-381](https://hackmd.io/@benjaminion/bls12-381)
[^12]: BN254 for the Rest of Us: [https://hackmd.io/@jpw/bn254](https://hackmd.io/@jpw/bn254)
[^13]: Some analytics of different curve security: [https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-02.html#name-for-100-bits-of-security](https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-02.html#name-for-100-bits-of-security)
[^14]: ZCash Transfer from bn254 to bls12-381: [https://electriccoin.co/blog/new-snark-curve/](https://electriccoin.co/blog/new-snark-curve/)
[^15]: EIP-2537 Precompiles for Ethereum for BLS12-381: [https://eips.ethereum.org/EIPS/eip-2537](https://eips.ethereum.org/EIPS/eip-2537)
[^16]: The article, where Tezos announce the support of BLS12-381 [https://medium.com/metastatedev/meanwhile-at-cryptium-labs-2-part-2-adding-the-pairing-equipped-elliptic-curve-bls12-381-to-tezos-cfce907e4be3](https://medium.com/metastatedev/meanwhile-at-cryptium-labs-2-part-2-adding-the-pairing-equipped-elliptic-curve-bls12-381-to-tezos-cfce907e4be3)
[^17]: Article about Rainbow Bridge [https://near.org/blog/eth-near-rainbow-bridge](https://near.org/blog/eth-near-rainbow-bridge)
[^18]: EIP-196. Precompiles for BN254: [https://eips.ethereum.org/EIPS/eip-196](https://eips.ethereum.org/EIPS/eip-196)
[^19]: Intro into zkSNARKs: [https://media.consensys.net/introduction-to-zksnarks-with-examples-3283b554fc3b](https://media.consensys.net/introduction-to-zksnarks-with-examples-3283b554fc3b)
[^20]: Zeropool project: [https://zeropool.network/](https://zeropool.network/)
[^21]: Motivation for EIP-2537: [https://www.youtube.com/watch?v=al4YpfDVmS4&ab_channel=EthereumCatHerders](https://www.youtube.com/watch?v=al4YpfDVmS4&ab_channel=EthereumCatHerders)
[^22]: NEAR blog post about Roll Ups: [https://near.org/blog/layer-2](https://near.org/blog/layer-2)
[^23]: Ledger post about Roll Ups: [https://www.ledger.com/academy/what-are-blockchain-rollups](https://www.ledger.com/academy/what-are-blockchain-rollups)
[^24]: Precompiles on Aurora: [https://doc.aurora.dev/evm/precompiles/](https://doc.aurora.dev/evm/precompiles/)
[^25]: Pippenger Algorithm: [https://github.com/wborgeaud/python-pippenger/blob/master/pippenger.pdf](https://github.com/wborgeaud/python-pippenger/blob/master/pippenger.pdf)
[^26]: NEP-446 proposal for BLS-signature verification: [https://github.com/nearprotocol/neps/pull/446](https://github.com/nearprotocol/neps/pull/446)
[^27]: EIP-1962 EC arithmetic and pairings with runtime definitions: [https://eips.ethereum.org/EIPS/eip-1962](https://eips.ethereum.org/EIPS/eip-1962)
[^28]: Drawbacks of NEP-446: [https://github.com/near/NEPs/pull/446#pullrequestreview-1314601508](https://github.com/near/NEPs/pull/446#pullrequestreview-1314601508)
[^29]: BLS12-381 Milagro: [https://github.com/sigp/incubator-milagro-crypto-rust/tree/057d238936c0cbbe3a59dfae6f2405db1090f474](https://github.com/sigp/incubator-milagro-crypto-rust/tree/057d238936c0cbbe3a59dfae6f2405db1090f474)
[^30]: BLST: [https://github.com/supranational/blst](https://github.com/supranational/blst),
[^31]: BLST EIP-2537 adaptation: [https://github.com/sean-sn/blst_eip2537](https://github.com/sean-sn/blst_eip2537)
[^32]: EIP-1962 implementation matter labs Rust: https://github.com/matter-labs/eip1962
[^33]: zCash origin rust implementation: [https://github.com/zcash/zcash/tree/master/src/rust/src](https://github.com/zcash/zcash/tree/master/src/rust/src)
[^34]: MCL library: [https://github.com/herumi/bls](https://github.com/herumi/bls)
[^35]: filecoin/bls-signature: [https://github.com/filecoin-project/bls-signatures](https://github.com/filecoin-project/bls-signatures)
[^36]: zkCrypto: [https://github.com/zkcrypto/bls12_381](https://github.com/zkcrypto/bls12_381), [https://github.com/zkcrypto/pairing](https://github.com/zkcrypto/pairing)
[^37]: BLS12-381 code bases for ETH2.0 client Chia library C++: [https://github.com/Chia-Network/bls-signatures](https://github.com/Chia-Network/bls-signatures)
[^38]: Adjoint Lib: [https://github.com/sdiehl/pairing](https://github.com/sdiehl/pairing)
[^39]: Ethereum Go implementation for EIP-2537: [https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles](https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles)
[^40]: Noble JS implementation: [https://github.com/paulmillr/noble-bls12-381](https://github.com/paulmillr/noble-bls12-381)
[^41]: EIP-1962 implementation matter labs Go: https://github.com/kilic/eip2537,
[^42]: EIP-1962 implementation matter labs C++: https://github.com/matter-labs-archive/eip1962_cpp
[^43]: EIP-2537 with links: [https://github.com/matter-labs-forks/EIPs/blob/bls12_381/EIPS/eip-2537.md](https://github.com/matter-labs-forks/EIPs/blob/bls12_381/EIPS/eip-2537.md)
[^44]: Pairing-friendly curves specification, crypto libs: [https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#name-cryptographic-libraries](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#name-cryptographic-libraries)
[^45]: Comparing different libs for pairing-friendly curves: [https://hackmd.io/@gnark/eccbench](https://hackmd.io/@gnark/eccbench)
[^46]: Bench vectors from EIP2537: [https://eips.ethereum.org/assets/eip-2537/bench_vectors](https://eips.ethereum.org/assets/eip-2537/bench_vectors)
[^47]: Metter Labs tests for EIP2537: [https://github.com/matter-labs/eip1962/tree/master/src/test/test_vectors/eip2537](https://github.com/matter-labs/eip1962/tree/master/src/test/test_vectors/eip2537)
[^48]: Tests from Go Ethereum implementation: [https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles](https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles)
[^49]: EIP-2537 Map To Curve specification: [https://eips.ethereum.org/assets/eip-2537/field_to_curve](https://eips.ethereum.org/assets/eip-2537/field_to_curve)
[^50]: The current implementation of BN254: [https://github.com/near/nearcore/blob/master/runtime/near-vm-runner/src/logic/logic.rs](https://github.com/near/nearcore/blob/master/runtime/near-vm-runner/src/logic/logic.rs)
[^51]: draft-irtf-cfrg-pairing-friendly-curves-11 [https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11#name-bls-curves-for-the-128-bit-](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11#name-bls-curves-for-the-128-bit-)  *(*[https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/bls.md](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/bls.md) → [https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04) → this ref*)*
[^52]: Paper with BLS12-381: [https://eprint.iacr.org/2019/403.pdf](https://eprint.iacr.org/2019/403.pdf)
[^53]: Zkcrypto points encoding: [https://github.com/zkcrypto/pairing/blob/0.14.0/src/bls12_381/README.md](https://github.com/zkcrypto/pairing/blob/0.14.0/src/bls12_381/README.md)
[^54]: Draft PR for BLS12-381 operations in nearcore: https://github.com/near/nearcore/pull/9317
[^55]: Audit for BLST library: [https://research.nccgroup.com/wp-content/uploads/2021/01/NCC_Group_EthereumFoundation_ETHF002_Report_2021-01-20_v1.0.pdf](https://research.nccgroup.com/wp-content/uploads/2021/01/NCC_Group_EthereumFoundation_ETHF002_Report_2021-01-20_v1.0.pdf)
[^56]: Eric Brier, Jean-Sébastien Coron, Thomas Icart, David Madore, Hugues Randriam, and Mehdi Tibouchi. Efficient indifferentiable hashing into ordinary
elliptic curves. In Tal Rabin, editor, CRYPTO 2010, volume 6223 of LNCS,
pages 237–254. Springer, Heidelberg, August 2010. [https://link.springer.com/chapter/10.1007/978-3-642-14623-7_13](https://link.springer.com/chapter/10.1007/978-3-642-14623-7_13)
[^57]: Wahby, Riad S., and Dan Boneh. "Fast and simple constant-time hashing to the BLS12-381 elliptic curve." Cryptology ePrint Archive (2019). [https://eprint.iacr.org/2019/403](https://eprint.iacr.org/2019/403)
