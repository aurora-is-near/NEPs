---
NEP: 488
Title: Host Functions for BLS12-381 Curve Operations
Authors: Olga Kuniavskaia <olga.kunyavskaya@aurora.dev>
Status: Draft
DiscussionsTo: https://github.com/nearprotocol/neps/pull/488
Type: Runtime Spec
Version: 0.0.1
Created: 2023-07-17
LastUpdated: 2023-11-21
---

## Summary

This NEP introduces host functions to perform operations on the BLS12-381 elliptic curve. It is a minimal set of functions needed to efficiently verify BLS signatures and zkSNARKs.

## Motivation

The primary aim of this NEP is to enable fast and efficient verification of BLS signatures and zkSNARKs based on 
BLS12-381[^1],[^11],[^52] elliptic curve on NEAR.

To efficiently verify zkSNARKs[^19], host functions for operations on the BN254 
elliptic curve(also known as Alt-BN128)[^9], [^12] have already been implemented on NEAR[^10]. 
For instance, the Zeropool[^20] project utilizes these host functions for verifying zkSNARKs on NEAR. 
However, recent research shows that the BN254 security level is lower than 100-bit[^13] and it is not recommended for use. 
BLS12-381, on the other hand, offers over 120 bits of security[^8] and is widely used[^2],[^3],[^4],[^5],[^6],[^7]  as a robust alternative. 
Supporting operations for BLS12-381 elliptic curve will significantly enhance the security of projects similar to Zeropool.

Another crucial objective is the verification of BLS signatures. 
Initially, host functions for BN254 in NEAR were designed for zkSNARK verification and 
are insufficient for BLS signature verifications. 
However, even if they were sufficient, it wouldn't work for us. 
Projects such as ZCash[^2], Ethereum[^3], Tezos[^5], and Filecoin[^6] incorporate BLS12-381 specifically within their protocols. 
If we aim for compatibility with these projects, we must also utilize this elliptic curve. 
For instance, to create a trustless bridge[^17] between Ethereum and NEAR, 
we must efficiently verify BLS signatures based on BLS12-381, as these are the signatures employed within Ethereum's protocol.

In this NEP, we propose to add the following host functions:

- ***bls12381_g1_sum —*** sum the signed points from $G_1$ on an elliptic curve. This function is useful for the aggregation of public keys in BLS Signature. It can be used for simple addition in $G_1$. Separate from the multiexp function due to the gas cost.
- ***bls12381_g2_sum —*** sum the signed points from $G_2$ on an elliptic curve. This function is useful for the aggregation of signatures in BLS Signature. It can be used for simple addition in $G_2$. Separate from the multiexp function due to the gas cost.
- ***bls12381_g1_multiexp —*** for points $g_i \in G_1$ and scalars $s_i$ calculate $\sum g_i s_i$. It can be used to multiply a group element by a scalar. 
- ***bls12381_g2_multiexp —*** for points $g_i \in G_2$ and scalars $s_i$ calculate $\sum g_i s_i$. It can be used to multiply a group element by a scalar.
- ***bls12381_map_fp_to_g1 —*** maps base field element into the $G_1$ point. It does not perform mapping of the byte string into field elements.
- ***bls12381_map_fp2_to_g2 —*** maps extension field element into the $G_2$ point. It does not perform mapping of the byte string into extension field elements. We require this function to efficiently map a message into a group element. We don't implement hash_to_field[^60] function, because it can be done inside a contract and different hashing algorithms can be used.
- ***bls12381_decompress_g1 —*** decompresses the points from $G_1$ provided in the compressed form. Some protocols provide points on the curve in the compressed form (e.g., the light client updates in Ethereum 2.0), and decompressing is a time-consuming operation. All the other functions in this NEP accept only decompressed points to be simple and to have optimized gas consumption.
- ***bls12381_decompress_g2 —*** decompresses the points from $G_2$ provided in the compressed form.
- ***bls12381_pairing_check —*** verifying that $\prod e(p_i, q_i) = 1$, where $e$ is a pairing operation and $p_i \in G_1 \land q_i \in G_2$. Used to verify BLS signatures or zkSNARKs. 

Functions required for verifying BLS signatures[^59]:

- bls12381_g1_sum
- bls12381_g2_sum
- bls12381_map_fp2_to_g2
- bls12381_decompress_g1
- bls12381_decompress_g2
- bls12381_pairing_check

Functions required for verifying zkSNARKs:

- bls12381_g1_sum
- bls12381_g1_multiexp
- bls12381_pairing_check

Both zkSNARKs and BLS signatures can be implemented alternatively by swapping G1 and G2. 
Therefore, all functions have been implemented for both G1 and G2.

An analogous proposal, EIP-2537[^15], exists in Ethereum. 
The functions here have been designed considering compatibility with Ethereum's proposal. 
This design approach aims to ensure future ease in supporting corresponding precompiles for Aurora[^24].

## Specification

### BLS12-381 Curve Specification

#### Elliptic Curve

**The field $F_p$** for some *prime* $p$ is a set of integer elements $\textbraceleft 0, 1, \ldots, p - 1 \textbraceright$ with two operations: multiplication $\cdot$ and addition $+$. These operations are performed as multiplication/addition for integers number and then taking the remainder modulo $p$.

**The elliptic curve $E(F_p)$**  is a set of all pairs $(x, y) \in F_p$:

$$
y^2 \equiv x^3 + Ax + B \mod p
$$

together with an imaginary point at infinity 0, where: $A, B \in F_p$, p is prime > 3, and $4A^3 + 27B^2 \not \equiv 0 \mod p$

In the case of BLS12-381 equation is $y^2 \equiv x^3 + 4 \mod p$[^15],[^51],[^14],[^11]

**Parameters for our case:**

- $A = 0$
- $B = 4$
- $p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab$

Let’s $P \in E(F_q)$ have coordinates (x, y), define **$-P$**  as a point on a curve with coordinates (x, -y).

**The addition operation for Elliptic Curve** is a function $+\colon E(F_p) \times E(F_p) \rightarrow E(F_p)$ defined with following rules: let’s P and Q $\in E(F_p)$

- if  $P \ne Q$ and $P \ne -Q$
  - draw a line passing through P and Q. This line intersects the curve at a third point R
  - reflect the point R about the x-axis by changing the sign of the y-coordinate. The resulting point is P+Q.
- if $P=Q$
  - draw a tangent line throw P for an elliptic curve. The line will intersect the curve at the second point R.
  - reflect the point R about the x-axis the same way to get point 2P
- $P = -Q$
  - $P + Q = P + (-P) = 0$ — the point on infinity
- Q = 0
  - $P + Q = P + 0 = P$

With the addition operation, Elliptic Curve forms a **group**.

#### Subgroups

**Subgroup** H is a subset of the group G with the following properties:

- $\forall h_1, h_2 \in H\colon h_1 + h_2 \in H$
- $0 \in H$
- $\forall h \in H \colon -h \in H$

Notation: $H \subseteq G$

Group/subgroup **order** is the number of elements in group/subgroup.

Notation: |G|  or #G, where G is group

For some technical reason (for `pairing` operation which we will define later), we will work not with the whole $E(F_p)$, but only with the two subgroups $G_1$ and $G_2$ with the same **order** $r$. $G_1$ is a subset of $E(F_p)$, $G_2$ is a subgroup of another group, which we will define later. The $r$ should be prime and $G1 \ne G2$

For our BLS12-381 Elliptic Curve, **the order r** of $G1$  and $G2$[^15],[^51]:

- $r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001$

#### Field extension

**The field extension $F_{p^k}$** is a set of all polynomials with degree < k and coefficients from $F_p$ and defined operations $\cdot$ , $+$

$$
a_{k - 1}x^{k - 1} + \ldots + a_1x + a_0 = A(x) \in F_{p^k} \vert a_i \in F_p
$$

The $+$ operation is defined as a regular addition for polynomials:

$$
A(x) + B(x) = C(x)
$$

$$
\sum a_i x^i + \sum b_i x^i = \sum c_i x^i
$$

$$
c_i = (a_i + b_i) \mod p
$$

The multiplication $\cdot$ is defined as a regular polynomials’ multiplication by modulo M(x), where M(x) is an ***irreducible*** polynomial of degree k with coefficients from $F_p$

$$
C(x) = A(x) \cdot B(x)\mod M(x)
$$

Notation: $F_{p^k} = F_{p}[x] / M(x)$

In BLS12-381 we will need $F_{p^{12}}$ and we will build this field not as an extension from $F_p$ directly, but first we will build $F_{p^2}$ as a quadratic extension of field $F_p$, second we will build $F_{p^6}$ as a cubic extension of $F_{p^2}$, and finally we will build  $F_{p^{12}}$ the quadratic extension of field $F_{p^6}$.

For defining these fields, we will need to set up three $M(x)$ irreducible polynomials[^51]:

- $F_{p^2} = F_p[u] / (u^2 + 1)$
- $F_{p^6} = F_{p^2}[v] / (v^3 - u - 1)$
- $F_{p^{12}} = F_{p^6}[w]/(w^2 - v)$

Our second subgroup of order r, which we will use, is a subgroup of the same Elliptic Curve but with elements from $F_{p^{12}}$.   $G_2 \subset E(F_{p^{12}})$, where $E: y^2 = x^3 + 4$

#### Twist

Store elements from $E(F_{p^{12}})$ takes a lot of memory. ***The twist*** operation transforms the origin curve $E(F_{p^{12}})$ into another curve under another space $E'(F_{p^2})$. It is important that the new curve also has a $G'_2$  subgroup with order r and we can easily transform it to origin $G_2$.

We want to have $\psi \colon E'(F_{p^2}) \rightarrow E(F_{p^{12}})$, such as

- $\forall a, b \in E'(F_{p^2}) \colon \psi(a + b) = \psi(a) + \psi(b)$
- $\forall a, b \in E'(F_{p^2}) \colon \psi(a) = \psi(b) \Rightarrow a = b$

It is called injective group homomorphism.

For BLS12-381 E’ is defined as[^51]:

$$
E'\colon y^2 = x^3 + 4(u + 1)
$$

In most cases we will work with points from $G_2' \subset E'(F_{p^2})$ and use for this subgroup just the notation $G_2$.

#### Generators

If in the group $G$ exists element g, such as $\textbraceleft g, 2g, 3g, \ldots, |G|g \textbraceright = G$, the group G called ***cyclic group*** and g called ***generator***

$G_1$ and $G_2$ are cyclic subgroups with the following generators[^15],[^51]:

$G_1$:

- $x = 0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb$
- $y = 0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1$

For $(x', y') \in G_2 \subset E'(F_{p^2}):$
$$x' = x_0 + x_1u$$

$$y' = y_0 + y_1u$$

$G_2$:

- $x_0 = 0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8$
- $x_1 = 0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e$
- $y_0 = 0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801$
- $y_1 = 0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be$


**Cofactor** is the ratio of the size of the whole group G to the size of subgroup H:

$$
|G|/|H|
$$

Cofactor $G_1\colon h = |E(F_p)|/r$[^51]

$$h = 0x396c8c005555e1568c00aaab0000aaab$$

Cofactor $G_2\colon h' = |E'(F_{p^2})|/r$[^51]

$$h' = 0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5$$

#### Pairing

Pairing is an operation, which we will need for digital signature verification. Pairing operation $e\colon G_1 \times G_2 \rightarrow G_T$, where $G_T \subset F_{p^{12}}$.

The main  pairing properties is:

- $e(P, Q + R) = e(P, Q) \cdot e(P, R)$
- $e(P  + S, R) = e(P, R)\cdot e(S, R)$

For calculating this function we will need the algorithm, called Miller Loop, and to effectively perform this algorithm we will need to know the key parameter for BLS curve $x$

$$ x = -0xd201000000010000$$

You can find this parameter in:

- [^15] section specification, pairing parameters, miller loop scalar
- [^51] section 4.2.1 Parameter t
- [^14] section BLS12-381, parameter u
- [^11] section Curve equation and parameters, parameter x

#### Summary

The  parameters for the BLS12-381:

Base field modulus $p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab$

$$
E\colon y^2 \equiv x^3 + 4
$$

$$
E'\colon y^2 \equiv x^3 + 4(u + 1)
$$

Main subgroup order $r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001$

$$
F_{p^2} = F_p[u] / (u^2 + 1)
$$

$$
F_{p^6} = F_{p^2}[v] / (v^3 - u - 1)
$$

$$
F_{p^{12}} = F_{p^6}[w] / (w^2 - v)
$$

Generator for G1:

- $x = 0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb$
- $y = 0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1$

Generator for G2:

- $x_0 = 0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8$
- $x_1 = 0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e$
- $y_0 = 0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801$
- $y_1 = 0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be$


Cofactor for G1:
$$h = 0x396c8c005555e1568c00aaab0000aaab$$

Cofactor for G2:
$$h' = 0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5$$

Key  BLS12-381 parameter used in Miller Loop:
$$x = -0xd201000000010000$$

All parameters were taken from[^15],[^51] and [^14], all of them consistent between sources.

### Map to curve specification

This section explains the functionality of the `bls12381_map_fp_to_g1` and `bls12381_map_fp2_to_g2` functions. 
They operate based on the specification RFC9380 "Hashing to Elliptic Curves"[^62].

These functions map the field element in $F_p$ or $F_{p^2}$ to the corresponding subgroup $G_1 \subset E(F_p)$ or $G_2 \subset E'(F_{p^2})$.
`bls12381_map_fp_to_g1`/`bls12381_map_fp2_to_g2` combine functions `map_to_curve` and `clear_cofactor` from RFC9380[^63].

```text
fn bls12381_map_fp_to_g1(u):
    let Q = map_to_curve(u);
    return clear_cofactor(Q);
```

We won't be implementing `hash_to_field` function as a host function because hashing can be performed through 
various methods, and this part is most likely subject to change. Additionally, executing this function within
the contract consumes approximately 2 TGas, which is acceptable for our goals.

Specific parameters for implementing `bls12381_map_fp_to_g1` and `bls12381_map_fp2_to_g2` you can find in RFC9380 in 
sections 8.8.1[^64] and 8.8.2[^65] respectively.

### Curve points encoding

#### Sign

The sign of the point on the elliptic curve is encoded as `u8` type in Rust with two possible values: `0` and `1`. `0` for positive sign, and `1` for negative sign. All other value of `u8` is not allowed and should be interpreted as incorrect.

#### Scalar

The scalar value is encoded as a little-endian `[u8;32]`. All possible bytes combination is allowed.

#### Fields elements Fp

The value from $F_p$ is encoded as a big-endian `[u8; 48]`. Only values less than `p` are allowed. If the value is equal to or bigger than `p` the error should be returned.

The rule of encoding is consistent with zkcrypto[^53], with implementation in milagro lib[^29].

#### Extension fields elements Fp2

The $q \in F_{p^{2}}$ could be written as $q = c_0 + c_1 v$, where $c_0, c_1 \in F_p$ The element from $F_{p^2}$ encoded in `[u8; 96]` as a bytes’ concatenation of $c_1$ and $c_0$. The $c_1$ and $c_0$ are encoded by the rule described in the previous section.

$q \in F_{p^2}$, $q = c_0 + c_1 v$ encoded as `[u8; 96]`:

- $c_1 \in F_p$ `[u8; 48]`
- $c_0 \in F_p$ `[u8; 48]`

The rule of encoding is consistent with zkcrypto[^53] and with implementation in milagro lib[^29].

#### Uncompressed points on curve E(Fp)

The points on the curve represent by affine coordinates: `(x: Fp, y: Fp)`. The elements from $E(F_p)$ encoded in `[u8; 96]` as bytes’ concatenation of `x` and `y` point coordinates, where $x, y \in F_p$. The $x, y$ are encoded according to the rules described in the section “Fields elements $F_p$” .

$E(F_p)$  is encoded as `[u8; 96]`:

- $x \in F_p$ `[u8; 48]`
- $y \in F_p$ `[u8; 48]`

*The second-highest bit* is used to mark a point on infinity, if the second-highest bit is set to 1 — it is an infinity point.
If the second-highest bit is set to 1, all others bits should be set to 0. Other encoding should throw an error.

Encoding point on infinity:

```bash
let x: [u8; 96] = [0; 96];
x[0] = x[0] | 0x40;
```

The rule of encoding is consistent with zkcrypto[^53] and with implementation in milagro lib[^29].

#### Compressed points on curve E(Fp)

The points on the curve represent by affine coordinates: `(x: Fp, y: Fp)`. The elements from $E(F_p)$ in compressed form are encoded in `[u8; 48]` as *big-endian* encoded $x \in F_p$. The $y$  coordinate can be detected by the formula: $y = \pm \sqrt{x^3 + 4}$.

*The highest bit* should be set as 1. This bit indicates that point is encoded in compressed form.

*The second-highest bit* is used to mark a point on infinity, if the second-highest bit is set to 1 — it is an infinity point.
If the second-highest bit is set to 1, all others except first two bits should be set to 0. Other encoding should throw an error.

To represent the sign of the $y$ *the third-highest bit* of x encoding is used. If the first bit = 0 the $y$ is positive, if the first bit = 1 the $y$ is negative. We will consider the number positive the smallest between $y$  and $-y = p - y$.

The $x \in F_p$ encoded as `[u8; 48]` bytes according to the rules from section  “Extension fields elements $F_{p}$” .

The point on $E(F_p)$ with negative $y$ coordinate encoded as `[u8; 48]` bytes:

```rust
let x: [u8; 48] = encodeFp(x)
x[0] = x[0] | 0x80;
x[0] = x[0] | 0x20;
```

For encoding point of infinity:

```rust
let x: [u8; 48] = [0; 48];
x[0] = x[0] | 0x80;
x[0] = x[0] | 0x40;
```

The rule of encoding is consistent with zkcrypto[^53] and with implementation in milagro lib[^29].

#### Uncompressed points on twisted curve E'(Fp2)

The points on the curve represent by affine coordinates: `(x: Fp2, y: Fp2)`. The elements from $E'(F_{p^2})$ encoded in `[u8; 192]` as bytes’ concatenation of `x` and `y` point coordinates, where $x, y \in F_{p^2}$. The $x, y$ are encoded according to the rules described in the section “Extension fields elements $F_{p^2}$” .

$E'(F_{p^2})$  is encoded as `[u8; 192]`:

- $x \in F_{p^2}$ `[u8; 96]`:
  - $c_1 \in F_p$ `[u8; 48]`
  - $c_0 \in F_p$ `[u8; 48]`
- $y \in F_{p^2}$ `[u8; 96]`:
  - $c_1 \in F_p$ `[u8; 48]`
  - $c_0 \in F_p$ `[u8; 48]`

*The second-highest bit* is used to mark a point on infinity, if the second-highest bit is set to 1 — it is an infinity point. 
If the second-highest bit is set to 1, all others bits should be set to 0. Other encoding should throw an error.

Encoding point on infinity:

```bash
let x: [u8; 192] = [0; 192];
x[0] = x[0] | 0x40;
```

The rule of encoding is consistent with zkcrypto[^53] and with implementation in milagro lib[^29].

#### Compressed points on twisted curve E'(Fp2)

The points on the curve represent by affine coordinates: `(x: Fp2, y: Fp2)`. The elements from $E'(F_{p^2})$ in compressed form are encoded in `[u8; 96]` as *big-endian* encoded $x \in F_{p^2}$. The $y$  coordinate can be detected by the formula: $y = \pm \sqrt{x^3 + 4(u + 1)}$.

*The highest bit* should be set as 1. This bit indicates that point is encoded in compressed form.

*The second-highest bit* is used to mark a point on infinity, if the second-highest bit is set to 1 — it is an infinity point.
If the second-highest bit is set to 1, all others except first two bits should be set to 0. Other encoding should throw an error.

To represent the sign of the $y$ *the third-highest bit* of x encoding is used. If the bit = 0 the $y$ is positive, if the bit = 1 the $y$ is negative. We will consider the number positive the smallest between $y$  and $-y$: first compare $c_1$ and second $c_0$.

The $x \in F_{p^2}$ encoded as `[u8; 96]` bytes according to the rules from section  “Extension fields elements $F_{p^2}$” .

The point on $E'(F_{p^2})$ with negative $y$ coordinate encoded as `[u8; 96]` bytes:

```rust
let x: [u8; 96] = encodeFp2(x);
x[0] = x[0] | 0x80;
x[0] = x[0] | 0x20;
```

Encoding point of infinity:

```rust
let x: [u8; 96] = [0; 96];
x[0] = x[0] | 0x80;
x[0] = x[0] | 0x40;
```

The rule of encoding is consistent with zkcrypto[^53] and with implementation in milagro lib[^29].

#### ERROR_CODE

Verifying the correctness of the input for the host-functions inside the contract can be gas-consuming. 
For example, checking that the point is an element of the subgroup. If the near host function returns an error, 
the whole execution is reverted. To avoid it, if the input is difficult to verify, the host function will finish 
the work successfully but will return the ERROR_CODE. This solution will provide the opportunity for the user 
to handle error cases by himself. Note: the host functions can finish with an error if the error were easy to avoid 
(for example, if the input size is incorrect).

The ERROR_CODE encoded as a little-endian u64 and can take the following values:

- 0 -- no error, execution was successful
- 1 -- incorrect encoding (the bit compress/decompress format set incorrectly, coordinate >= p etc)
- 2 -- point not on the curve
- 3 -- point not in expected subgroup
- 5 -- the pairing result is not equal to multiplicative identity

ERROR_CODEs consistent with blst errors[^58].

### Host functions

#### bls12381_g1_sum

***Description:***

The function computes the sum of the signed elements of the BLS12-381 curve. The input is an arbitrary number of pairs $(s_i, p_i)$, where $p_i \in E(F_p)$ is point on elliptic curve and $s_i \in \textbraceleft 0, 1 \textbraceright$ is the point sign. The output is one point from $E(F_p)$ equal to $\sum (-1)^{s_i}p_i$.

The $E(F_p)$ curve,  points on the curve, multiplication on -1,  and the addition operation are defined in the BLS12-381 Curve Specification section.

Note: we take as input any points on the curve, not only from   $G_1$

***Input:*** the sequence of pairs $(s_i, p_i)$, where $p_i \in E(F_p)$ is point and $s_i \in \textbraceleft 0, 1 \textbraceright$ is sign, each point encoded in decompress form as $(x\colon F_p, y\colon F_p)$ and sign encoded in one byte with only two allowed values: 0, 1. Expected `97*k` bytes as an input that is interpreted as byte concatenation of `k` slices ($k \le 1000$), each slice is the uncompressed point from $E(F_p)$ and a bool value for point sign. More details are in the Curve Points Encoding section.

***Output:*** the ERROR_CODE is returned. 

- If the input is correct: ERROR_CODE = 0, the output is 96 bytes — the one point $\in E(F_p)$ in decompressed form. For empty input it returns point on infinity (see  Curve Points Encoding section).
- If the field elements encoded incorrectly (see Curve points encoded section): ERROR_CODE = 1, the output is empty
- If point not on the curve: ERROR_CODE = 2, the output is empty

***Gas Estimation:***

The algorithm has a linear complexity of the number of elements. The gas can be calculated by the next formula

```rust
let k = input_bytes / item_size
let gas_consumed = A + B * k
```

A and B are constants calculated empirically.

Here you can find benchmark test vectors for EIP-2537[^46]. It doesn’t contain a sum function, but we can adopt the test vector for addition by duplicating it many times.

***Test cases:***

<ins>Tests for the sum of two points</ins>

In this section, I would like to test that the sum of two correct elements on the curve works correctly.
We can use the following methods:

- Take the points on the curve with known answer and compare results. For example, we can use tests for EIP-2537
- Generate the random points on the curve and check the P + Q = Q + P
- Generate the random points from G1 and check that sum also in G1
- Use the implementation from another library, generate the random points on curve and compare results

Edge cases:

- Points not from G1
- 0 + 0 = 0
- P + 0 = 0 + P = P
- P + (-P) = (-P) + P = 0
- P + P (tangent to the curve)
- The sum of two points P and (-(P + P)). (tangent to the curve in point P)


<ins>Tests for inversion</ins>

In this section, I would like to check that point inverse works correctly.
 
- Generate random points on the curve and check P - P = -P + P = 0
- Generate random points on the curve and check -(-P) = P
- Generate random points from G1 and check -P also from G1
- Use the implementation from another library, generate the random points on curve and compare results

Edge cases:

- Point not from G1
- -0


<ins>Tests for incorrect data</ins>

In this section, I would like to check that incorrect input data is handled properly

- Incorrect len of input
- Incorrect sign value (not 0 or 1)
- The coding of field elements is incorrect, but if take only the suffix it will be the correct point on the curve
- The coding of field elements is incorrect, but by modulo p it is a correct element on the curve
- The coding of field elements is incorrect, an incorrect extra bit, which shows that it is decompressed encoding.
- Point not on the curve
- The point on infinity encoded incorrectly
- Number of points more than 1000


<ins>Tests for the sum of an arbitrary amount of points</ins>

In this section, we are checking that the sum of an arbitrary amount of points works properly

- Generate random points on the curve and check that sum of random permutation is the same
- Use the implementation from another library, generate the random points on curve and compare results
- Generate points and cross-test the result with multiexp function.
- Generate a random points from G1 and check that sum also from G1

Edge cases:

- Empty input
- Sum with the maximum number of elements
- One point


***Tests References:***

We can use all the tests for addition for Ethereum[^47],[^48] to check the case with k = 2. Also, we can reuse the `error` points. Can use the vectors for multiexp functions if separately perform multiplication.

***Error cases:***

- The input length is not divided by 97
- Number of points more than 1000
- Too much memory is used
- The sign value is not 0 or 1

***Annotation:***

The input is obtained from memory started from `value_ptr` to `value_ptr + value_len`,
if the `value_len` is `u64::MAX` the input will be obtained from register.

The output data will be written to register with `register_id` id.

The ERROR_CODE is returned.

```rust
pub fn bls12381_g1_sum(&mut self, 
                       value_len: u64, 
                       value_ptr: u64, 
                       register_id: u64) -> Result<u64>;
```

#### bls12381_g2_sum

***Description:***

The function computes the sum of the signed elements of the BLS12-381 curve. The input is an arbitrary number of pairs $(s_i, p_i)$, where $p_i \in E'(F_{p^2})$ is point on elliptic curve and $s_i \in \textbraceleft 0, 1 \textbraceright$ is the point sign. The output is one point from $E'(F_{p^2})$ equal to $\sum (-1)^{s_i}p_i$.

The $E'(F_{p^2})$ curve,  points on the curve, multiplication on -1, and the addition operation are defined in the BLS12-381 Curve Specification section.

Note: we take as input any points on the curve, not only from $G_2$

***Input:*** the sequence of pairs $(s_i, p_i)$, where $p_i \in E'(F_{p^2})$ is point and $s_i \in \textbraceleft 0, 1 \textbraceright$ is sign, each point encoded in decompress form as $(x\colon F_{p^2}, y\colon F_{p^2})$ and sign encoded in one byte. Expected `193*k` bytes as an input that is interpreted as byte concatenation of `k` slices ($k \le 1000$), each slice is the uncompressed point from $E'(F_{p^2})$ and the point sign. More details are in the Curve Points Encoding section.

***Output:***
the ERROR_CODE is returned.

- If the input is correct: ERROR_CODE = 0, the output is 192 bytes — the one point $\in E'(F_{p^2})$ in decompressed form. For empty input it returns point on infinity(see  Curve Points Encoding section).
- If extension field elements encoded incorrectly (see Curve points encoded section): ERROR_CODE = 1, the output is empty
- If point not on the curve: ERROR_CODE = 2, the output is empty


***Gas Estimation:***

The algorithm has a linear complexity of the number of elements. The gas can be calculated by the next formula

```rust
let k = input_bytes / item_size
let gas_consumed = A + B * k
```

A and B are constants calculated empirically.

Here you can find benchmark test vectors for EIP-2537[^46]. It doesn’t contain a sum function, but we can adopt the test vector for addition by duplicating it many times.

***Test cases:***

The same as for **`bls12381_g1_sum`** only change points from $G_1$ and $E(F_p)$ into $G_2$ and $E'(F_{p^2})$.

***Tests References:***

We can use all the tests for addition for Ethereum[^47],[^48] to check the case with k = 2. Also, we can reuse the `error` points. Can use the vectors for multiexp functions if separately perform multiplication.

***Error cases:***

- The input length is not divided by 193
- Too much memory is used
- Number of points more than 1000
- The sign value is not 0 or 1

***Annotation:***

The input is obtained from memory started from `value_ptr` to `value_ptr + value_len`,
if the `value_len` is `u64::MAX` the input will be obtained from register.

The output data will be written to register with `register_id` id.

The ERROR_CODE is returned.

```rust
pub fn bls12381_g2_sum(&mut self, 
                       value_len: u64, 
                       value_ptr: u64, 
                       register_id: u64) -> Result<u64>;
```

#### ***bls12381_g1_multiexp***

***Description:***

The function takes as input the list of pairs $(p_i, s_i)$, where $p_i \in E(F_p)$ is a point on the curve and $s_i \in \mathbb{N}_0$ is a scalar. The function calculates $\sum s_i \cdot p_i$.

The multiplication on the scalar is the addition of that point a scalar number of times:

$$
s \cdot p = \underbrace{p + p + \ldots + p}_{s}
$$

The $E(F_p)$ curve,  points on the curve and the addition operation are defined in the BLS12-381 Curve Specification section.

Note:

- We take as input any points on the curve, not only from   $G_1$.
- The scalar is an arbitrary unsigned integer and can be bigger than the group order.

***Input:*** the sequence of pairs $(p_i, s_i)$, where $p_i \in E(F_p)$ is a point on the curve and $s_i \in \mathbb{N}_0$ is a scalar. Each point is encoded in decompress form as $(x\colon F_p, y\colon F_p)$ and a scalar has a type `u256` and BigEndian encoded in 32 bytes. Expected `128*k` bytes as an input that is interpreted as byte concatenation of `k` slices ($k \le 1000$), each slice is the concatenation of uncompressed point from $E(F_p)$ — `96` bytes and scalar — `32` bytes. More details are in the Curve Points Encoding section.

***Output:***
the ERROR_CODE is returned.

- If the input is correct: ERROR_CODE = 0, the output is 96 bytes — the one point $\in E(F_p)$ in decompressed form. For empty input it returns point on infinity (see  Curve Points Encoding section).
- If field elements encoded incorrectly (see Curve points encoded section): ERROR_CODE = 1, the output is empty
- If point not on the curve: ERROR_CODE = 2, the output is empty

***Gas Estimation:***

For simplicity, we will use the linear formula for gas calculation:

```rust
let k = input_bytes / item_size
let gas_consumed = A + B * k
```

A and B are constants calculated empirically.

To improve gas costs Pippenger’s algorithm[^25] can be used. For gas estimation, we can use the benchmark vectors for addition and multiplication for EIP-2537[^46].

***Test cases:***

<ins>Tests for multiplication</ins>

- tests with known answer for multiplication from EIP-2537
- random small scalar n and point P:
  - check with sum function results: `P + P + P .. + P = n*P`
  - check with result from another library
- random scalar n and point P:
  - check with result from another library
  - implement multiplication by using sum function and double-and-add algorithm[^61]

Edge cases:

- `group_order * P = 0`
- `(scalar + groupt_order) * P = scalar * P`
- `P + P + P .. + P = N*P`
- `0 * P = 0`
- `1 * P = P`
- Scalar is a MAX_INT

<ins>Tests for sum of two points</ins>
The same test cases as for the bls12381_g1_sum section.

- random points P and Q, compare results with sum function

<ins>Tests for the sum of an arbitrary amount of points</ins>

- random points number amount, random points, compare results with sum function
- empty input
- input of maximum size

<ins>Tests for the multiexp of an arbitrary amount of points</ins>

- tests with known answers from EIP-2537
- random number of points, scalars, points:
  - check with results from another library
  - check with raw implementation based on sum function and double-and-add algorithm
- empty input
- maximum input with MAX_INT scalars and random points

<ins>Tests for error cases</ins>
The same test cases as for the bls12381_g1_sum section.

***Tests References:***

The EIP-2537 contains the same function, so we can reuse test vectors from Ethereum[^47],[^48].

***Error cases:***

- The input length is not divided by 128
- Too much memory is used
- Number of points more than 1000

***Annotation:***

The input is obtained from memory started from `value_ptr` to `value_ptr + value_len`,
if the `value_len` is `u64::MAX` the input will be obtained from register.

The output data will be written to register with `register_id` id.

The ERROR_CODE is returned.

```rust
pub fn bls12381_g1_multiexp(
        &mut self,
        value_len: u64,
        value_ptr: u64,
        register_id: u64,
) -> Result<u64>;
```

#### ***bls12381_g2_multiexp***

***Description:***

The function takes as input the list of pairs $(p_i, s_i)$, where $p_i \in E'(F_{p^2})$ is a point on the curve and $s_i \in \mathbb{N}_0$ is a scalar. The function calculates $\sum s_i \cdot p_i$.

The multiplication on the scalar is the addition of that point a scalar number of times:

$$
s \cdot p = \underbrace{p + p + \ldots + p}_{s}
$$

The $E'(F_{p^2})$ curve,  points on the curve and the addition operation are defined in the BLS12-381 Curve Specification section.

Note:

- We take as input any points on the curve, not only from $G_2$.
- The scalar is an arbitrary unsigned integer and can be bigger than the group order.

***Input:*** the sequence of pairs $(p_i, s_i)$, where $p_i \in E'(F_{p^2})$ is a point on the curve and $s_i \in \mathbb{N}_0$ is a scalar. 

Each point is encoded in decompress form as $(x\colon F_{p^2}, y\colon F_{p^2})$ and a scalar has a type `u256` and BigEndian encoded in 32 bytes. Expected `224*k` bytes as an input that is interpreted as byte concatenation of `k` slices ($k \le 1000$), each slice is the concatenation of uncompressed point from $E'(F_{p^2})$ — `192` bytes and scalar — `32` bytes. More details are in the Curve Points Encoding section.

***Output:*** 

the ERROR_CODE is returned.

- If the input is correct: ERROR_CODE = 0, the output is 96 bytes — the one point $\in E(F_p)$ in decompressed form. For empty input it returns point on infinity (see  Curve Points Encoding section).
- If field elements encoded incorrectly (see Curve points encoded section): ERROR_CODE = 1, the output is empty
- If point not on the curve: ERROR_CODE = 2, the output is empty

the output is 192 bytes — the one point $\in E'(F_{p^2})$ in decompressed form. For empty input it returns point on infinity(see Curve Points Encoding section).

***Gas Estimation:***

For simplicity, we will use the linear formula for gas calculation:

```rust
let k = input_bytes / item_size
let gas_consumed = A + B * k
```

A and B are constants calculated empirically.

To improve gas costs Pippenger’s algorithm[^25] can be used. For gas estimation, we can use the benchmark vectors for addition and multiplication for EIP-2537[^46].

***Test cases:***

The same as for **`bls12381_g1_multiexp`** only change points from $G_1$ and $E(F_p)$ into $G_2$ and $E'(F_{p^2})$.

***Tests References:***

The EIP-2537 contains the same function, so we can reuse test vectors from Ethereum[^47],[^48].

***Error cases:***

- The input length is not divided by 224
- Too much memory is used
- Field elements encoded incorrectly (see Curve points encoded section)
- Any points not on the curve
- Number of points more than 1000

***Annotation:***

The input is obtained from memory started from `value_ptr` to `value_ptr + value_len`,
if the `value_len` is `u64::MAX` the input will be obtained from register.

The output data will be written to register with `register_id` id.

The ERROR_CODE is returned.

```rust
pub fn bls12381_g2_multiexp(
        &mut self,
        value_len: u64,
        value_ptr: u64,
        register_id: u64,
) -> Result<u64>;
```

#### bls12381_map_fp_to_g1

***Description:***

The function takes the element $a \in F_p$ and maps it to the $G_1 \subset E(F_p)$. The specification of the mapping function you can find in the section "Map to curve specification". This function does NOT perform mapping of the byte string into $F_p$, it can be implemented in different ways and this can be performed effectively in contract.

***Input:*** the function takes as input `48` bytes — the element from $F_p$ (one unsigned integer $< p$). More details are in the Curve Points Encoding section.

***Output:*** 

the ERROR_CODE is returned.

- If the input is correct: ERROR_CODE = 0, the output is 96 bytes — the one point $\in E(F_p)$ in decompressed form. For empty input it returns point on infinity (see  Curve Points Encoding section).
- $a \ge p$: ERROR_CODE = 1, the output is empty

the output is `96 bytes` — one point $\in G_1 \subset E(F_p)$ in decompressed format. More details are in the Curve Points Encoding section.

***Gas Estimation:***

The gas consumption is a constant calculated empirically.

***Test cases:***

<ins>Tests for general cases </ins>

- validate the results for known answers. Tests for same function in EIP-2537
- generate random point $a$ from Fp:
  - check the result with another library
  - check that result point on curve in G1
  - compare results for $a$ and $-a$, it should be the same x coordinates and opposite y.

Edge cases:

- $a = 0$
- $a = p - 1$

<ins>Tests for error cases </ins>

- input length not equal to 48 bytes: 
  - empty input
  - 96 bytes
  - out of memory input length
- $a = p$
- random number $\ge p$

***Tests References:*** The EIP-2537 contains the same function, so we can reuse test vectors from Ethereum[^47],[^48].

***Error cases:***

- Incorrect input length

***Annotation:***

The input is obtained from memory started from `value_ptr` to `value_ptr + value_len`,
if the `value_len` is `u64::MAX` the input will be obtained from register.

The output data will be written to register with `register_id` id.

The ERROR_CODE is returned.

```rust
pub fn bls12381_map_fp_to_g1(
        &mut self,
        value_len: u64,
        value_ptr: u64,
        register_id: u64,
) -> Result<u64>;
```

#### bls12381_map_fp2_to_g2

***Description:***

The function takes the element $a \in F_{p^2}$ and maps it to the $G_2 \subset E'(F_{p^2})$. The specification of the mapping function you can find in the section "Map to curve specification". This function does NOT perform mapping of the byte string into $F_{p^2}$, it can be implemented in different ways and this can be performed effectively in the contract.

***Input:*** the function takes as input `96 bytes` — the element from $F_{p^2}$ (two unsigned integers $< p$). More details are in the Curve Points Encoding section.

***Output:*** 

the ERROR_CODE is returned.

- If the input is correct: ERROR_CODE = 0, the output is 96 bytes — the one point $\in E(F_p)$ in decompressed form. For empty input it returns point on infinity (see  Curve Points Encoding section).
- If value is not a valid extension field $F_{p^2}$ element: ERROR_CODE = 1, the output is empty

the output is `192 bytes` — one point $\in G_2 \subset E'(F_{p^2})$ in decompressed format. More details are in the Curve Points Encoding section.

***Gas Estimation:***

The gas consumption is a constant calculated empirically.

***Test cases:***

<ins>Tests for general cases </ins>

- validate the results for known answers. Tests for same function in EIP-2537
- generate random point $a$ from $F_{p^2}$:
  - check the result with another library
  - check that result point on curve in G2
  - compare results for $a$ and $-a$, it should be the same x coordinates and opposite y.

Edge cases:

- $a = (0, 0)$
- $a = (p - 1, p - 1)$

<ins>Tests for error cases </ins>

- input length not equal to 96 bytes:
  - empty input
  - 192 bytes
  - out of memory input length
- $a = (0, p)$
- $a = (p, 0)$
- (random number $\ge p$, 0)
- (0, random number $\ge p$)

***Tests References:*** The EIP-2537 contains the same function, so we can reuse test vectors from Ethereum[^47],[^48].

***Error cases:***

- Incorrect input length

***Annotation:***

The input is obtained from memory started from `value_ptr` to `value_ptr + value_len`,
if the `value_len` is `u64::MAX` the input will be obtained from register.

The output data will be written to register with `register_id` id.

The ERROR_CODE is returned.

```rust
pub fn bls12381_map_fp2_to_g2(
        &mut self,
        value_len: u64,
        value_ptr: u64,
        register_id: u64,
) -> Result<u64>;
```

#### bls12381_pairing_check

***Description:***

The pairing function $e\colon G_1 \times G_2 \rightarrow G_T$, where $G_T \subset F_{q^{12}}$. The pairing function has the following properties:

- $e(P, Q + R) = e(P, Q) \cdot e(P, R)$
- $e(P + S, R) = e(P, R)\cdot e(S, R)$

The consequence:

$e([a]P, [b]Q) = e(P, Q)^{ab} = e([b]P, [a]Q)$

We need this function to verify BLS signature.

This function takes as input the sequence of pairs $(p_i, q_i)$, where $p_i \in G_1 \subset E(F_{p})$ and $q_i \in G_2 \subset E'(F_{p^2})$ and check:

$$
\prod e(p_i, q_i) = 1
$$

We don’t calculate the pairing function itself: the result will be in the huge field, and in all known applications only such a check is necessary.

***Input:*** the sequence of pairs $(p_i, q_i)$, where $p_i \in G_1 \subset E(F_{p})$ and $q_i \in G_2 \subset E'(F_{p^2})$. Each point is encoded in decompressed form. Expected `288*k` bytes as an input that is interpreted as byte concatenation of `k` slices ($k \le 1000$), each slice is the concatenation of uncompressed point from $G_1 \subset E(F_p)$ — `96 bytes` and point from $G_2 \subset E'(F_{p^2})$ — `192 bytes`. More details are in the Curve Points Encoding section.

***Output:***

the ERROR_CODE is returned.

- If the input is correct and the pairing result is equal to multiplicative identity : ERROR_CODE = 0
- If field elements encoded incorrectly (see Curve points encoded section): ERROR_CODE = 1
- If point not on the curve: ERROR_CODE = 2
- If point not in $G_1/G_2$: ERROR_CODE = 3
- If the input is correct and the pairing result is not equal to multiplicative identity : ERROR_CODE = 5

For empty input it returns ERROR_CODE = 0.

***Gas Estimation:***

The algorithm has a linear complexity of the number of elements. The gas can be calculated by the next formula

```rust
let k = input_bytes / item_size
let gas_consumed = A + B * k
```

A and B are constants calculated empirically.

Here you can find benchmark test vectors for EIP-2537[^46].

***Test cases:***

<ins>Tests for one pair</ins>

- generate random $P \in G_1$: check $e(P, 0) = 1$
- generate random $Q \in G_2$: check $e(0, Q) = 1$
- generate random $P \ne 0 \in G_1$ and $Q \ne 0 \in G_2$: check $e(P, Q) \ne 1$  

<ins>Tests for two pairs</ins>

- generate random points $P \in G_1$, $Q \in G_2$ and random scalars $s_1, s_2$:
  - $e(P, Q) \cdot e(P, -Q) = 1$
  - $e(P, Q) \cdot e(-P, Q) = 1$
  - $e(s_1P, s_2Q) \cdot e(-s_2P, s_1Q) = 1$
  - $e(s_1P, s_2Q) \cdot e(s_2P, -s_1Q) = 1$

- $g_1 \in G_1$, $g_2 \in G_2$ -- generators defined in section 'BLS12-381 Curve Specification', r -- order of $G_1$ and $G_2$,  and $p_1, p_2, q_1, q_2$ randomly generated scalars:
  - if $p_1 \cdot q_1 + p_2 \cdot q_2 \not \equiv 0 (\mod r)$, check $e(p_1 g_1, q_1 g_2) \cdot e(p_2 g_1, q_2 g_2) \ne 1$
  - if $p_1 \cdot q_1 + p_2 \cdot q_2 \equiv 0 (\mod r)$, check $e(p_1 g_1, q_1 g_2) \cdot e(p_2 g_1, q_2 g_2) = 1$

<ins>Tests for arbitrary amount of pairs</ins>

- empty input
- test with maximum available amount of pairs
- tests with known answers from EIP-2537
- random pairs numbers, random scalars $p_1 \cdots p_n$ and $q_1 \cdots q_n$ such as $\sum p_i \cdot q_i \not \equiv 0 (\mod r)$:
  - check $\prod e(p_i g_1, q_i g_2) \ne 1$
- random pairs numbers, random scalars $p_1 \cdots p_{n - 1}$ and $q_1 \cdots q_{n - 1}$:
  - check $(\prod e(p_i g_1, q_i g_2)) \cdot e(-(\sum p_i q_i) g_1, g_2) = 1$
  - check $(\prod e(p_i g_1, q_i g_2)) \cdot e(g_1, -(\sum p_i q_i) g_2) = 1$

<ins>Tests for error cases</ins>

- The first point on the curve but not in G1
- The second point on the curve but not in G2
- The input length not divided by 288
- The first point not on the curve
- The second point not on the curve
- Number of point more than 1000
- Input length exceeds memory limit
- The incorrect 0 point encoding
- Incorrect encoding of curve point:
  - wrong decompression bit
  - coordinates bigger or equal than p

***Tests References:*** The EIP-2537 contains the same function, so we can reuse test vectors from Ethereum[^47],[^48].

***Error cases:***

- The input length is not divided by 288
- Too much memory is used
- Number of pairs more than 1000

***Annotation:***

The input is obtained from memory started from `value_ptr` to `value_ptr + value_len`,
if the `value_len` is `u64::MAX` the input will be obtained from register.

The ERROR_CODE is returned.

```rust
pub fn bls12381_pairing_check(&mut self, value_len: u64, value_ptr: u64) -> Result<u64>;
```

#### bls12381_decompress_g1

***Description:***  Function decompress compressed points from $E(F_p)$. The input is an arbitrary number of points $p_i \in E(F_p)$ in compressed format, and the output is the same number of points from $E(F_p)$ in decompressed format. More about the decompressed and compressed formats you can read in the Curve Points Encoding section.

***Input:***  the sequence of point $p_i \in E(F_p)$, each point encoded in compressed form. Expected `48*k` bytes as an input that is interpreted as byte concatenation of `k` slices ($k \le 1000$), each slice is the compressed point from $E(F_p)$. More details are in the Curve Points Encoding section.

***Output:***

the ERROR_CODE is returned.

- If the input is correct: ERROR_CODE = 0, the output is the sequence of point $p_i \in E(F_p)$, each point encoded in decompressed form. Expected `96*k` bytes as an output that is interpreted as byte concatenation of `k` slices, each slice is the decompressed point from $E(F_p)$. `k` the same as in input. More details are in the Curve Points Encoding section.
- If field elements encoded incorrectly (see Curve points encoded section): ERROR_CODE = 1, the output is empty
- If point not on the curve: ERROR_CODE = 2, the output is empty

***Gas Estimation:*** The algorithm has a linear complexity of the number of elements. The gas can be calculated by the next formula

```rust
let k = input_bytes / item_size
let gas_consumed = A + B * k
```

A and B are constants calculated empirically.

***Test cases:***

<ins>Tests for one point decompression</ins>

- generate random points on the curve from G1 and not from G1:
  - check that the uncompressed point lies on the curve
  - compare the result with another library
- generate random points with negative y:
  - take inverse and compare y
  - compare the result with another library
- decompress point on infinity

<ins>Tests for decompression of arbitrary amount of points</ins>

- empty input
- maximum amount of points
- generate the random amount of the random points on curve and compare the result with another library

<ins>Tests for error cases</ins>

- the input length is not divided by 48
- input length exceeds memory limit
- 1001 points on input
- point not on the curve
- incorrect decompression bit
- incorrectly encoded infinity point
- point with coordinate bigger then p

***Tests References:***

- Take the correct points on the curve from Ethereum tests[^47],[^48] and check the correctness after decompression
- Randomly generate compressed points and check the equation correctness after decompression.

***Error cases:***

- The input length is not divided by 48
- Too much memory is used
- Number of points more than 1000

***Annotation:***

The input is obtained from memory started from `value_ptr` to `value_ptr + value_len`,
if the `value_len` is `u64::MAX` the input will be obtained from register.

The output data will be written to register with `register_id` id.

The ERROR_CODE is returned.

```rust
pub fn bls12381_decompress_g1(&mut self, 
                              value_len: u64, 
                              value_ptr: u64, 
                              register_id: u64) -> Result<u64>;
```

#### bls12381_decompress_g2

***Description:***  Function decompress compressed points from $E'(F_{p^2})$. The input is an arbitrary number of points $p_i \in E'(F_{p^2})$ in compressed format, and the output is the same number of points from $E'(F_{p^2})$ in decompressed format. More about the decompressed and compressed formats you can read in the Curve Points Encoding section.

***Input:***  the sequence of point $p_i \in E'(F_{p^2})$, each point encoded in compressed form. Expected `96*k` bytes as an input that is interpreted as byte concatenation of `k` slices ($k \le 1000$), each slice is the compressed point from $E'(F_{p^2})$. More details are in the Curve Points Encoding section.

***Output:***

the ERROR_CODE is returned.

- If the input is correct: ERROR_CODE = 0, the output is the sequence of point $p_i \in E'(F_{p^2})$, each point encoded in decompressed form. Expected `192*k` bytes as an output that is interpreted as byte concatenation of `k` slices, each slice is the decompressed point from $E'(F_{p^2})$. `k` the same as in input. More details are in the Curve Points Encoding section.
- If field elements encoded incorrectly (see Curve points encoded section): ERROR_CODE = 1, the output is empty
- If point not on the curve: ERROR_CODE = 2, the output is empty

***Gas Estimation:*** The algorithm has a linear complexity of the number of elements. The gas can be calculated by the next formula

```rust
let k = (input_bytes + item_size - 1)/item_size
let gas_consumed = A + B * k
```

A and B are constants calculated empirically.

***Test cases:***

The same test cases as for `bls12381_decompress_g1` but with points from $G_2$ and the input length should be divided by 96.

***Tests References:***

- Take the correct points on the curve from Ethereum tests[^47],[^48] and check the correctness after decompression
- Randomly generate compressed points and check the equation correctness after decompression.

***Error cases:***

- The input length is not divided by 96
- Too much memory is used
- Number of points more than 1000

***Annotation:***

The input is obtained from memory started from `value_ptr` to `value_ptr + value_len`,
if the `value_len` is `u64::MAX` the input will be obtained from register.

The output data will be written to register with `register_id` id.

The ERROR_CODE is returned.

```rust
pub fn bls12381_decompress_g2(&mut self, 
                              value_len: u64, 
                              value_ptr: u64, 
                              register_id: u64) -> Result<u64>;
```

## Reference Implementation

First of all, for integration with nearcore, we are interested in libraries in the Rust language. The existing BLS12-381 implementations on Rust:

1. ***Milagro Library*** [^29].
2. ***BLST***  [^30][^31].
3. ***Matter labs EIP-1962 implementation*** [^32]
4. ***zCash origin implementation*** [^33]
5. ***MCL Library*** [^34]
6. ***FileCoin implementation*** [^35]
7. ***zkCrypto*** [^36]

To compile the list, we used the links from EIP-2537[^43], pairing-curves specification[^44], and an article with benchmarks[^45]. This list may be incomplete but should cover the core BLS12-381 implementations. In any case, to implement host functions from that NEP we will need to modify any of that libraries.

In addition, there are implementations in other languages that are not so interesting to us in this context, but can be used as references:

1. C++, ETH2.0 Client, ***Chia library***[^37]
2. Haskell, ***Adjoint Lib***[^38]
3. Go, ***Go-Ethereum***[^39]
4. JavaScript, ***Noble JS***[^40]
5. Go, ***Matter Labs Go EIP-1962 implementation***[^41]
6. C++, ***Matter Labs Go EIP-1962 implementation***[^42]

One of the possible libraries to use is *blst* library[^30]. This library shows a good performance[^45] and passed some audits[^55].
The draft implementation in nearcore, which is based on this library, you can find by this link[^54].

## Security Implications

The implementation security relies on the security of the chosen library, which supports operations with BLS curves.

In this NEP, we do not require a constant execution time for all operations. This is not a problem if you use host functions to verify the BLS signature. These host functions should not be used if you need a constant-time algorithm.

The BLS12-381 has more security bits than the already existing pairing-friendly curve BN254, as a result, the security of the projects which need the pairing-friendly curve will improve.

## Alternatives

In the nearcore the host functions for another pairing-friendly curve BN254 are already implemented[^10]. For some projects[^20] the alternative is just to use the supported curve. However, according to the recent research, this curve contains less than 100 bits of security and is not recommended to use[^13]. Moreover, projects with cross-chain interactions, such as Rainbow Bridge, must use the same curve as in a target protocol, and for Ethereum it is BLS12-381[^3] nowadays. As a result, there is no alternative to using another pairing-friendly curve.

Another alternative is to create one simple host function in nearcore for BLS-signature verification. It was the first suggested solution[^26]. However, this solution is not flexible enough[^28]: (1) projects can use different hash functions; (2) some projects can use G1 subgroup for the public keys, and others – G2; (3) the specification for Ethereum 2.0 continue to be in the draft and details can change, (4) we have one big function instead of a more diverse and flexible set of functions (inspired by EIP-2537's precompiles).

The next alternative is to execute BLS12-381 operations off-chain. In that case, the applications which are using the BLS curve will not be trustless anymore.

## Future possibilities

In the future, it is possible to support work with other curves, not only BLS12-381. In Ethereum, before EIP-2537[^15], EIP-1962 was proposed[^27]. In EIP-1962 was proposed to implement pairing-friendly elliptic curves in a generic format and support not only BLS curves but many others. However, this proposal wasn't accepted due to its large scope and complexity. I don't think it makes sense to implement every possible curve, but it could be a possible extension.

## Consequences

### Positive

- Projects, which are using BN254 will be able to switch on BLS12-381 curve, and it will improve their security.
- The trustless cross-chain interactions with blockchains using BLS12-381 in protocols (such as Ethereum 2.0) will become possible.

### Neutral

### Negative

- The appearance of dependence on the library which supports BLS12-381 curves operations.
- We will need to maintain operations with BLS12-381 curve forever, even if vulnerabilities are found, and it is no longer safe to use.

### Backward Compatibility

There are no backward compatibility questions.

## Changelog

The previous NEP for supporting BLS signature based on BLS12-381[^26]

[^1]: BLS 2002 [https://www.researchgate.net/publication/2894224_Constructing_Elliptic_Curves_with_Prescribed_Embedding_Degrees](https://www.researchgate.net/publication/2894224_Constructing_Elliptic_Curves_with_Prescribed_Embedding_Degrees)
[^2]: ZCash protocol: [https://zips.z.cash/protocol/protocol.pdf](https://zips.z.cash/protocol/protocol.pdf)
[^3]: Ethereum 2 specification: [https://github.com/ethereum/consensus-specs/blob/master/specs/phase0/beacon-chain.md](https://github.com/ethereum/consensus-specs/blob/master/specs/phase0/beacon-chain.md)
[^4]: Dfinity: [https://internetcomputer.org/docs/current/references/ic-interface-spec#certificate](https://internetcomputer.org/docs/current/references/ic-interface-spec#certificate)
[^5]: Tezos: [https://wiki.tezosagora.org/learn/futuredevelopments/layer2#zkchannels](https://wiki.tezosagora.org/learn/futuredevelopments/layer2#zkchannels)
[^6]: Filecoin: [https://spec.filecoin.io/](https://spec.filecoin.io/)
[^7]: Specification of pairing friendly curves with a list of applications in the table: [https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#name-adoption-status-of-pairing-](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#name-adoption-status-of-pairing-)
[^8]: Specification of pairing friendly curves, the security level for BLS12-381: [https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#section-4.2.1](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#section-4.2.1)
[^9]: BN2005: [https://eprint.iacr.org/2005/133](https://eprint.iacr.org/2005/133)
[^10]: NEP-98 for BN254 host functions on NEAR: [https://github.com/near/NEPs/issues/98](https://github.com/near/NEPs/issues/98)
[^11]: BLS12-381 for the Rest of Us: [https://hackmd.io/@benjaminion/bls12-381](https://hackmd.io/@benjaminion/bls12-381)
[^12]: BN254 for the Rest of Us: [https://hackmd.io/@jpw/bn254](https://hackmd.io/@jpw/bn254)
[^13]: Some analytics of different curve security: [https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-02.html#name-for-100-bits-of-security](https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-02.html#name-for-100-bits-of-security)
[^14]: ZCash Transfer from bn254 to bls12-381: [https://electriccoin.co/blog/new-snark-curve/](https://electriccoin.co/blog/new-snark-curve/)
[^15]: EIP-2537 Precompiles for Ethereum for BLS12-381: [https://eips.ethereum.org/EIPS/eip-2537](https://eips.ethereum.org/EIPS/eip-2537)
[^17]: Article about Rainbow Bridge [https://near.org/blog/eth-near-rainbow-bridge](https://near.org/blog/eth-near-rainbow-bridge)
[^19]: Intro into zkSNARKs: [https://media.consensys.net/introduction-to-zksnarks-with-examples-3283b554fc3b](https://media.consensys.net/introduction-to-zksnarks-with-examples-3283b554fc3b)
[^20]: Zeropool project: [https://zeropool.network/](https://zeropool.network/)
[^24]: Precompiles on Aurora: [https://doc.aurora.dev/evm/precompiles/](https://doc.aurora.dev/evm/precompiles/)
[^25]: Pippenger Algorithm: [https://github.com/wborgeaud/python-pippenger/blob/master/pippenger.pdf](https://github.com/wborgeaud/python-pippenger/blob/master/pippenger.pdf)
[^26]: NEP-446 proposal for BLS-signature verification: [https://github.com/nearprotocol/neps/pull/446](https://github.com/nearprotocol/neps/pull/446)
[^27]: EIP-1962 EC arithmetic and pairings with runtime definitions: [https://eips.ethereum.org/EIPS/eip-1962](https://eips.ethereum.org/EIPS/eip-1962)
[^28]: Drawbacks of NEP-446: [https://github.com/near/NEPs/pull/446#pullrequestreview-1314601508](https://github.com/near/NEPs/pull/446#pullrequestreview-1314601508)
[^29]: BLS12-381 Milagro: [https://github.com/sigp/incubator-milagro-crypto-rust/tree/057d238936c0cbbe3a59dfae6f2405db1090f474](https://github.com/sigp/incubator-milagro-crypto-rust/tree/057d238936c0cbbe3a59dfae6f2405db1090f474)
[^30]: BLST: [https://github.com/supranational/blst](https://github.com/supranational/blst),
[^31]: BLST EIP-2537 adaptation: [https://github.com/sean-sn/blst_eip2537](https://github.com/sean-sn/blst_eip2537)
[^32]: EIP-1962 implementation matter labs Rust: https://github.com/matter-labs/eip1962
[^33]: zCash origin rust implementation: [https://github.com/zcash/zcash/tree/master/src/rust/src](https://github.com/zcash/zcash/tree/master/src/rust/src)
[^34]: MCL library: [https://github.com/herumi/bls](https://github.com/herumi/bls)
[^35]: filecoin/bls-signature: [https://github.com/filecoin-project/bls-signatures](https://github.com/filecoin-project/bls-signatures)
[^36]: zkCrypto: [https://github.com/zkcrypto/bls12_381](https://github.com/zkcrypto/bls12_381), [https://github.com/zkcrypto/pairing](https://github.com/zkcrypto/pairing)
[^37]: BLS12-381 code bases for ETH2.0 client Chia library C++: [https://github.com/Chia-Network/bls-signatures](https://github.com/Chia-Network/bls-signatures)
[^38]: Adjoint Lib: [https://github.com/sdiehl/pairing](https://github.com/sdiehl/pairing)
[^39]: Ethereum Go implementation for EIP-2537: [https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles](https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles)
[^40]: Noble JS implementation: [https://github.com/paulmillr/noble-bls12-381](https://github.com/paulmillr/noble-bls12-381)
[^41]: EIP-1962 implementation matter labs Go: https://github.com/kilic/eip2537,
[^42]: EIP-1962 implementation matter labs C++: https://github.com/matter-labs-archive/eip1962_cpp
[^43]: EIP-2537 with links: [https://github.com/matter-labs-forks/EIPs/blob/bls12_381/EIPS/eip-2537.md](https://github.com/matter-labs-forks/EIPs/blob/bls12_381/EIPS/eip-2537.md)
[^44]: Pairing-friendly curves specification, crypto libs: [https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#name-cryptographic-libraries](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#name-cryptographic-libraries)
[^45]: Comparing different libs for pairing-friendly curves: [https://hackmd.io/@gnark/eccbench](https://hackmd.io/@gnark/eccbench)
[^46]: Bench vectors from EIP2537: [https://eips.ethereum.org/assets/eip-2537/bench_vectors](https://eips.ethereum.org/assets/eip-2537/bench_vectors)
[^47]: Metter Labs tests for EIP2537: [https://github.com/matter-labs/eip1962/tree/master/src/test/test_vectors/eip2537](https://github.com/matter-labs/eip1962/tree/master/src/test/test_vectors/eip2537)
[^48]: Tests from Go Ethereum implementation: [https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles](https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles)
[^51]: draft-irtf-cfrg-pairing-friendly-curves-11 [https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11#name-bls-curves-for-the-128-bit-](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11#name-bls-curves-for-the-128-bit-)  *(*[https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/bls.md](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/bls.md) → [https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04) → this ref*)*
[^52]: Paper with BLS12-381: [https://eprint.iacr.org/2019/403.pdf](https://eprint.iacr.org/2019/403.pdf)
[^53]: Zkcrypto points encoding: [https://github.com/zkcrypto/pairing/blob/0.14.0/src/bls12_381/README.md](https://github.com/zkcrypto/pairing/blob/0.14.0/src/bls12_381/README.md)
[^54]: Draft PR for BLS12-381 operations in nearcore: https://github.com/near/nearcore/pull/9317
[^55]: Audit for BLST library: [https://research.nccgroup.com/wp-content/uploads/2021/01/NCC_Group_EthereumFoundation_ETHF002_Report_2021-01-20_v1.0.pdf](https://research.nccgroup.com/wp-content/uploads/2021/01/NCC_Group_EthereumFoundation_ETHF002_Report_2021-01-20_v1.0.pdf)
[^58]: BLST errors list. [https://github.com/supranational/blst/blob/v0.3.11/src/errors.h](https://github.com/supranational/blst/blob/v0.3.11/src/errors.h)
[^59]: Implementation of BLS-signature based on these host functions: [https://github.com/olga24912/bls-signature-verificaion-poc/blob/main/src/lib.rs](https://github.com/olga24912/bls-signature-verificaion-poc/blob/main/src/lib.rs)
[^60]: hash_to_field specification: [https://datatracker.ietf.org/doc/html/rfc9380#name-hash_to_field-implementatio](https://datatracker.ietf.org/doc/html/rfc9380#name-hash_to_field-implementatio)
[^61]: double-and-add algorithm: [https://en.wikipedia.org/wiki/Exponentiation_by_squaring](https://en.wikipedia.org/wiki/Exponentiation_by_squaring)
[^62]: RFC 9380 Hashing to Elliptic Curves specification: [https://www.rfc-editor.org/rfc/rfc9380](https://www.rfc-editor.org/rfc/rfc9380)
[^63]: map_to_curve and clear_cofactor functions: [https://datatracker.ietf.org/doc/html/rfc9380#name-encoding-byte-strings-to-el](https://datatracker.ietf.org/doc/html/rfc9380#name-encoding-byte-strings-to-el)
[^64]: Specification of parameters for BLS12-381 G1: [https://datatracker.ietf.org/doc/html/rfc9380#name-bls12-381-g1](https://datatracker.ietf.org/doc/html/rfc9380#name-bls12-381-g1)
[^65]: Specification of parameters for BLS12-381 G2: [https://datatracker.ietf.org/doc/html/rfc9380#name-bls12-381-g2](https://datatracker.ietf.org/doc/html/rfc9380#name-bls12-381-g2)
