---
NEP: 488
Title: Precompile for BLS12-381 curve operations
Authors: Olga Kuniavskaia <olga.kunyavskaya@aurora.dev>
Status: Draft
DiscussionsTo: https://github.com/nearprotocol/neps/pull/488
Type: Runtime Spec
Version: 0.0.1
Created: 2023-07-17
LastUpdated: 2023-07-17
---

## Summary

A pre-compiled NEAR runtime functions for operations on BLS12-381 curve. It is a necessary set to efficiently perform operations such as BLS signature and zkSNARKs verifications.

## Motivation

The BLS12-381([^1],[^11],[^52]) is a wildly 
used([^2],[^3],[^4],[^5],[^6],[^7]) elliptic curve with 120+ bits of security[^8] which support **the *pairing* operation*.* It is a good alternative for bn254 elliptic curve([^9], [^12]), which also supports the aggregation, and is currently implemented as NEAR precompiles[^10]. Recent research shows that it contains only <100 bits of security[^13] and we can see the tendency of switching from bn254 to bls12-381(ZCash[^14], Ethereum[^15], Tezos[^16]).

The implementation of  BLS12-381 curve operations from this NEP as a precompile will allows effective verify the BLS-signature and zkSNARKs. At the moment, BLS signature verification for BLS12-381 is impossible due to the limitation of the gas in 300 TGas for one transaction.

Effective BLS-signature verification based on BLS12-381 elliptic curve will be useful for cross-chain interactions. Some of the blockchains use the BLS signature in the protocols. If we want to implement the clients for this blockchain on-chain in NEAR, we should be able to effectively verify the BLS signature. We can want to have a client for a specific blockchain on Near for creating a bridge to verify the transaction from another blockchain and use it in Near. Examples of blockchains that use BLS signature based on BLS12-381: Eth2.0[^3], Filecoin[^6] and Tezos[^5]. Especially, it is necessary for Rainbow Bridge[^17] to make trustless transfers from Ethereum 2.0 to Near.

zkSNARKs is useful for working with user's private information([^18],[^19]). Zeropool[^20] is a project who implements zkSNARKs verifier on Near and is currently based on alt-bn128. Implementation of the precompiles for BLS12-381 can make the projects like that more secure. zkSNARKs is also used in Roll Ups([^21], [^22], [^23]) scaling solutions.

This proposal is based on a similar proposal for Ethereum: EIP-2537[^15].

In this NEP we propose to add the following functions as precompile:

- ***bls12381_g1_sum —*** the function which adds the signed points from G1 on an elliptic curve. This function is useful for the aggregation of private keys in BLS Signature. Can be used for simple addition in G1. Separate from multiexp function due to gas cost. A similar function exists in Near for BN254 curve[^10].
- ***bls12381_g2_sum —*** the function which adds the signed points from G2 on an elliptic curve. This function is useful for the aggregation of signatures in BLS Signature. Can be used for simple addition in G2. Separate from multiexp function due to gas cost.
- ***bls12381_g1_multiexp —*** for points $g_i \in G_1$ and scalars $s_i$ calculate $\sum g_i s_i$. Can be used for multiplication on the scalar. Can be useful for zkSNARKs verification. This operation can be performed in a more optimized way than just straightforward multiplication and addition by using Pippenger algorithm[^25]. A similar function exists both in NEAR for BN254[^10] and in EIP-2537[^15].
- ***bls12381_g2_multiexp —*** for points $g_i \in G_2$ and scalars $s_i$ calculate $\sum g_i s_i$. Can be used for multiplication on the scalar.
- ***bls12381_g1_map_to_curve —*** map base field element into the $G_1$ point. Doesn’t perform mapping of the byte string into field elements (can be done in different ways and quite fast). Transfer field element into a curve. It is necessary for signature schemes. Function from EIP-2537[^15].
- ***bls12381_g2_map_to_curve —*** map extension field element into the $G_2$ point. Doesn’t perform mapping of the byte string into extension field elements. Function from EIP-2537[^15].
- ***bls12381_g1_decompress —*** accepts points from $G_1$  in compressed form and returns in decompressed form. Some protocols provide points in compressed forms (for example, light client updates in Ethereum 2), and decompressing is a time-consuming operation. Other functions accept only decompressed points for simplicity and for gas consumption optimization.
- ***bls12381_g2_decompress —*** accepts points from $G_2$  in compressed form and returns in decompressed form.
- ***bls12381_pairing —*** verifying that $\prod e(p_i, q_i) = 1$, where $e$ is a pairing operation and $p_i \in G_1 \land q_i \in G_2$. Necessary function for verification BLS-signatures or zkSNARKs.  A similar function exists both in NEAR for BN254[^10] and in EIP-2537[^15].

By using these functions, we can reproduce all functionality from EIP-2537[^15]. Which can be useful for Aurora[^24] to support Ethereum functionality on NEAR.

## Specification

### BLS12-381 Curve Specification

#### Elliptic Curve

**Definition:** The field $F_p$ for some *prime* $p$ is a set of integer elements $\textbraceleft 0, 1, \ldots, p - 1 \textbraceright$ with two operations: multiplication $\cdot$ and addition $+$. These operations are performed as multiplication/addition for integers number and then taking the remainder modulo $p$.



**Definition:** The elliptic curve $E(F_p)$  is a set of all pairs $(x, y) \in F_p$:

$$
y^2 \equiv x^3 + Ax + B \mod p
$$

together with an imaginary point at infinity 0, where: $A, B \in F_p$, p is prime > 3, and $4A^3 + 27B^2 \not \equiv 0 \mod p$

In the case of BLS12-381 equation is $y^2 \equiv x^3 + 4 \mod p$[^15][^51][^14][^11]

**Parameters for our case:**

```rust
A = 0
B = 4
p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab
```

**Definition:** Let’s $P \in E(F_q)$ have coordinates (x, y), define $-P$  as a point on a curve with coordinates (x, -y).

**Definition:** The addition operation for Elliptic Curve is a function $+\colon E(F_p) \times E(F_p) \rightarrow E(F_p)$ defined with following rules: let’s P and Q $\in E(F_p)$

- if  $P \ne Q$ and $P \ne -Q$
  - draw a line passing through P and Q. This line intersects the curve at a third point R
  - reflect the point R about the x-axis by changing the sign of the y-coordinate. The resulting point is P+Q.
- if $P=Q$
  - draw a tangent line throw P for an elliptic curve. The line will intersect the curve at the second point R.
  - reflect the point R about the x-axis the same way to get point 2P
- $P = -Q$
  - $P + Q = P + (-P) = 0$ — the point on infinity
- Q = 0
  - $P + Q = P + 0 = P$

With the addition operation, Elliptic Curve forms a **group**.

#### Subgroups

**Definition:**  Subgroup H is a subset of the group G with the following properties:

- $\forall h_1, h_2 \in H\colon h_1 + h_2 \in H$
- $0 \in H$
- $\forall h \in H \colon -h \in H$

Notation: $H \subseteq G$

**Definition:** group/subgroup **order** is the number of elements in group/subgroup.

Notation: |G|  or #G, where G is group

For some technical reason (for `pairing` operation which we will define later), we will work not with the hole $E(F_p)$, but only with the two subgroups $G_1$and $G_2$ with the same **order** $r$. $G_1$ is a subset of $E(F_p)$, $G_2$ is a subgroup of another group, which we will define later. The $r$ should be prime and $G1 \ne G2$

For our BLS12-381 Elliptic Curve, **the order r** of $G1$  and $G2$[^15][^51]:

```rust
Main subgroup order r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001
```

#### Field extension

**Definition:**  The field extension $F_{p^k}$ is a set of all polynomials with degree < k and coefficients from $F_p$ and defined operations $\cdot$ , $+$

$$
a_{k - 1}x^{k - 1} + \ldots + a_1x + a_0 = A(x) \in F_{p^k} \vert a_i \in F_p
$$

The $+$ operation is defined as a regular addition for polynomials:

$$
A(x) + B(x) = C(x)
$$

$$
\sum a_i x^i + \sum b_i x^i = \sum c_i x^i
$$

$$
c_i = (a_i + b_i) \mod p
$$

The multiplication $\cdot$ is defined as a regular polynomials’ multiplication by modulo M(x), where M(x) is an ***irreducible*** polynomial of degree k with coefficients from $F_p$

$$
C(x) = A(x) \cdot B(x)\mod M(x)
$$

Notation: $F_{p^k} = F_{p}[x] / M(x)$

In BLS12-381 we will need $F_{p^{12}}$ and we will build this field not as an extension from $F_p$ directly, but first we will build $F_{p^2}$ as a quadratic extension of field $F_p$, second we will build $F_{p^6}$ as a cubic extension of $F_{p^2}$, and finally we will build  $F_{p^{12}}$ the quadratic extension of field $F_{p^6}$.

For defining these fields, we will need to set up three $M(x)$ irreducible polynomials[^51]:

- $F_{p^2} = F_p[u] / (u^2 + 1)$
- $F_{p^6} = F_{p^2}[v] / (v^3 - u - 1)$
- $F_{p^{12}} = F_{p^6}[w]/(w^2 - v)$

Our second subgroup of order r, which we will use, is a subgroup of the same Elliptic Curve but with elements from $F_{p^{12}}$.   $G_2 \subset E(F_{p^{12}})$, where $E: y^2 = x^3 + 4$

#### Twist

Store elements from $E(F_{p^{12}})$ takes a lot of memory. ***The twist*** operation transforms the origin curve $E(F_{p^{12}})$ into another curve under another space $E'(F_{p^2})$. It is important that the new curve also has a $G'_2$  subgroup with order r and we can easily transform it to origin $G_2$.

We want to have $\psi \colon E'(F_{p^2}) \rightarrow E(F_{p^{12}})$, such as

- $\forall a, b \in E'(F_{p^2}) \colon \psi(a + b) = \psi(a) + \psi(b)$
- $\forall a, b \in E'(F_{p^2}) \colon \psi(a) = \psi(b) \Rightarrow a = b$

It is called injective group homomorphism.

For BLS12-381 E’ is defined as[^51]:

$$
E'\colon y^2 = x^3 + 4(u + 1)
$$

In most cases we will work with points from $G_2' \subset E'(F_{p^2})$ and use for this subgroup just the notation $G_2$.

#### Generators

**Definition:** if in the group $G$ exists element g, such as $\textbraceleft g, 2g, 3g, \ldots, |G|g \textbraceright = G$, the group G called ***cyclic group*** and g called ***generator***



$G_1$ and $G_2$ are cyclic subgroups with the following generators[^15][^51]:

```rust
G1:
X = 0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb
Y = 0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1
```

For $(x', y') \in G_2 \subset E'(F_{p^2}):$
$$x' = x_0 + x_1u$$

$$y' = y_0 + y_1u$$

```rust
G2:
x0 = 0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8
x1 = 0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e
y0 = 0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801
y1 = 0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be
```

**Definition:** ***Cofactor*** is the ratio of the size of the whole group G to the size of subgroup H:

$$
|G|/|H|
$$

Cofactor $G_1\colon h = |E(F_p)|/r$[^51]

```rust
h = 0x396c8c005555e1568c00aaab0000aaab
```

Cofactor $G_2\colon h' = |E'(F_{p^2})|/r$[^51]

```rust
h' = 0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5
```

#### Pairing

Pairing is an operation, which we will need for digital signature verification. Pairing operation $e\colon G_1 \times G_2 \rightarrow G_T$, where $G_T \subset F_{p^{12}}$.

The main  pairing properties is:

- $e(P, Q + R) = e(P, Q) \cdot e(P, R)$
- $e(P  + S, R) = e(P, R)\cdot e(S, R)$

For calculating this function we will need the algorithm, called Miller Loop, and to effectively perform this algorithm we will need to know the key parameter for BLS curve $x$

```rust
x = -0xd201000000010000
```

You can find this parameter in:

- [^15] section specification, pairing parameters, miller loop scalar
- [^51] section 4.2.1 Parameter t
- [^14] section BLS12-381, parameter u
- [^11] section Curve equation and parameters, parameter x

#### Summary

The  parameters for the BLS12-381:

```rust
Base field modulus p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab
```

$$
E\colon y^2 \equiv x^3 + 4
$$

$$
E'\colon y^2 \equiv x^3 + 4(u + 1)
$$

```rust
Main subgroup order r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001
```

$$
F_{p^2} = F_p[u] / (u^2 + 1)
$$

$$
F_{p^6} = F_{p^2}[v] / (v^3 - u - 1)
$$

$$
F_{p^{12}} = F_{p^6}[w] / (w^2 - v)
$$

Generator for G1:

```rust
X = 0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb
Y = 0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1
```

Generator for G2:

```rust
x0 = 0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8
x1 = 0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e
y0 = 0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801
y1 = 0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be
```

Cofactor for G1:

```rust
h = 0x396c8c005555e1568c00aaab0000aaab
```

Cofactor for G2:

```rust
h' = 0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5
```

Key  BLS12-381 parameter used in Miller Loop:

```rust
x = -0xd201000000010000
```

All parameters were taken from[^15][^51] and [^14], all of them consistent between sources.

### Map to curve specification
In this section we explain how to map the element $a \in F_p$ to the $G_1 \subset E(F_p)$ and how to map $b \in F_{p^2}$ to the $G_2 \subset E'(F_{p^2})$. 
This section will explain how functions `bls12381_map_fp_to_g1` and `bls12381_map_fp2_to_g2` work. 
It mostly duplicates the correspondent section in EIP-2537[^49].

#### Mapping algorithm
The general elliptic curve equation is $y^2 = x^3 + A \cdot x + B$. In our case $A \cdot B = 0$, so the mapping algorithm
will consist of the following steps: 
1. Field element(from $F_p$ or $F_{p^2}$) will map to some curve with $A \cdot B \ne 0$
2. Points from this curve will map to the target curve($E(F_p)$ or $ E'(F_{p^2}) $) by isomorphism
3. For mapping points to subgroup($G_1$ or $G_2$) the cofactor will be cleared

First, we will describe the general algorithm and, next, we will provide the concrete parameters.

***Step 1: Map field element to the curve with AB != 0***
In this section we will describe `map_to_curve_simple_swu(u)` function. 
It is simplification of the Shallue-van de Woestijne-Ulas mapping described by Brier et al.[^56], which they call the “simplified SWU” map. 
Wahby and Boneh[^57] generalize and optimize this mapping.

A Weierstrass curve is $y^2 = g(x) = x^3 + A \cdot x + B$, where $A \ne 0$ and $B \ne 0$.

Constants, which we will define in the following sections:
* $A$, $B$ -- the parameters of Weierstress curve
* $Z$ the element of the field $F$ (in our case $F_p$ or $F_{p^2}$), which meeting the below criteria:
  * Z is non-square in F
  * $Z \ne -1$ in F
  * The polynomial $g(x) - Z$ is irreducible over F
  * $g(\frac{B}{Z \cdot A})$ is square in $F$.

For points $u$ and $-u$ we will get the same $x$-coordinate. We will define the $y$ sign the same as $u$ sign(see the definition of sign in sections "Compressed points on curve $E(F_p)$" and "Compressed points on curve $E'(F_{p^2})$)".

The case when $Z^2 \cdot u^4 + Z \cdot u^2 = 0$ should be handled separately. In that case set $x_1 = \frac{B}{X \cdot A}$,
which guarantees that $g(x_1)$ is square by the condition on Z given above.

The algorithm:
```
fn map_to_curve_simple_swu(u) {
    let tv1 = 1 / (Z^2 * u^4 + Z * u^2);
    let x1 = (-B / A) * (1 + tv1);
    if tv1 == 0 {
        x1 = B/(Z*A);
    }
    
    let gx1 = x1^3 + A*x1 + B;
    let x2 = Z * u^2 + x1;
    let gx2 = x2^3 + A*x2 + B;
    let (x, y) = if is_squere(gx1) {
        (x1, sqrt(gx1));
    } else {
        (x2, sqrt(gx2));
    }
    
    if sign(u) != sign(y) {
       y = -y;
    }
    
    return (x, y);
}

```

***Step 2: Map to target curve***

The function `iso_map(x_inner, y_inner)` map the points from isogenous curve E_inner with no-zero coefficients to our
target elliptic curve E. 

Wahby and Boneh[^57] show how to adopt the algorithm for case when elliptic curve have zero A or B. The idea: map
the F element to isogenous elliptic curve E_inner by the method from previous section, and then transform E_inner curve
to our target curve E by knowing isogeny. 

E_inner curve with isogeny will be defined in the "Parameters" section.

Note that `iso_map` is a group homomorphism. This mean `iso_map(p) + iso_map(q) = iso_map(p + q)`. So, the correspondent optimization can be applied.

If any denominator in rational functions used in `iso_map` function equal to zero, the `iso_map` function
must return identity point on E.

***Step 3: Map to subgroup(cofactor cleaning)***

In this section we will describe the function `clear_cofactor((x, y))`. This function transfer a point from $E(F_p)$ or $E'(F_{p^2})$ 
into a point in $G_1 \subset E(F_p)$ or $G_2 \subset E'(F_{p^2})$ respectively. 

To do that, we should multiply the point on the curve by effective cofactor `h_eff`. Multiplication on `h_eff` gives the
results in the same subset as multiplication on cofactor, but can be executed must faster. The value of `h_eff` will be given in
the following sections.

```
fn clear_cofactor(P) {
    h_eff * P
}

```

***Full algorithm***

In this section, the pseudocode for the full mapping algorithm is shown. All the functions are described in the sections above.

```
1. (x_inner, y_inner) = map_to_curve_simple_swu(u)    # (x_inner, y_inner) is on E_inner - the helper elliptic curve with AB != 0
2. (x, y) = iso_map(x_inner, y_inner)                 # (x, y) is on E
3. (x, y) = clear_cofactor((x, y))                    # clears cofactor for point (x, y) on E
4. return (x, y)
```

#### Parameters

***Fp-to-G1 mapping***

**Step 1:** E_inner: $y^2 = x^3 + A \cdot x + B$ parameters:
* A = 0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d
* B = 0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0
* Z = 11

**Step 2:** Isogeny from E_inner to curve $E(F_p)$:

Let's we have the point on E_inner with coordinates $(x_{inner}, y_{inner})$ and
we would like to calculate the correspondent coordinates $(x, y) \in E(F_p)$.  

* $x = \frac{x_{num}}{x_{den}}$ where
  
  * $$x_{num} = \sum_{i=0}^{11} k_{(1, i)} \cdot x_{inner}^i$$
  
  * $$x_{den} = x_{inner}^{10} + \sum_{i=0}^{9} k_{(2, i)} \cdot x_{inner}^i$$

* $y = y_{inner} \cdot \frac{y_{num}}{y_{den}}$:

  * $$y_{num} = \sum_{i=0}^{15} k_{(3, i)} \cdot x_{inner}^i$$
  
  * $$y_{den} = x_{inner}^{15} + \sum_{i=0}^{14} k_{(4, i)} \cdot x_{inner}^i$$

The constants to compute $x_{num}$:
```
k_(1,0) = 0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7
k_(1,1) = 0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb
k_(1,2) = 0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0
k_(1,3) = 0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861
k_(1,4) = 0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9
k_(1,5) = 0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983
k_(1,6) = 0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84
k_(1,7) = 0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e
k_(1,8) = 0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317
k_(1,9) = 0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e
k_(1,10) = 0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b
k_(1,11) = 0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229
```

The constants to compute $x_{den}$:
```
k_(2,0) = 0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c
k_(2,1) = 0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff
k_(2,2) = 0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19
k_(2,3) = 0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8
k_(2,4) = 0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e
k_(2,5) = 0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5
k_(2,6) = 0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a
k_(2,7) = 0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e
k_(2,8) = 0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641
k_(2,9) = 0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a
```

The constants used to compute $y_{num}$:
```
k_(3,0) = 0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33
k_(3,1) = 0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696
k_(3,2) = 0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6
k_(3,3) = 0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb
k_(3,4) = 0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb
k_(3,5) = 0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0
k_(3,6) = 0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2
k_(3,7) = 0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29
k_(3,8) = 0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587
k_(3,9) = 0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30
k_(3,10) = 0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132
k_(3,11) = 0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e
k_(3,12) = 0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8
k_(3,13) = 0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133
k_(3,14) = 0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b
k_(3,15) = 0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604
```

The constants to compute $y_{den}$:
```
k_(4,0) = 0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1
k_(4,1) = 0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d
k_(4,2) = 0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2
k_(4,3) = 0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416
k_(4,4) = 0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d
k_(4,5) = 0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac
k_(4,6) = 0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c
k_(4,7) = 0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9
k_(4,8) = 0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a
k_(4,9) = 0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55
k_(4,10) = 0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8
k_(4,11) = 0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092
k_(4,12) = 0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc
k_(4,13) = 0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7
k_(4,14) = 0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f
```

**Step 3:** Effective cofactor:
 * h_eff = 0xd201000000010001

***Fp2-to-G2 mapping***

**Step 1:** E_inner: $y^2 = x^3 + A \cdot x + B$ parameters:
* A = $240 \cdot I$
* B = $1012 \cdot (1 + I)$
* Z = $-(2 + I)$

Note: $I$ means a non-residue used to make an extension field $F_{p^2}$

**Step 2:** Isogeny from E_inner to curve $E'(F_{p^2})$:

Let's we have the point on E_inner with coordinates $(x_{inner}, y_{inner})$ and
we would like to calculate the correspondent coordinates $(x, y) \in E'(F_{p^2})$.

* $x = \frac{x_{num}}{x_{den}}$ where

  * $$x_{num} = \sum_{i = 0}^{3} k_{1, i} \cdot x_{inner}^i$$
  
  * $$x_{den} = x_{inner}^2 + \sum_{i=0}^{1} k_{2, i} \cdot x_{inner}^i$$

* $y = y_{inner} \cdot \frac{y_num}{y_den}$:
  
  * $$y_{num} = \sum_{i = 0}^{3} k_{3, i} \cdot x_{inner}^i$$
  
  * $$y_{den} = x_{inner}^{3} + \sum_{i = 0}^{2} k_{4, i} \cdot x_{inner}^i$$

The constants used to compute $x_{num}$ are as follows:
```
k_(1,0) = 0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6 + 0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6 * I
k_(1,1) = 0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a * I
k_(1,2) = 0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e + 0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d * I
k_(1,3) = 0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1
```

The constants used to compute $x_{den}$ are as follows:
```
k_(2,0) = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63 * I
k_(2,1) = 0xc + 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f * I
```

The constants used to compute $y_{num}$ are as follows:
```
k_(3,0) = 0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706 + 0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706 * I
k_(3,1) = 0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be * I
k_(3,2) = 0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c + 0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f * I
k_(3,3) = 0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10
```

The constants used to compute $y_{den}$ are as follows:
```
k_(4,0) = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb + 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb * I
k_(4,1) = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3 * I
k_(4,2) = 0x12 + 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99 * I
```

**Step 3:** Effective cofactor:
* h_eff = 0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551

### Curve points encoding

#### Bool as output

The bool is encoded as a little-endian `u64` type in Rust. The `true` value is encoded as `1` and `false` is encoded as `0`. All other values of `u64` are not allowed and should be interpreted as incorrect. Encoding is the same as for alt_bn128 implementation in nearcore[^50].

#### Sign

The sign of the point on the elliptic curve is encoded as `u8` type in Rust with two possible values: `0` and `1`. `0` for positive sign, and `1` for negative sign. All other value of `u8` is not allowed and should be interpreted as incorrect.

#### Scalar

The scalar value is encoded as a big-endian `[u8;32]`. All possible bytes combination is allowed. Encoding is similar with alt_bn128 implementation in nearcore[^50], but `big-endian` encoding is used instead of `little-endian` as in EIP-2537[^15].

#### Fields elements $F_p$

The value from $F_p$ is encoded as a big-endian `[u8; 48]`. Only values less than `p` are allowed. If the value is equal to or bigger than `p` the error should be returned.

The rule of encoding is consistent with zkcrypto[^53], with implementation in milagro lib[^29].

#### Extension fields elements $F_{p^2}$

The $q \in F_{p^{2}}$ could be written as $q = c_0 + c_1 v$, where $c_0, c_1 \in F_p$ The element from $F_{p^2}$ encoded in `[u8; 96]` as a bytes’ concatenation of $c_1$ and $c_0$. The $c_1$ and $c_0$ are encoded by the rule described in the previous section.

$q \in F_{p^2}$, $q = c_0 + c_1 v$ encoded as `[u8; 96]`:

- $c_1 \in F_p$ `[u8; 48]`
- $c_0 \in F_p$ `[u8; 48]`

The rule of encoding is consistent with zkcrypto[^53] and with implementation in milagro lib[^29].

#### Uncompressed points on curve $E(F_p)$

The points on the curve represent by affine coordinates: `(x: Fp, y: Fp)`. The elements from $E(F_p)$ encoded in `[u8; 96]` as bytes’ concatenation of `x` and `y` point coordinates, where $x, y \in F_p$. The $x, y$ are encoded according to the rules described in the section “Fields elements $F_p$” .

$E(F_p)$  is encoded as `[u8; 96]`:

- $x \in F_p$ `[u8; 48]`
- $y \in F_p$ `[u8; 48]`

*The second bit* is used to mark a point on infinity, if the second bit is set to 1 — it is an infinity point.

Encoding point on infinity:

```bash
let x: [u8; 96] = [0; 96];
x[0] = x[0] | 0x40;
```

The rule of encoding is consistent with zkcrypto[^53] and with implementation in milagro lib[^29].

#### Compressed points on curve $E(F_p)$

The points on the curve represent by affine coordinates: `(x: Fp, y: Fp)`. The elements from $E(F_p)$ in compressed form are encoded in `[u8; 48]` as *big-endian* encoded $x \in F_p$. The $y$  coordinate can be detected by the formula: $y = \pm \sqrt{x^3 + 4}$.

*The first bit* should be set as 1. This bit indicates that point is encoded in compressed form.

*The second bit* is used to mark a point on infinity, if the second bit is set to 1 — it is an infinity point.

To represent the sign of the $y$ *the third bit* of x encoding is used. If the first bit = 0 the $y$ is positive, if the first bit = 1 the $y$ is negative. We will consider the number positive the smallest between $y$  and $-y = p - y$.

The $x \in F_p$ encoded as `[u8; 48]` bytes according to the rules from section  “Extension fields elements $F_{p}$” .

The point on $E(F_p)$ with negative $y$ coordinate encoded as `[u8; 48]` bytes:

```rust
let x: [u8; 48] = encodeFp(x)
x[0] = x[0] | 0x80;
x[0] = x[0] | 0x20;
```

For encoding point of infinity:

```rust
let x: [u8; 48] = [0; 48];
x[0] = x[0] | 0x80;
x[0] = x[0] | 0x40;
```

The rule of encoding is consistent with zkcrypto[^53] and with implementation in milagro lib[^29].

#### Uncompressed points on twisted curve $E'(F_{p^2})$

The points on the curve represent by affine coordinates: `(x: Fp2, y: Fp2)`. The elements from $E'(F_{p^2})$ encoded in `[u8; 192]` as bytes’ concatenation of `x` and `y` point coordinates, where $x, y \in F_{p^2}$. The $x, y$ are encoded according to the rules described in the section “Extension fields elements $F_{p^2}$” .

$E'(F_{p^2})$  is encoded as `[u8; 192]`:

- $x \in F_{p^2}$ `[u8; 96]`:
  - $c_1 \in F_p$ `[u8; 48]`
  - $c_0 \in F_p$ `[u8; 48]`
- $y \in F_{p^2}$ `[u8; 96]`:
  - $c_1 \in F_p$ `[u8; 48]`
  - $c_0 \in F_p$ `[u8; 48]`

*The second bit* is used to mark a point on infinity, if the second bit is set to 1 — it is an infinity point.

Encoding point on infinity:

```bash
let x: [u8; 192] = [0; 192];
x[0] = x[0] | 0x40;
```

The rule of encoding is consistent with zkcrypto[^53] and with implementation in milagro lib[^29].

#### Compressed points on twisted curve $E'(F_{p2})$

The points on the curve represent by affine coordinates: `(x: Fp2, y: Fp2)`. The elements from $E'(F_{p^2})$ in compressed form are encoded in `[u8; 96]` as *big-endian* encoded $x \in F_{p^2}$. The $y$  coordinate can be detected by the formula: $y = \pm \sqrt{x^3 + 4}$.

*The first bit* should be set as 1. This bit indicates that point is encoded in compressed form.

*The second bit* is used to mark a point on infinity, if the second bit is set to 1 — it is an infinity point.

To represent the sign of the $y$ *the third bit* of x encoding is used. If the first bit = 0 the $y$ is positive, if the first bit = 1 the $y$ is negative. We will consider the number positive the smallest between $y$  and $-y$: first compare $c_1$ and second $c_0$.

The $x \in F_{p^2}$ encoded as `[u8; 96]` bytes according to the rules from section  “Extension fields elements $F_{p^2}$” .

The point on $E'(F_{p^2})$ with negative $y$ coordinate encoded as `[u8; 96]` bytes:

```rust
let x: [u8; 96] = encodeFp2(x);
x[0] = x[0] | 0x80;
x[0] = x[0] | 0x20;
```

Encoding point of infinity:

```rust
let x: [u8; 96] = [0; 96];
x[0] = x[0] | 0x80;
x[0] = x[0] | 0x40;
```

The rule of encoding is consistent with zkcrypto[^53] and with implementation in milagro lib[^29].

### Precompile functions

#### bls12381_g1_sum

***Description:***

The function computes the sum of the signed elements of the BLS12-381 curve. The input is an arbitrary number of pairs $(p_i, s_i)$, where $p_i \in E(F_p)$ is point on elliptic curve and $s_i \in \textbraceleft 0, 1 \textbraceright$ is the point sign. The output is one point from $E(F_p)$ equal to $\sum (-1)^{s_i}p_i$.

The $E(F_p)$ curve,  points on the curve, multiplication on -1,  and the addition operation are defined in the BLS12-381 Curve Specification section.

Note: we take as input any points on the curve, not only from   $G_1$

***Input:*** the sequence of pairs $(p_i, s_i)$, where $p_i \in E(F_p)$ is point and $s_i \in \textbraceleft 0, 1 \textbraceright$ is sign, each point encoded in decompress form as $(x\colon F_p, y\colon F_p)$ and sign encoded in one byte with only two allowed values: 0, 1. Expected `97*k` bytes as an input that is interpreted as byte concatenation of `k` slices, each slice is the uncompressed point from $E(F_p)$ and a bool value for point sign. More details are in the Curve Points Encoding section.

***Output:*** the output is 96 bytes — the one point $\in E(F_p)$ in decompressed form. For empty input it returns point on infinity(see  Curve Points Encoding section).

***Gas Estimation:***

The algorithm has a linear complexity of the number of elements. The gas can be calculated by the next formula

```rust
let k = (input_bytes + item_size - 1)/item_size
let gas_consumed = A + B * k
```

A and B are constants calculated empirically.

Here you can find benchmark test vectors for EIP-2537[^46]. It doesn’t contain a sum function, but we can adopt the test vector for addition by duplicating it many times.

***Test cases:***

- Correct points in G1 group
- One of the points is 0
- One of the points is not in G1 group but on the curve
- The result is 0
- Correct addition with one point
- Point not on the curve
- The coding of field elements is incorrect, but if take only the suffix it will be the correct point on the curve
- The coding of field elements is incorrect, but by modulo p it is a correct element on the curve
- The coding of field elements is incorrect, an incorrect extra bit, which shows that it is decompressed encoding.
- Sum with the maximum number of elements
- Too many points for sum
- Incorrect len of input
- Empty input
- Generate points on the curve and check that the result doesn’t depend on permutation
- Generate points and cross-test the result with multiexp function.
- Correct input with negative signs
- Incorrect sign value (not 0 or 1)
- Correct input with negative signs for points with $y > \frac{p}{2}$
- Sum of the two equal points with opposite sign

***Tests References:***

We can use all the tests for addition for Ethereum([^47], [^48]) to check the case with k = 2. Also, we can reuse the `error` points. Can use the vectors for multiexp functions if separately perform multiplication.

***Error cases:***

- The input length is not divided by 97
- Too much memory is used
- Field elements encoded incorrectly (see Curve points encoded section)
- Any points not on the curve
- The sign value is not 0 or 1

***Annotation:***

```rust
/// Computes sum for signed elements on BLS12-381 curve 
/// \sum_i (-1)^{s_i} p_i should be the equal result.
///
/// # Arguments
///
/// * `value` - sequence of (pi, si) where pi is point(x:Fp, y:Fp) on BLS-381 curve and si is sign (0 for +, and 1 for -)
///    BLS12-381 is Y^2 = X^3 + 4 curve over Fp.
///
///   `value` is encoded as packed, big-endian
///   `[([u8; 48], [u8; 48])]` slice.
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory or the registers
/// use more memory than the limit, the function returns `MemoryAccessViolation`.
///
/// If (1) point coordinates are not on curve or (2) `value.len()%97 != 0` or (3) value of sign is not 0 or 1
/// the function returns `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes +
/// bls12381_g1_sum_base + bls12381_g1_sum_element * num_elements`
pub fn bls12381_g1_sum(&mut self, 
                       value_len: u64, 
                       value_ptr: u64, 
                       register_id: u64) -> Result<()>;
```

#### bls12381_g2_sum

***Description:***

The function computes the sum of the signed elements of the BLS12-381 curve. The input is an arbitrary number of pairs $(p_i, s_i)$, where $p_i \in E'(F_{p^2})$ is point on elliptic curve and $s_i \in \textbraceleft 0, 1 \textbraceright$ is the point sign. The output is one point from $E'(F_{p^2})$ equal to $\sum (-1)^{s_i}p_i$.

The $E'(F_{p^2})$ curve,  points on the curve, multiplication on -1, and the addition operation are defined in the BLS12-381 Curve Specification section.

Note: we take as input any points on the curve, not only from $G_2$

***Input:*** the sequence of pairs $(p_i, s_i)$, where $p_i \in E'(F_{p^2})$ is point and $s_i \in \textbraceleft 0, 1 \textbraceright$ is sign, each point encoded in decompress form as $(x\colon F_{p^2}, y\colon F_{p^2})$ and sign encoded in one byte. Expected `193*k` bytes as an input that is interpreted as byte concatenation of `k` slices, each slice is the uncompressed point from $E'(F_{p^2})$ and the point sign. More details are in the Curve Points Encoding section.

***Output:*** the output is 192 bytes — the one point $\in E'(F_{p^2})$ in decompressed form. For empty input it returns point on infinity(see  Curve Points Encoding section).

***Gas Estimation:***

The algorithm has a linear complexity of the number of elements. The gas can be calculated by the next formula

```rust
let k = (input_bytes + item_size - 1)/item_size
let gas_consumed = A + B * k
```

A and B are constants calculated empirically.

Here you can find benchmark test vectors for EIP-2537[^46]. It doesn’t contain a sum function, but we can adopt the test vector for addition by duplicating it many times.

***Test cases:***

The same as for **`bls12381_g1_sum`** only change points from $G_1$ and $E(F_p)$ into $G_2$ and $E'(F_{p^2})$.

***Tests References:***

We can use all the tests for addition for Ethereum[^47][^48] to check the case with k = 2. Also, we can reuse the `error` points. Can use the vectors for multiexp functions if separately perform multiplication.

***Error cases:***

- The input length is not divided by 193
- Too much memory is used
- Extension field elements encoded incorrectly (see Curve points encoded section)
- Any points not on the curve
- The sign value is not 0 or 1

***Annotation:***

```rust
/// Computes sum for signed elements on BLS12-381 curve 
/// \sum_i (-1)^{s_i} p_i should be the equal result.
///
/// # Arguments
///
/// * `value` - sequence of (pi, si), where pi is point(x:Fp^2, y:Fp^2) on BLS-381 curve and si is sign (0 for +, 1 for -) 
///    BLS12-381 is Y^2 = X^3 + 4(i + 1) curve over Fp^2.
///
///   `value` is encoded as packed, big-endian
///   `[(([u8; 96], [u8; 96]), u8)]` slice.
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory or the registers
/// use more memory than the limit, the function returns `MemoryAccessViolation`.
///
/// If (1) point coordinates are not on curve or (2) `value.len()%193 != 0` or (3) sign is not 0 or 1,
/// the function returns `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes +
/// bls12381_g2_sum_base + bls12381_g2_sum_element * num_elements`
pub fn bls12381_g2_sum(&mut self, 
                       value_len: u64, 
                       value_ptr: u64, 
                       register_id: u64) -> Result<()>;
```

#### ***bls12381_g1_multiexp***

***Description:***

The function takes as input the list of pairs $(p_i, s_i)$, where $p_i \in E(F_p)$ is a point on the curve and $s_i \in \mathbb{N}_0$ is a scalar. The function calculates $\sum s_i \cdot p_i$.

The multiplication on the scalar is the addition of that point a scalar number of times:

$$
s \cdot p = \underbrace{p + p + \ldots + p}_{s}
$$

The $E(F_p)$ curve,  points on the curve and the addition operation are defined in the BLS12-381 Curve Specification section.

Note:

- We take as input any points on the curve, not only from   $G_1$.
- The scalar is an arbitrary unsigned integer and can be bigger than the group order.

***Input:*** the sequence of pairs $(p_i, s_i)$, where $p_i \in E(F_p)$ is a point on the curve and $s_i \in \mathbb{N}_0$ is a scalar. Each point is encoded in decompress form as $(x\colon F_p, y\colon F_p)$ and a scalar has a type `u256` and BigEndian encoded in 32 bytes. Expected `128*k` bytes as an input that is interpreted as byte concatenation of `k` slices, each slice is the concatenation of uncompressed point from $E(F_p)$ — `96` bytes and scalar — `32` bytes. More details are in the Curve Points Encoding section.

***Output:*** the output is 96 bytes — the one point $\in E(F_p)$ in decompressed form. For empty input it returns point on infinity(see  Curve Points Encoding section).

***Gas Estimation:***

This function should be calculated by Pippenger’s algorithm[^25]. The Complexity of this algorithm is $O(\frac{k}{\log(k)})$. For gas calculation we will use the formula $\frac{k}{\max(\log_2(k), 1)}$ the same way as in precompile for `alt_bn128`[^10].

```rust
let k = (input_bytes+item_size-1)/item_size;
let gas_consumed = A + B*k + C * if k > 1 {k / (k as f32).log2().floor()} else {k};
```

A, B and C are constants calculated empirically.

For gas estimation, we can use the benchmark vectors for addition and multiplication for EIP-2537[^46].

***Test cases:***

The same test cases as for the bls12381_g1_sum section.

Addition test cases:

- `group_order * P = 0`
- `(scalar + groupt_order) * P = scalar * P`
- `P + P + P .. + P = N*P`
- `0 * P = 0`
- `1 * P = P`
- Scalar is a MAX_INT

***Tests References:***

The EIP-2537 contains the same function, so we can reuse test vectors from Ethereum[^47][^48].

***Error cases:***

- The input length is not divided by 128
- Too much memory is used
- Field elements encoded incorrectly (see Curve points encoded section)
- Any points not on the curve

***Annotation:***

```rust
/// Computes multiexp on BLS12-381 curve using Pippenger's algorithm 
///\sum_i si*pi should be equal result.
///
/// # Arguments
///
/// * `value` - sequence of (pi, si), where
///    pi is point (x:Fp, y:Fp) on BLS12-381, and si is u256.
///    BLS12-381 is Y^2 = X^3 + 4 curve over Fp.
///
///   `value` is encoded as packed, big-endian
///   `[(([u8; 48], [u8; 48]), u256)]` slice.
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory or the registers
/// use more memory than the limit, the function returns
/// `MemoryAccessViolation`.
///
/// If point coordinates are not on curve, point is not in the subgroup,
/// scalar is not in the field or  `value.len()%128!=0`, the function returns
/// `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes +
///  bls12381_g1_multiexp_base +
///  bls12381_g1_multiexp_element * num_elements + 
///  bls12381_g1_multiexp_element_div_log * num_elements/max(1, log(num_elements))`
pub fn bls12381_g1_multiexp(
        &mut self,
        value_len: u64,
        value_ptr: u64,
        register_id: u64,
) -> Result<()>;
```

#### ***bls12381_g2_multiexp***

***Description:***

The function takes as input the list of pairs $(p_i, s_i)$, where $p_i \in E'(F_{p^2})$ is a point on the curve and $s_i \in \mathbb{N}_0$ is a scalar. The function calculates $\sum s_i \cdot p_i$.

The multiplication on the scalar is the addition of that point a scalar number of times:

$$
s \cdot p = \underbrace{p + p + \ldots + p}_{s}
$$

The $E'(F_{p^2})$ curve,  points on the curve and the addition operation are defined in the BLS12-381 Curve Specification section.

Note:

- We take as input any points on the curve, not only from   $G_2$.
- The scalar is an arbitrary unsigned integer and can be bigger than the group order.

***Input:*** the sequence of pairs $(p_i, s_i)$, where $p_i \in E'(F_{p^2})$ is a point on the curve and $s_i \in \mathbb{N}_0$ is a scalar. 

Each point is encoded in decompress form as $(x\colon F_{p^2}, y\colon F_{p^2})$ and a scalar has a type `u256` and BigEndian encoded in 32 bytes. Expected `224*k` bytes as an input that is interpreted as byte concatenation of `k` slices, each slice is the concatenation of uncompressed point from $E'(F_{p^2})$ — `192` bytes and scalar — `32` bytes. More details are in the Curve Points Encoding section.

***Output:*** the output is 192 bytes — the one point $\in E'(F_{p^2})$ in decompressed form. For empty input it returns point on infinity(see  Curve Points Encoding section).

***Gas Estimation:***

This function should be calculated by Pippenger’s algorithm[^25]. The Complexity of this algorithm is $O(\frac{k}{\log(k)})$. For gas calculation we will use the formula $\frac{k}{\max(\log_2(k), 1)}$ the same way as in precompile for `alt_bn128`[^10].

```rust
let k = (input_bytes+item_size-1)/item_size;
let gas_consumed = A + B*k + C * if k > 1 {k / (k as f32).log2().floor()} else {k};
```

A, B and C are constants calculated empirically.

For gas estimation, we can use the benchmark vectors for addition and multiplication for EIP-2537[^46].

***Test cases:***

The same as for **`bls12381_g1_multiexp`** only change points from $G_1$ and $E(F_p)$ into $G_2$ and $E'(F_{p^2})$.

***Tests References:***

The EIP-2537 contains the same function, so we can reuse test vectors from Ethereum[^47][^48].

***Error cases:***

- The input length is not divided by 224
- Too much memory is used
- Field elements encoded incorrectly (see Curve points encoded section)
- Any points not on the curve

***Annotation:***

```rust
/// Computes multiexp on BLS12-381 curve using Pippenger's algorithm 
///\sum_i si*pi should be equal result.
///
/// # Arguments
///
/// * `value` - sequence of (pi, si), where
///    pi is point (x:Fp^2, y:Fp^2) on BLS12-381, and si is u256.
///    BLS12-381 is Y^2 = X^3 + 4(i + 1) curve over Fp^2.
///
///   `value` is encoded as packed, big-endian
///   `[(([u8; 96], [u8; 96]), u256)]` slice.
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory or the registers
/// use more memory than the limit, the function returns
/// `MemoryAccessViolation`.
///
/// If point coordinates are not on curve, point is not in the subgroup,
/// scalar is not in the field or  `value.len()%224!=0`, the function returns
/// `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes +
///  bls12381_g2_multiexp_base +
///  bls12381_g2_multiexp_element * num_elements + 
///  bls12381_g2_multiexp_element_div_log * num_elements/max(1, log(num_elements))`
pub fn bls12381_g2_multiexp(
        &mut self,
        value_len: u64,
        value_ptr: u64,
        register_id: u64,
) -> Result<()>;
```

#### bls12381_map_fp_to_g1

***Description:***

The function takes the element $a \in F_p$ and maps it to the $G_1 \subset E(F_p)$. The specification of the mapping function you can find in the section "Map to curve specification". This function does NOT perform mapping of the byte string into $F_p$, it can be implemented in different ways and this can be performed effectively in contract.

***Input:*** the function takes as input `48` bytes — the element from $F_p$ (one unsigned integer $< p$). More details are in the Curve Points Encoding section.

***Output:*** the output is `96 bytes` — one point $\in G_1 \subset E(F_p)$ in decompressed format. More details are in the Curve Points Encoding section.

***Gas Estimation:***

The gas consumption is a constant calculated empirically.

***Test cases:***

- Correct $F_p$ element
- $a = 0$
- $a \ge p$
- Edge cases for inner algorithms for mapping[^49]

***Tests References:*** The EIP-2537 contains the same function, so we can reuse test vectors from Ethereum[^47][^48].

***Error cases:***

- Incorrect input length
- $a \ge p$

***Annotation:***

```rust
/// Map elements from Fp to G1 subset of BLS12-381 curve
///
/// # Arguments
///
/// * `value` - 48 bytes, the element from Fp -- unsigned integer < p 
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory or the registers
/// use more memory than the limit, the function returns
/// `MemoryAccessViolation`.
///
/// If value_len != 48 or the value >= p the function return `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes +
///  bls12381_map_fp_to_g1_base`
pub fn bls12381_map_fp_to_g1(
        &mut self,
        value_len: u64,
        value_ptr: u64,
        register_id: u64,
) -> Result<()>;
```

#### bls12381_map_fp2_to_g2

***Description:***

The function takes the element $a \in F_{p^2}$ and maps it to the $G_2 \subset E'(F_{p^2})$. The specification of the mapping function you can find in the section "Map to curve specification". This function does NOT perform mapping of the byte string into $F_{p^2}$, it can be implemented in different ways and this can be performed effectively in the contract.

***Input:*** the function takes as input `96 bytes` — the element from $F_{p^2}$ (two unsigned integers $< p$). More details are in the Curve Points Encoding section.

***Output:*** the output is `192 bytes` — one point $\in G_2 \subset E'(F_{p^2})$ in decompressed format. More details are in the Curve Points Encoding section.

***Gas Estimation:***

The gas consumption is a constant calculated empirically.

***Test cases:***

- Correct $F_{p^2}$ element
- $a = 0$
- One of the `a` value $\ge p$
- Edge cases for inner algorithms for mapping[^49]

***Tests References:*** The EIP-2537 contains the same function, so we can reuse test vectors from Ethereum[^47][^48].

***Error cases:***

- Incorrect input length
- Value is not a valid extension field $F_{p^2}$ element

***Annotation:***

```rust
/// Map elements from Fp2 to G2 subset of E'(Fp2) BLS12-381 curve
///
/// # Arguments
///
/// * `value` - 96 bytes, the element from Fp2 -- two unsigned integer < p 
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory or the registers
/// use more memory than the limit, the function returns
/// `MemoryAccessViolation`.
///
/// If value_len != 96 or the value is not correct Fp2 element the function return `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes +
///  bls12381_map_fp2_to_g2_base`
pub fn bls12381_map_fp2_to_g2(
        &mut self,
        value_len: u64,
        value_ptr: u64,
        register_id: u64,
) -> Result<()>;
```

#### bls12381_pairing_check

***Description:***

The pairing function $e\colon G_1 \times G_2 \rightarrow G_T$, where $G_T \subset F_{q^{12}}$. The pairing function has the following properties:

- $e(P, Q + R) = e(P, Q) \cdot e(P, R)$
- $e(P + S, R) = e(P, R)\cdot e(S, R)$

The consequence:

$e([a]P, [b]Q) = e(P, Q)^{ab} = e([b]P, [a]Q)$

We need this function to verify BLS signature.

This function takes as input the sequence of pairs $(p_i, q_i)$, where $p_i \in G_1 \subset E(F_{p})$ and $q_i \in G_2 \subset E'(F_{p^2})$ and check:

$$
\prod e(p_i, q_i) = 1
$$

We don’t calculate the pairing function itself: the result will be in the huge field, and in all known applications only such a check is necessary.

***Input:*** the sequence of pairs $(p_i, q_i)$, where $p_i \in G_1 \subset E(F_{p})$ and $q_i \in G_2 \subset E'(F_{p^2})$. Each point is encoded in decompressed form. Expected `288*k` bytes as an input that is interpreted as byte concatenation of `k` slices, each slice is the concatenation of uncompressed point from $G_1 \subset E(F_p)$ — `96 bytes` and point from $G_2 \subset E'(F_{p^2})$ — `192 bytes`. More details are in the Curve Points Encoding section.

***Output:*** returns `bool` — the result of the pairing check. The `true` value means that the pairing result is equal to multiplicative identity and `false` otherwise. For empty input it returns `true`.

***Gas Estimation:***

The algorithm has a linear complexity of the number of elements. The gas can be calculated by the next formula

```rust
let k = (input_bytes + item_size - 1)/item_size
let gas_consumed = A + B * k
```

A and B are constants calculated empirically.

Here you can find benchmark test vectors for EIP-2537[^46].

***Test cases:***

- The correct input with different lengths with results true
- The correct input with different lengths with results false
- The first point on the curve but not in G1
- The second point on the curve but not in G2
- The input with incorrect length
- The points not on the curve
- Some points = 0
- The field elements are encoded incorrectly
- Empty input

***Tests References:*** The EIP-2537 contains the same function, so we can reuse test vectors from Ethereum[^47][^48].

***Error cases:***

- The input length is not divided by 288
- Too much memory is used
- Field elements encoded incorrectly (see Curve points encoded section)
- Any points not on the curve
- Any points not in $G_1/G_2$

***Annotation:***

```rust
/// Computes pairing check on BLS12-381 curve.
/// \prod_i e(g_{1 i}, g_{2 i}) should be equal one, e(g1, g2) is pairing
///
/// # Arguments
///
/// * `value` - sequence of (g1:G1, g2:G2), where
///   G2 is subgroup point (x:Fp2, y:Fp2) on BLS12-381 twist,
///   BLS12-381 twist is Y^2 = X^3 + 4(i + 1) curve over Fp2
///   Fp2 is complex field element (re: Fp, im: Fp)
///   G1 is point (x:Fp, y:Fp) on BLS12-381,
///   BLS12-381 is Y^2 = X^3 + 4 curve over Fp
///
///   `value` is encoded a as packed, big-endian
///   `[(([u8; 48], [u8; 48]), ([u8; 96], [u8; 96]))]` slice.
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory than
/// the function returns `MemoryAccessViolation`.
///
/// If point coordinates are not on curve, point is not in the subgroup
// or data are wrong serialized, for example,
/// `value.len()%288!=0`, the function returns `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes + 
/// bls12381_pairing_base + bls12381_pairing_element * num_elements`
pub fn bls12381_pairing_check(&mut self, value_len: u64, value_ptr: u64) -> Result<u64> {
```

#### bls12381_decompress_g1

***Description:***  Function decompress compressed points from $E(F_p)$. The input is an arbitrary number of points $p_i \in E(F_p)$ in compressed format, and the output is the same number of points from $E(F_p)$ in decompressed format. More about the decompressed and compressed formats you can read in the Curve Points Encoding section.



***Input:***  the sequence of point $p_i \in E(F_p)$, each point encoded in compressed form. Expected `48*k` bytes as an input that is interpreted as byte concatenation of `k` slices, each slice is the compressed point from $E(F_p)$. More details are in the Curve Points Encoding section.

***Output:*** the sequence of point $p_i \in E(F_p)$, each point encoded in decompressed form. Expected `96*k` bytes as an output that is interpreted as byte concatenation of `k` slices, each slice is the decompressed point from $E(F_p)$. `k` the same as in input. More details are in the Curve Points Encoding section.

***Gas Estimation:*** The algorithm has a linear complexity of the number of elements. The gas can be calculated by the next formula

```rust
let k = (input_bytes + item_size - 1)/item_size
let gas_consumed = A + B * k
```

A and B are constants calculated empirically.

***Test cases:***

- the correct input with different length
- the input with incorrect size
- the points with the negative `y` coordinate
- 0 points
- points not on the curve
- incorrectly encoded points
- very long input

***Tests References:***

- Take the correct points on the curve from Ethereum tests[^47][^48] and check the correctness after decompression
- Randomly generate compressed points and check the equation correctness after decompression.

***Error cases:***

- The input length is not divided by 48
- Too much memory is used
- Field elements encoded incorrectly (see Curve points encoded section)
- Any points not on the curve

***Annotation:***

```rust
/// Decompress points on BLS12-381 curve.
///
/// # Arguments
///
/// * `value` - sequence of pi points (x:Fp) on BLS-381 curve
///    BLS12-381 is Y^2 = X^3 + 4 curve over Fp.
///
///   `value` is encoded as packed `[[u8; 48]]` slice.
///
/// # Output
/// sequence of pi points (x: Fp; y: Fp) in decompress format: [([u8; 48], [u8; 48])]
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory or the registers
/// use more memory than the limit, the function returns `MemoryAccessViolation`.
///
/// If point coordinates are not on curve or `value.len()%48 != 0`,
/// the function returns `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes +
/// bls12381_g1_decompress_base + bls12381_g1_decompress_element * num_elements`
pub fn bls12381_decompress_g1(&mut self, 
                              value_len: u64, 
                              value_ptr: u64, 
                              register_id: u64) -> Result<()>;
```

#### bls12381_decompress_g2

***Description:***  Function decompress compressed points from $E'(F_{p^2})$. The input is an arbitrary number of points $p_i \in E'(F_{p^2})$ in compressed format, and the output is the same number of points from $E'(F_{p^2})$ in decompressed format. More about the decompressed and compressed formats you can read in the Curve Points Encoding section.



***Input:***  the sequence of point $p_i \in E'(F_{p^2})$, each point encoded in compressed form. Expected `96*k` bytes as an input that is interpreted as byte concatenation of `k` slices, each slice is the compressed point from $E'(F_{p^2})$. More details are in the Curve Points Encoding section.

***Output:*** the sequence of point $p_i \in E'(F_{p^2})$, each point encoded in decompressed form. Expected `192*k` bytes as an output that is interpreted as byte concatenation of `k` slices, each slice is the decompressed point from $E'(F_{p^2})$. `k` the same as in input. More details are in the Curve Points Encoding section.

***Gas Estimation:*** The algorithm has a linear complexity of the number of elements. The gas can be calculated by the next formula

```rust
let k = (input_bytes + item_size - 1)/item_size
let gas_consumed = A + B * k
```

A and B are constants calculated empirically.

***Test cases:***

- the correct input with different length
- the input with incorrect size
- the points with the negative `y` coordinate
- 0 points
- points not on the curve
- incorrectly encoded points
- very long input

***Tests References:***

- Take the correct points on the curve from Ethereum tests[^47][^48] and check the correctness after decompression
- Randomly generate compressed points and check the equation correctness after decompression.

***Error cases:***

- The input length is not divided by 96
- Too much memory is used
- Field elements encoded incorrectly (see Curve points encoded section)
- Any points not on the curve

***Annotation:***

```rust
/// Decompress points on twisted BLS12-381 curve.
///
/// # Arguments
///
/// * `value` - sequence of pi points (x:Fp2) on twisted BLS-381 curve
///    BLS12-381 is Y^2 = X^3 + (4 + i) curve over Fp2.
///
///   `value` is encoded as packed `[[u8; 96]]` slice.
///
/// # Output
/// sequence of pi points (x: Fp2; y: Fp2) in decompress format: [([u8; 96], [u8; 96])]
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory or the registers
/// use more memory than the limit, the function returns `MemoryAccessViolation`.
///
/// If point coordinates are not on curve or `value.len()%96 != 0`,
/// the function returns `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes +
/// bls12381_g2_decompress_base + bls12381_g2_decompress_element * num_elements`
pub fn bls12381_decompress_g2(&mut self, 
                              value_len: u64, 
                              value_ptr: u64, 
                              register_id: u64) -> Result<()>;
```

## Reference Implementation

First of all, for integration with nearcore, we are interested in libraries in the Rust language. The existing BLS12-381 implementations on Rust:

1. ***Milagro Library*** [^29].
2. ***BLST***  [^30][^31].
3. ***Matter labs EIP-1962 implementation*** [^32]
4. ***zCash origin implementation*** [^33]
5. ***MCL Library*** [^34]
6. ***FileCoin implementation*** [^35]
7. ***zkCrypto*** [^36]

To compile the list, we used the links from EIP-2537[^43], pairing-curves specification[^44], and an article with benchmarks[^45]. This list may be incomplete but should cover the core BLS12-381 implementations. In any case, to implement precompiles from that NEP we will need to modify any of that libraries.

In addition, there are implementations in other languages that are not so interesting to us in this context, but can be used as references:

1. C++, ETH2.0 Client, ***Chia library***[^37]
2. Haskell, ***Adjoint Lib***[^38]
3. Go, ***Go-Ethereum***[^39]
4. JavaScript, ***Noble JS***[^40]
5. Go, ***Matter Labs Go EIP-1962 implementation***[^41]
6. C++, ***Matter Labs Go EIP-1962 implementation***[^42]

The draft implementation to nearcore you can find by this link[^54]. This implementation is based on blst library[^30]. This library one of the fastest[^45] and audited[^55].

## Security Implications

The implementation security relies on the security of the chosen library, which supports operations with BLS curves.

In this NEP, we do not require a constant execution time for all operations. This is not a problem if you use precompiles to verify the BLS signature. These precompiles should not be used if you need a constant-time algorithm.

The BLS12-381 has more security bits than the already existing pairing-friendly curve BN254, as a result, the security of the projects which need the pairing-friendly curve will improve.

## Alternatives

In the nearcore the precompiles for another pairing-friendly curve alt-bn128 are already implemented[^10]. For some projects[^20] the alternative is just to use the supported curve. However, according to recent research, this curve contains less than 100 bits of security and is not recommended to use[^13]. Moreover, projects with cross-chain interactions, such as Rainbow Bridge, must use the same curve as in a target protocol, and for Eth2.0 it is BLS12-381[^3]. As a result, there is no alternative to using another pairing-friendly curve.

Another alternative is to create one simple precompile in nearcore for BLS-signature verification. It was the first suggested solution[^26]. However, this solution is not flexible enough[^28]: (1) projects can use different hash functions; (2) some projects can use for public keys G1 subgroup, another G2; (3) the specification for Eth2.0 continue to be in the draft and details can change, (4) in such implementation we can't support precompiles from EIP-2537.

The next alternative is to execute BLS12-381 operations off-chain. In that case, the applications which used the BLS curve will not be trustless anymore.

## Future possibilities

In the future, it is possible to support work with other curves, not only BLS12-381. In Ethereum, before EIP-2537[^15], EIP-1962 was proposed[^27]. In EIP-1962 was proposed to implement pairing-friendly elliptic curves in a generic format and support not only BLS curves but many others. However, this proposal wasn't accepted due to its large scope and complexity. I don't think it makes sense to implement every possible curve, but it could be a possible extension.

## Consequences

### Positive

- Projects, which used BN254 will be able to switch on BLS12-381 curve, and it will improve security.
- The trustless cross-chain interactions with blockchains that use BLS12-381 in protocols(such as Ethereum 2) will become possible.

### Neutral

### Negative

- The appearance of dependence on the library which supports BLS12-381 curves operations.

### Backward Compatibility

There are no backward compatibility questions.

## Changelog

The previous NEP for supporting BLS signature based on BLS12-381[^26]

[^1]: BLS 2002 [https://www.researchgate.net/publication/2894224_Constructing_Elliptic_Curves_with_Prescribed_Embedding_Degrees](https://www.researchgate.net/publication/2894224_Constructing_Elliptic_Curves_with_Prescribed_Embedding_Degrees)
[^2]: ZCash protocol: [https://zips.z.cash/protocol/protocol.pdf](https://zips.z.cash/protocol/protocol.pdf)
[^3]: Ethereum 2 specification: [https://github.com/ethereum/consensus-specs/blob/master/specs/phase0/beacon-chain.md](https://github.com/ethereum/consensus-specs/blob/master/specs/phase0/beacon-chain.md)
[^4]: Dfinity: [https://internetcomputer.org/docs/current/references/ic-interface-spec#certificate](https://internetcomputer.org/docs/current/references/ic-interface-spec#certificate)
[^5]: Tezos: [https://wiki.tezosagora.org/learn/futuredevelopments/layer2#zkchannels](https://wiki.tezosagora.org/learn/futuredevelopments/layer2#zkchannels)
[^6]: Filecoin: [https://spec.filecoin.io/](https://spec.filecoin.io/)
[^7]: Specification of pairing friendly curves with a list of applications in the table: [https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#name-adoption-status-of-pairing-](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#name-adoption-status-of-pairing-)
[^8]: Specification of pairing friendly curves, the security level for BLS12-381: [https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#section-4.2.1](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#section-4.2.1)
[^9]: BN2005: [https://eprint.iacr.org/2005/133](https://eprint.iacr.org/2005/133)
[^10]: NEP-98 for BN254 precompile on NEAR: [https://github.com/near/NEPs/issues/98](https://github.com/near/NEPs/issues/98)
[^11]: BLS12-381 for the Rest of Us: [https://hackmd.io/@benjaminion/bls12-381](https://hackmd.io/@benjaminion/bls12-381)
[^12]: BN254 for the Rest of Us: [https://hackmd.io/@jpw/bn254](https://hackmd.io/@jpw/bn254)
[^13]: Some analytics of different curve security: [https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-02.html#name-for-100-bits-of-security](https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-02.html#name-for-100-bits-of-security)
[^14]: ZCash Transfer from bn254 to bls12-381: [https://electriccoin.co/blog/new-snark-curve/](https://electriccoin.co/blog/new-snark-curve/)
[^15]: EIP-2537 Precompiles for Ethereum for BLS12-381: [https://eips.ethereum.org/EIPS/eip-2537](https://eips.ethereum.org/EIPS/eip-2537)
[^16]: The article, where Tezos announce the support of BLS12-381 [https://medium.com/metastatedev/meanwhile-at-cryptium-labs-2-part-2-adding-the-pairing-equipped-elliptic-curve-bls12-381-to-tezos-cfce907e4be3](https://medium.com/metastatedev/meanwhile-at-cryptium-labs-2-part-2-adding-the-pairing-equipped-elliptic-curve-bls12-381-to-tezos-cfce907e4be3)
[^17]: Article about Rainbow Bridge [https://near.org/blog/eth-near-rainbow-bridge](https://near.org/blog/eth-near-rainbow-bridge)
[^18]: EIP-196. Precompiles for BN254: [https://eips.ethereum.org/EIPS/eip-196](https://eips.ethereum.org/EIPS/eip-196)
[^19]: Intro into zkSNARKs: [https://media.consensys.net/introduction-to-zksnarks-with-examples-3283b554fc3b](https://media.consensys.net/introduction-to-zksnarks-with-examples-3283b554fc3b)
[^20]: Zeropool project: [https://zeropool.network/](https://zeropool.network/)
[^21]: Motivation for EIP-2537: [https://www.youtube.com/watch?v=al4YpfDVmS4&ab_channel=EthereumCatHerders](https://www.youtube.com/watch?v=al4YpfDVmS4&ab_channel=EthereumCatHerders)
[^22]: NEAR blog post about Roll Ups: [https://near.org/blog/layer-2](https://near.org/blog/layer-2)
[^23]: Ledger post about Roll Ups: [https://www.ledger.com/academy/what-are-blockchain-rollups](https://www.ledger.com/academy/what-are-blockchain-rollups)
[^24]: Precompiles on Aurora: [https://doc.aurora.dev/evm/precompiles/](https://doc.aurora.dev/evm/precompiles/)
[^25]: Pippenger Algorithm: [https://github.com/wborgeaud/python-pippenger/blob/master/pippenger.pdf](https://github.com/wborgeaud/python-pippenger/blob/master/pippenger.pdf)
[^26]: NEP-446 proposal for BLS-signature verification precompile: [https://github.com/nearprotocol/neps/pull/446](https://github.com/nearprotocol/neps/pull/446)
[^27]: EIP-1962 EC arithmetic and pairings with runtime definitions: [https://eips.ethereum.org/EIPS/eip-1962](https://eips.ethereum.org/EIPS/eip-1962)
[^28]: Drawbacks of NEP-446: [https://github.com/near/NEPs/pull/446#pullrequestreview-1314601508](https://github.com/near/NEPs/pull/446#pullrequestreview-1314601508)
[^29]: BLS12-381 Milagro: [https://github.com/sigp/incubator-milagro-crypto-rust/tree/057d238936c0cbbe3a59dfae6f2405db1090f474](https://github.com/sigp/incubator-milagro-crypto-rust/tree/057d238936c0cbbe3a59dfae6f2405db1090f474)
[^30]: BLST: [https://github.com/supranational/blst](https://github.com/supranational/blst),
[^31]: BLST EIP-2537 adaptation: [https://github.com/sean-sn/blst_eip2537](https://github.com/sean-sn/blst_eip2537)
[^32]: EIP-1962 implementation matter labs Rust: https://github.com/matter-labs/eip1962
[^33]: zCash origin rust implementation: [https://github.com/zcash/zcash/tree/master/src/rust/src](https://github.com/zcash/zcash/tree/master/src/rust/src)
[^34]: MCL library: [https://github.com/herumi/bls](https://github.com/herumi/bls)
[^35]: filecoin/bls-signature: [https://github.com/filecoin-project/bls-signatures](https://github.com/filecoin-project/bls-signatures)
[^36]: zkCrypto: [https://github.com/zkcrypto/bls12_381](https://github.com/zkcrypto/bls12_381), [https://github.com/zkcrypto/pairing](https://github.com/zkcrypto/pairing)
[^37]: BLS12-381 code bases for ETH2.0 client Chia library C++: [https://github.com/Chia-Network/bls-signatures](https://github.com/Chia-Network/bls-signatures)
[^38]: Adjoint Lib: [https://github.com/sdiehl/pairing](https://github.com/sdiehl/pairing)
[^39]: Ethereum Go implementation for EIP-2537: [https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles](https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles)
[^40]: Noble JS implementation: [https://github.com/paulmillr/noble-bls12-381](https://github.com/paulmillr/noble-bls12-381)
[^41]: EIP-1962 implementation matter labs Go: https://github.com/kilic/eip2537,
[^42]: EIP-1962 implementation matter labs C++: https://github.com/matter-labs-archive/eip1962_cpp
[^43]: EIP-2537 with links: [https://github.com/matter-labs-forks/EIPs/blob/bls12_381/EIPS/eip-2537.md](https://github.com/matter-labs-forks/EIPs/blob/bls12_381/EIPS/eip-2537.md)
[^44]: Pairing-friendly curves specification, crypto libs: [https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#name-cryptographic-libraries](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#name-cryptographic-libraries)
[^45]: Comparing different libs for pairing-friendly curves: [https://hackmd.io/@gnark/eccbench](https://hackmd.io/@gnark/eccbench)
[^46]: Bench vectors from EIP2537: [https://eips.ethereum.org/assets/eip-2537/bench_vectors](https://eips.ethereum.org/assets/eip-2537/bench_vectors)
[^47]: Metter Labs tests for EIP2537: [https://github.com/matter-labs/eip1962/tree/master/src/test/test_vectors/eip2537](https://github.com/matter-labs/eip1962/tree/master/src/test/test_vectors/eip2537)
[^48]: Tests from Go Ethereum implementation: [https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles](https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles)
[^49]: EIP-2537 Map To Curve specification: [https://eips.ethereum.org/assets/eip-2537/field_to_curve](https://eips.ethereum.org/assets/eip-2537/field_to_curve)
[^50]: The current implementation of BN254: [https://github.com/near/nearcore/blob/master/runtime/near-vm-runner/src/logic/logic.rs](https://github.com/near/nearcore/blob/master/runtime/near-vm-runner/src/logic/logic.rs)
[^51]: draft-irtf-cfrg-pairing-friendly-curves-11 [https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11#name-bls-curves-for-the-128-bit-](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11#name-bls-curves-for-the-128-bit-)  *(*[https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/bls.md](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/bls.md) → [https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04) → this ref*)*
[^52]: Paper with BLS12-381: [https://eprint.iacr.org/2019/403.pdf](https://eprint.iacr.org/2019/403.pdf)
[^53]: Zkcrypto points encoding: [https://github.com/zkcrypto/pairing/blob/0.14.0/src/bls12_381/README.md](https://github.com/zkcrypto/pairing/blob/0.14.0/src/bls12_381/README.md)
[^54]: Draft PR for BLS12-381 operations in nearcore: https://github.com/near/nearcore/pull/9317
[^55]: Audit for BLST library: [https://research.nccgroup.com/wp-content/uploads/2021/01/NCC_Group_EthereumFoundation_ETHF002_Report_2021-01-20_v1.0.pdf](https://research.nccgroup.com/wp-content/uploads/2021/01/NCC_Group_EthereumFoundation_ETHF002_Report_2021-01-20_v1.0.pdf)
[^56]: Eric Brier, Jean-Sébastien Coron, Thomas Icart, David Madore, Hugues Randriam, and Mehdi Tibouchi. Efficient indifferentiable hashing into ordinary
elliptic curves. In Tal Rabin, editor, CRYPTO 2010, volume 6223 of LNCS,
pages 237–254. Springer, Heidelberg, August 2010. [https://link.springer.com/chapter/10.1007/978-3-642-14623-7_13](https://link.springer.com/chapter/10.1007/978-3-642-14623-7_13)
[^57]: Wahby, Riad S., and Dan Boneh. "Fast and simple constant-time hashing to the BLS12-381 elliptic curve." Cryptology ePrint Archive (2019). [https://eprint.iacr.org/2019/403](https://eprint.iacr.org/2019/403)
