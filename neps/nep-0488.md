---
NEP: 488
Title: Precompile for BLS12-381 curve operations
Authors: Olga Kuniavskaia <olga.kunyavskaya@aurora.dev>
Status: Draft
DiscussionsTo: https://github.com/nearprotocol/neps/pull/488
Type: Runtime Spec
Version: 0.0.1
Created: 2023-07-17
LastUpdated: 2023-07-17
---

## Summary

A pre-compiled NEAR runtime functions for operations on BLS12-381 curve. It is a necessary set to efficiently perform operations such as BLS signature and zkSNARKs verifications.

## Motivation

The BLS12-381 [[1](https://www.researchgate.net/publication/2894224_Constructing_Elliptic_Curves_with_Prescribed_Embedding_Degrees), [11](https://hackmd.io/@benjaminion/bls12-381), [52](https://eprint.iacr.org/2019/403.pdf)] is a wildly 
used[[2](https://zips.z.cash/protocol/protocol.pdf),[3](https://github.com/ethereum/consensus-specs/blob/master/specs/phase0/beacon-chain.md), [4](https://internetcomputer.org/docs/current/references/ic-interface-spec#certificate), [5](https://wiki.tezosagora.org/learn/futuredevelopments/layer2#zkchannels), [6](https://spec.filecoin.io/), [7](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#name-adoption-status-of-pairing-)] elliptic curve with 120+ bits of security[[8](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#section-4.2.1)] which support **the *pairing* operation*.* It is a good alternative for bn254 elliptic curve[[9](https://eprint.iacr.org/2005/133), [12](https://hackmd.io/@jpw/bn254)], which also supports the aggregation, and is currently implemented as NEAR precompiles[[10](https://github.com/near/NEPs/issues/98)]. Recent research shows that it contains only <100 bits of security[[13](https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-02.html#name-for-100-bits-of-security)] and we can see the tendency of switching from bn254 to bls12-381(ZCash[[14](https://electriccoin.co/blog/new-snark-curve/)], Ethereum[[15](https://eips.ethereum.org/EIPS/eip-2537)], Tezos[[16](https://medium.com/metastatedev/meanwhile-at-cryptium-labs-2-part-2-adding-the-pairing-equipped-elliptic-curve-bls12-381-to-tezos-cfce907e4be3)]).

The implementation of  BLS12-381 curve operations from this NEP as a precompile will allows effective verify the BLS-signature and zkSNARKs. At the moment, BLS signature verification for BLS12-381 is impossible due to the limitation of the gas in 300 TGas for one transaction.

Effective BLS-signature verification based on BLS12-381 elliptic curve will be useful for c*ross-chain interactions.* Some of the blockchains use the BLS signature in the protocols. If we want to implement the Clients for this blockchain on-chain in Near, we should be able to effectively verify the BLS signature. We can want to have a Client for a specific blockchain on Near for creating a bridge to verify the transaction from another blockchain and use it in Near. Examples of blockchains that use BLS signature based on BLS12-381: Eth2.0[[3](https://github.com/ethereum/consensus-specs/blob/master/specs/phase0/beacon-chain.md)], Filecoin[[6](https://spec.filecoin.io/)] and Tezos[[5](https://wiki.tezosagora.org/learn/futuredevelopments/layer2#zkchannels)]. Especially, it is necessary for Rainbow Bridge[[17](https://near.org/blog/eth-near-rainbow-bridge)] to make trustless transfers from Ethereum 2.0 to Near.

zkSNARKs is useful for working with users' private information[[18](https://eips.ethereum.org/EIPS/eip-196),[19](https://media.consensys.net/introduction-to-zksnarks-with-examples-3283b554fc3b)]. Zeropool[[20](https://zeropool.network/)] is a project who implements zkSNARKs verifier on Near and is currently based on alt-bn128. Implementation of the precompiles for BLS12-381 can make the projects like that more secure. zkSNARKs is also used in Roll Ups[[21](https://www.youtube.com/watch?v=al4YpfDVmS4&ab_channel=EthereumCatHerders),[22](https://near.org/blog/layer-2),[23](https://www.ledger.com/academy/what-are-blockchain-rollups)] scaling solutions.

This proposal is based on a similar proposal for Ethereum: EIP-2537[[15](https://eips.ethereum.org/EIPS/eip-2537)].

In this NEP we propose to add the following functions as precompile:

- ***bls12381_g1_sum*** — the function which adds the points from G1 on an elliptic curve. This function is useful for the aggregation of private keys in BLS Signature. Can be used for simple addition in G1. Separate from multiexp function due to gas cost. A similar function exists in Near for BN254 curve[[10](https://github.com/near/NEPs/issues/98)].
- ***bls12381_g2_sum*** — the function which adds the points from G2 on an elliptic curve. This function is useful for the aggregation of signatures in BLS Signature. Can be used for simple addition in G2. Separate from multiexp function due to gas cost.
- ***bls12381_g1_multiexp —*** for points $g_i \in G_1$ and scalars $s_i$ calculate $\sum g_i s_i$. Can be used for multiplication on the scalar. Can be useful for zkSNARKs verification. This operation can be performed in a more optimized way than just straightforward multiplication and addition by using Pippenger algorithm[[25](https://github.com/wborgeaud/python-pippenger/blob/master/pippenger.pdf)]. A similar function exists both in Near for BN254[[10](https://github.com/near/NEPs/issues/98)] and in EIP-2537[[15](https://eips.ethereum.org/EIPS/eip-2537)].
- ***bls12381_g2_multiexp —***  for points $g_i \in G_2$ and scalars $s_i$ calculate $\sum g_i s_i$. Can be used for multiplication on the scalar.
- ***bls12381_g1_map_to_curve —*** map base field element into the $G_1$ point. Doesn’t perform mapping of the byte string into field elements (can be done in different ways and quite fast). Transfer field element into a curve. It is necessary for signature schemes. Function from EIP-2537[[15](https://eips.ethereum.org/EIPS/eip-2537)].
- ***bls12381_g2_map_to_curve —*** map extension field element into the $G_2$ point. Doesn’t perform mapping of the byte string into extension field elements. Function from EIP-2537[[15](https://eips.ethereum.org/EIPS/eip-2537)].
- ***bls12381_g1_decompress —*** accepts points from $G_1$  in compressed form and returns in decompressed form. Some protocols provide points in compressed forms (for example, Light Client updates in Ethereum 2), and decompressing is a time-consuming operation. Other functions accept only decompressed points for simplicity and for gas consumption optimization.
- ***bls12381_g2_decompress —*** accepts points from $G_2$  in compressed form and returns in decompressed form.
- ***bls12381_pairing —***  verifying that $\prod e(p_i, q_i) = 1$, where $e$ is a pairing operation and $p_i \in G_1 \land q_i \in G_2$. Necessary function for verification BLS-signatures or zkSNARKs.  A similar function exists both in Near for BN254[[10](https://github.com/near/NEPs/issues/98)] and in EIP-2537[[15](https://eips.ethereum.org/EIPS/eip-2537)].

By using these functions, we can reproduce all functionality from EIP-2537[[15](https://eips.ethereum.org/EIPS/eip-2537)]. Which can be useful for Aurora[[24](https://doc.aurora.dev/evm/precompiles/)] to support Ethereum functionality on Near.

## Specification

### BLS12-381 Curve Specification

#### Elliptic Curve

**Definition:** The field $F_p$ for some *prime* $p$ is a set of integer elements $\textbraceleft 0, 1, \ldots, p - 1 \textbraceright$ with two operations: multiplication $\cdot$ and addition $+$. These operations are performed as multiplication/addition for integers number and then taking the remainder modulo $p$.



**Definition:** The elliptic curve $E(F_p)$  is a set of all pairs $(x, y) \in F_p$:

$$
y^2 \equiv x^3 + Ax + B \mod p
$$

together with an imaginary point at infinity 0, where: $A, B \in F_p$, p is prime > 3, and $4A^3 + 27B^2 \not \equiv 0 \mod p$

In the case of BLS12-381 equation is $y^2 \equiv x^3 + 4 \mod p$ ([[15](https://eips.ethereum.org/EIPS/eip-2537),[51](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11#name-bls-curves-for-the-128-bit-),[14](https://electriccoin.co/blog/new-snark-curve/),[11](https://hackmd.io/@benjaminion/bls12-381)])

**Parameters for our case:**

```rust
A = 0
B = 4
p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab
```

**Definition:** Let’s $P \in E(F_q)$ have coordinates (x, y), define $-P$  as a point on a curve with coordinates (x, -y).

**Definition:** The addition operation for Elliptic Curve is a function $+\colon E(F_p) \times E(F_p) \rightarrow E(F_p)$ defined with following rules: let’s P and Q $\in E(F_p)$

- if  $P \ne Q$ and $P \ne -Q$
  - draw a line passing through P and Q. This line intersects the curve at a third point R
  - reflect the point R about the x-axis by changing the sign of the y-coordinate. The resulting point is P+Q.
- if $P=Q$
  - draw a tangent line throw P for an elliptic curve. The line will intersect the curve at the second point R.
  - reflect the point R about the x-axis the same way to get point 2P
- $P = -Q$
  - $P + Q = P + (-P) = 0$ — the point on infinity
- Q = 0
  - $P + Q = P + 0 = P$

With the addition operation, Elliptic Curve forms a **group**.

#### Subgroups

**Definition:**  Subgroup H is a subset of the group G with the following properties:

- $\forall h_1, h_2 \in H\colon h_1 + h_2 \in H$
- $0 \in H$
- $\forall h \in H \colon -h \in H$

Notation: $H \subseteq G$

**Definition:** group/subgroup **order** is the number of elements in group/subgroup.

Notation: |G|  or #G, where G is group

For some technical reason (for `pairing` operation which we will define later), we will work not with the hole $E(F_p)$, but only with the two subgroups $G_1$and $G_2$ with the same **order** $r$. $G_1$ is a subset of $E(F_p)$, $G_2$ is a subgroup of another group, which we will define later. The $r$ should be prime and $G1 \ne G2$

For our BLS12-381 Elliptic Curve, **the order r** of $G1$  and $G2$([[15](https://eips.ethereum.org/EIPS/eip-2537), [51](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11#name-bls-curves-for-the-128-bit-)]):

```rust
Main subgroup order r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001
```

#### Field extension

**Definition:**  The field extension $F_{p^k}$ is a set of all polynomials with degree < k and coefficients from $F_p$ and defined operations $\cdot$ , $+$

$$
a_{k - 1}x^{k - 1} + \ldots + a_1x + a_0 = A(x) \in F_{p^k} \vert a_i \in F_p
$$

The $+$ operation is defined as a regular addition for polynomials:

$$
A(x) + B(x) = C(x)
$$

$$
\sum a_i x^i + \sum b_i x^i = \sum c_i x^i
$$

$$
c_i = (a_i + b_i) \mod p
$$

The multiplication $\cdot$ is defined as a regular polynomials’ multiplication by modulo M(x), where M(x) is an ***irreducible*** polynomial of degree k with coefficients from $F_p$

$$
C(x) = A(x) \cdot B(x)\mod M(x)
$$

Notation: $F_{p^k} = F_{p}[x] / M(x)$

In BLS12-381 we will need $F_{p^{12}}$ and we will build this field not as an extension from $F_p$ directly, but first we will build $F_{p^2}$ as a quadratic extension of field $F_p$, second we will build $F_{p^6}$ as a cubic extension of $F_{p^2}$, and finally we will build  $F_{p^{12}}$ the quadratic extension of field $F_{p^6}$.

For defining these fields, we will need to set up three $M(x)$ irreducible polynomials([[51](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11#name-bls-curves-for-the-128-bit-)]:

- $F_{p^2} = F_p[u] / (u^2 + 1)$
- $F_{p^6} = F_{p^2}[v] / (v^3 - u - 1)$
- $F_{p^{12}} = F_{p^6}[w]/(w^2 - v)$

Our second subgroup of order r, which we will use, is a subgroup of the same Elliptic Curve but with elements from $F_{p^{12}}$.   $G_2 \subset E(F_{p^{12}})$, where $E: y^2 = x^3 + 4$

#### Twist

Store elements from $E(F_{p^{12}})$ takes a lot of memory. ***The twist*** operation transforms the origin curve $E(F_{p^{12}})$ into another curve under another space $E'(F_{p^2})$. It is important that the new curve also has a $G'_2$  subgroup with order r and we can easily transform it to origin $G_2$.

We want to have $\psi \colon E'(F_{p^2}) \rightarrow E(F_{p^{12}})$, such as

- $\forall a, b \in E'(F_{p^2}) \colon \psi(a + b) = \psi(a) + \psi(b)$
- $\forall a, b \in E'(F_{p^2}) \colon \psi(a) = \psi(b) \Rightarrow a = b$

It is called injective group homomorphism.

For BLS12-381 E’ is defined as([[51](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11#name-bls-curves-for-the-128-bit-)]):

$$
E'\colon y^2 = x^3 + 4(u + 1)
$$

In most cases we will work with points from $G_2' \subset E'(F_{p^2})$ and use for this subgroup just the notation $G_2$.

#### Generators

**Definition:** if in the group $G$ exists element g, such as $\textbraceleft g, 2g, 3g, \ldots, |G|g \textbraceright = G$, the group G called ***cyclic group*** and g called ***generator***



$G_1$ and $G_2$ are cyclic subgroups with the following generators([[15](https://eips.ethereum.org/EIPS/eip-2537), [51](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11#name-bls-curves-for-the-128-bit-)]):

```rust
G1:
X = 0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb
Y = 0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1
```

For $(x', y') \in G_2 \subset E'(F_{p^2}):$
$$x' = x_0 + x_1u$$

$$y' = y_0 + y_1u$$

```rust
G2:
x0 = 0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8
x1 = 0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e
y0 = 0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801
y1 = 0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be
```

**Definition:** ***Cofactor*** is the ratio of the size of the whole group G to the size of subgroup H:

$$
|G|/|H|
$$

Cofactor $G_1\colon h = |E(F_p)|/r$ ([[51](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11#name-bls-curves-for-the-128-bit-)])

```rust
h = 0x396c8c005555e1568c00aaab0000aaab
```

Cofactor $G_2\colon h' = |E'(F_{p^2})|/r$ ([[51](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11#name-bls-curves-for-the-128-bit-)])

```rust
h' = 0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5
```

#### Pairing

Pairing is an operation, which we will need for digital signature verification. Pairing operation $e\colon G_1 \times G_2 \rightarrow G_T$, where $G_T \subset F_{p^{12}}$.

The main  pairing properties is:

- $e(P, Q + R) = e(P, Q) \cdot e(P, R)$
- $e(P  + S, R) = e(P, R)\cdot e(S, R)$

For calculating this function we will need the algorithm, called Miller Loop, and to effectively perform this algorithm we will need to know the key parameter for BLS curve $x$

```rust
x = -0xd201000000010000
```

You can find this parameter in:

- [[15](https://eips.ethereum.org/EIPS/eip-2537)] section specification, pairing parameters, miller loop scalar
- [[51](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11#name-bls-curves-for-the-128-bit-)] section 4.2.1 Parameter t
- [[14](https://electriccoin.co/blog/new-snark-curve/)] section BLS12-381, parameter u
- [[11](https://hackmd.io/@benjaminion/bls12-381)] section Curve equation and parameters, parameter x

#### Summary

The  parameters for the BLS12-381:

```rust
Base field modulus p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab
```

$$
E\colon y^2 \equiv x^3 + 4
$$

$$
E'\colon y^2 \equiv x^3 + 4(u + 1)
$$

```rust
Main subgroup order r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001
```

$$
F_{p^2} = F_p[u] / (u^2 + 1)
$$

$$
F_{p^6} = F_{p^2}[v] / (v^3 - u - 1)
$$

$$
F_{p^{12}} = F_{p^6}[w] / (w^2 - v)
$$

Generator for G1:

```rust
X = 0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb
Y = 0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1
```

Generator for G2:

```rust
x0 = 0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8
x1 = 0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e
y0 = 0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801
y1 = 0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be
```

Cofactor for G1:

```rust
h = 0x396c8c005555e1568c00aaab0000aaab
```

Cofactor for G2:

```rust
h' = 0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5
```

Key  BLS12-381 parameter used in Miller Loop:

```rust
x = -0xd201000000010000
```

All parameters were taken from [[15](https://eips.ethereum.org/EIPS/eip-2537)], [[51](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11#name-bls-curves-for-the-128-bit-)] and [[14](https://electriccoin.co/blog/new-snark-curve/)], all of them consistent between sources.

### Curve points encoding

#### bool

The bool is encoded as a little-endian `u64` type in Rust. The `true` value is encoded as `1` and `false` is encoded as `0`. All other values of `u64` are not allowed and should be interpreted as incorrect. Encoding is the same as for alt_bn128 implementation in nearcore[[50](https://github.com/near/nearcore/blob/master/runtime/near-vm-runner/src/logic/logic.rs)].

#### Scalar

The scalar value is encoded as a big-endian `[u8;32]`. All possible bytes combination is allowed. Encoding is similar with alt_bn128 implementation in nearcore[[50](https://github.com/near/nearcore/blob/master/runtime/near-vm-runner/src/logic/logic.rs)], but `big-endian` encoding is used instead of `little-endian` as in EIP-2537[[15](https://eips.ethereum.org/EIPS/eip-2537)].

#### Fields elements $F_p$

The value from $F_p$ is encoded as a big-endian `[u8; 48]`. Only values less than `p` are allowed. If the value is equal to or bigger than `p` the error should be returned.

The rule of encoding is consistent with zkcrypto[[53](https://github.com/zkcrypto/pairing/blob/0.14.0/src/bls12_381/README.md)], with implementation in milagro lib[[29](https://github.com/sigp/incubator-milagro-crypto-rust/tree/057d238936c0cbbe3a59dfae6f2405db1090f474)].

#### Extension fields elements $F_{p^2}$

The $q \in F_{p^{2}}$ could be written as $q = c_0 + c_1 v$, where $c_0, c_1 \in F_p$ The element from $F_{p^2}$ encoded in `[u8; 96]` as a bytes’ concatenation of $c_1$ and $c_0$. The $c_1$ and $c_0$ are encoded by the rule described in the previous section.

$q \in F_{p^2}$, $q = c_0 + c_1 v$ encoded as `[u8; 96]`:

- $c_1 \in F_p$ `[u8; 48]`
- $c_0 \in F_p$ `[u8; 48]`

The rule of encoding is consistent with zkcrypto[[53](https://github.com/zkcrypto/pairing/blob/0.14.0/src/bls12_381/README.md)] and with implementation in milagro lib[[29](https://github.com/sigp/incubator-milagro-crypto-rust/tree/057d238936c0cbbe3a59dfae6f2405db1090f474)].

#### Uncompressed points on curve $E(F_p)$

The points on the curve represent by affine coordinates: `(x: Fp, y: Fp)`. The elements from $E(F_p)$ encoded in `[u8; 96]` as bytes’ concatenation of `x` and `y` point coordinates, where $x, y \in F_p$. The $x, y$ are encoded according to the rules described in the section “Fields elements $F_p$” .

$E(F_p)$  is encoded as `[u8; 96]`:

- $x \in F_p$ `[u8; 48]`
- $y \in F_p$ `[u8; 48]`

*The second bit* is used to mark a point on infinity, if the second bit is set to 1 — it is an infinity point.

Encoding point on infinity:

```bash
let x: [u8; 96] = [0; 96];
x[0] = x[0] | 0x40;
```

The rule of encoding is consistent with zkcrypto[[53](https://github.com/zkcrypto/pairing/blob/0.14.0/src/bls12_381/README.md)] and with implementation in milagro lib[[29](https://github.com/sigp/incubator-milagro-crypto-rust/tree/057d238936c0cbbe3a59dfae6f2405db1090f474)].

#### Compressed points on curve $E(F_p)$

The points on the curve represent by affine coordinates: `(x: Fp, y: Fp)`. The elements from $E(F_p)$ in compressed form are encoded in `[u8; 48]` as *big-endian* encoded $x \in F_p$. The $y$  coordinate can be detected by the formula: $y = \pm \sqrt{x^3 + 4}$.

*The first bit* should be set as 1. This bit indicates that point is encoded in compressed form.

*The second bit* is used to mark a point on infinity, if the second bit is set to 1 — it is an infinity point.

To represent the sign of the $y$ *the third bit* of x encoding is used. If the first bit = 0 the $y$ is positive, if the first bit = 1 the $y$ is negative. We will consider the number positive the smallest between $y$  and $-y = p - y$.

The $x \in F_p$ encoded as `[u8; 48]` bytes according to the rules from section  “Extension fields elements $F_{p}$” .

The point on $E(F_p)$ with negative $y$ coordinate encoded as `[u8; 48]` bytes:

```rust
let x: [u8; 48] = encodeFp(x)
x[0] = x[0] | 0x80;
x[0] = x[0] | 0x20;
```

For encoding point of infinity:

```rust
let x: [u8; 48] = [0; 48];
x[0] = x[0] | 0x80;
x[0] = x[0] | 0x40;
```

The rule of encoding is consistent with zkcrypto[[53](https://github.com/zkcrypto/pairing/blob/0.14.0/src/bls12_381/README.md)] and with implementation in milagro lib[[29](https://github.com/sigp/incubator-milagro-crypto-rust/tree/057d238936c0cbbe3a59dfae6f2405db1090f474)].

#### Uncompressed points on twisted curve $E'(F_{p^2})$

The points on the curve represent by affine coordinates: `(x: Fp2, y: Fp2)`. The elements from $E'(F_{p^2})$ encoded in `[u8; 192]` as bytes’ concatenation of `x` and `y` point coordinates, where $x, y \in F_{p^2}$. The $x, y$ are encoded according to the rules described in the section “Extension fields elements $F_{p^2}$” .

$E'(F_{p^2})$  is encoded as `[u8; 192]`:

- $x \in F_{p^2}$ `[u8; 96]`:
  - $c_1 \in F_p$ `[u8; 48]`
  - $c_0 \in F_p$ `[u8; 48]`
- $y \in F_{p^2}$ `[u8; 96]`:
  - $c_1 \in F_p$ `[u8; 48]`
  - $c_0 \in F_p$ `[u8; 48]`

*The second bit* is used to mark a point on infinity, if the second bit is set to 1 — it is an infinity point.

Encoding point on infinity:

```bash
let x: [u8; 192] = [0; 192];
x[0] = x[0] | 0x40;
```

The rule of encoding is consistent with zkcrypto[[53](https://github.com/zkcrypto/pairing/blob/0.14.0/src/bls12_381/README.md)] and with implementation in milagro lib[[29](https://github.com/sigp/incubator-milagro-crypto-rust/tree/057d238936c0cbbe3a59dfae6f2405db1090f474)].

#### Compressed points on twisted curve $E'(F_{p2})$

The points on the curve represent by affine coordinates: `(x: Fp2, y: Fp2)`. The elements from $E'(F_{p^2})$ in compressed form are encoded in `[u8; 96]` as *big-endian* encoded $x \in F_{p^2}$. The $y$  coordinate can be detected by the formula: $y = \pm \sqrt{x^3 + 4}$.

*The first bit* should be set as 1. This bit indicates that point is encoded in compressed form.

*The second bit* is used to mark a point on infinity, if the second bit is set to 1 — it is an infinity point.

To represent the sign of the $y$ *the third bit* of x encoding is used. If the first bit = 0 the $y$ is positive, if the first bit = 1 the $y$ is negative. We will consider the number positive the smallest between $y$  and $-y$: first compare $c_1$ and second $c_0$.

The $x \in F_{p^2}$ encoded as `[u8; 96]` bytes according to the rules from section  “Extension fields elements $F_{p^2}$” .

The point on $E'(F_{p^2})$ with negative $y$ coordinate encoded as `[u8; 96]` bytes:

```rust
let x: [u8; 96] = encodeFp2(x);
x[0] = x[0] | 0x80;
x[0] = x[0] | 0x20;
```

Encoding point of infinity:

```rust
let x: [u8; 96] = [0; 96];
x[0] = x[0] | 0x80;
x[0] = x[0] | 0x40;
```

The rule of encoding is consistent with zkcrypto[[53](https://github.com/zkcrypto/pairing/blob/0.14.0/src/bls12_381/README.md)] and with implementation in milagro lib[[29](https://github.com/sigp/incubator-milagro-crypto-rust/tree/057d238936c0cbbe3a59dfae6f2405db1090f474)].

### Precompile functions

#### bls12381_g1_sum

***Description:***

The function computes the sum of the elements of the BLS12-381 curve. The input is an arbitrary number of points $p_i \in E(F_p)$, and the output is one point from $E(F_p)$ equal to $\sum p_i$.

The $E(F_p)$ curve,  points on the curve and the addition operation are defined in the BLS12-381 Curve Specification section.

Note: we take as input any points on the curve, not only from   $G_1$

***Input:*** the sequence of point $p_i \in E(F_p)$, each point encoded in decompress form as $(x\colon F_p, y\colon F_p)$. Expected `96*k` bytes as an input that is interpreted as byte concatenation of `k` slices, each slice is the uncompressed point from $E(F_p)$. More details are in the Curve Points Encoding section.

***Output:*** the output is 96 bytes — the one point $\in E(F_p)$ in decompressed form.

***Gas Estimation:***

The algorithm has a linear complexity of the number of elements. The gas can be calculated by the next formula

```rust
let k = (input_bytes + item_size - 1)/item_size
let gas_consumed = A + B * k
```

A and B are constants calculated empirically.

Here you can find benchmark test vectors for EIP-2537[[46](https://eips.ethereum.org/assets/eip-2537/bench_vectors)]. It doesn’t contain a sum function, but we can adopt the test vector for addition by duplicating it many times.

***Test cases:***

- Correct points in G1 group
- One of the points is 0
- One of the points is not in G1 group but on the curve
- The result is 0
- Correct addition with one point
- Point not on the curve
- The coding of field elements is incorrect, but if take only the suffix it will be the correct point on the curve
- The coding of field elements is incorrect, but by modulo p it is a correct element on the curve
- The coding of field elements is incorrect, an incorrect extra bit, which shows that it is decompressed encoding.
- Sum with the maximum number of elements
- Too many points for sum
- Incorrect len of input
- Empty input
- Generate points on the curve and check that the result doesn’t depend on permutation
- Generate points and cross-test the result with multiexp function.

***Tests References:***

We can use all the tests for addition for Ethereum[[47](https://github.com/matter-labs/eip1962/tree/master/src/test/test_vectors/eip2537), [48](https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles)] to check the case with k = 2. Also, we can reuse the `error` points. Can use the vectors for multiexp functions if separately perform multiplication.

***Error cases:***

- The input length is not divided by 96
- The input is empty
- Too much memory is used
- Field elements encoded incorrectly (see Curve points encoded section)
- Any points not on the curve

***Annotation:***

```rust
/// Computes sum for elements on BLS12-381 curve 
/// \sum_i p_i should be the equal result.
///
/// # Arguments
///
/// * `value` - sequence of pi points(x:Fp, y:Fp) on BLS-381 curve
///    BLS12-381 is Y^2 = X^3 + 4 curve over Fp.
///
///   `value` is encoded as packed, big-endian
///   `[([u8; 48], [u8; 48])]` slice.
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory or the registers
/// use more memory than the limit, the function returns `MemoryAccessViolation`.
///
/// If point coordinates are not on curve or `value.len()%96 != 0`,
/// the function returns `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes +
/// bls12381_g1_sum_base + bls12381_g1_sum_element * num_elements`
pub fn bls12381_g1_sum(&mut self, 
                       value_len: u64, 
                       value_ptr: u64, 
                       register_id: u64) -> Result<()>;
```

#### bls12381_g2_sum

***Description:***

The function computes the sum of the elements of the BLS12-381 curve. The input is an arbitrary number of points $p_i \in E'(F_{p^2})$, and the output is one point from $E'(F_{p^2})$ equal to $\sum p_i$.

The $E'(F_{p^2})$ curve,  points on the curve and the addition operation are defined in the BLS12-381 Curve Specification section.

Note: we take as input any points on the curve, not only from   $G_2$

***Input:*** the sequence of point $p_i \in E'(F_{p^2})$, each point encoded in decompress form as $(x\colon F_{p^2}, y\colon F_{p^2})$. Expected `192*k` bytes as an input that is interpreted as byte concatenation of `k` slices, each slice is the uncompressed point from $E'(F_{p^2})$. More details are in the Curve Points Encoding section.

***Output:*** the output is 192 bytes — the one point $\in E'(F_{p^2})$ in decompressed form.

***Gas Estimation:***

The algorithm has a linear complexity of the number of elements. The gas can be calculated by the next formula

```rust
let k = (input_bytes + item_size - 1)/item_size
let gas_consumed = A + B * k
```

A and B are constants calculated empirically.

Here you can find benchmark test vectors for EIP-2537[[46](https://eips.ethereum.org/assets/eip-2537/bench_vectors)]. It doesn’t contain a sum function, but we can adopt the test vector for addition by duplicating it many times.

***Test cases:***

The same as for **`bls12381_g1_sum`** only change points from $G_1$ and $E(F_p)$ into $G_2$ and $E'(F_{p^2})$.

***Tests References:***

We can use all the tests for addition for Ethereum[[47](https://github.com/matter-labs/eip1962/tree/master/src/test/test_vectors/eip2537), [48](https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles)] to check the case with k = 2. Also, we can reuse the `error` points. Can use the vectors for multiexp functions if separately perform multiplication.

***Error cases:***

- The input length is not divided by 192
- The input is empty
- Too much memory is used
- Extension field elements encoded incorrectly (see Curve points encoded section)
- Any points not on the curve

***Annotation:***

```rust
/// Computes sum for elements on BLS12-381 curve 
/// \sum_i p_i should be the equal result.
///
/// # Arguments
///
/// * `value` - sequence of pi points(x:Fp^2, y:Fp^2) on BLS-381 curve
///    BLS12-381 is Y^2 = X^3 + 4(i + 1) curve over Fp^2.
///
///   `value` is encoded as packed, big-endian
///   `[([u8; 96], [u8; 96])]` slice.
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory or the registers
/// use more memory than the limit, the function returns `MemoryAccessViolation`.
///
/// If point coordinates are not on curve or `value.len()%192 != 0`,
/// the function returns `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes +
/// bls12381_g2_sum_base + bls12381_g2_sum_element * num_elements`
pub fn bls12381_g2_sum(&mut self, 
                       value_len: u64, 
                       value_ptr: u64, 
                       register_id: u64) -> Result<()>;
```

#### ***bls12381_g1_multiexp***

***Description:***

The function takes as input the list of pairs $(p_i, s_i)$, where $p_i \in E(F_p)$ is a point on the curve and $s_i \in \mathbb{N}_0$ is a scalar. The function calculates $\sum s_i \cdot p_i$.

The multiplication on the scalar is the addition of that point a scalar number of times:

$$
s \cdot p = \underbrace{p + p + \ldots + p}_{s}
$$

The $E(F_p)$ curve,  points on the curve and the addition operation are defined in the BLS12-381 Curve Specification section.

Note:

- We take as input any points on the curve, not only from   $G_1$.
- The scalar is an arbitrary unsigned integer and can be bigger than the group order.

***Input:*** the sequence of pairs $(p_i, s_i)$, where $p_i \in E(F_p)$ is a point on the curve and $s_i \in \mathbb{N}_0$ is a scalar. Each point is encoded in decompress form as $(x\colon F_p, y\colon F_p)$ and a scalar has a type `u256` and BigEndian encoded in 32 bytes. Expected `128*k` bytes as an input that is interpreted as byte concatenation of `k` slices, each slice is the concatenation of uncompressed point from $E(F_p)$ — `96` bytes and scalar — `32` bytes. More details are in the Curve Points Encoding section.

***Output:*** the output is 96 bytes — the one point $\in E(F_p)$ in decompressed form.

***Gas Estimation:***

This function should be calculated by Pippenger’s algorithm[[25](https://github.com/wborgeaud/python-pippenger/blob/master/pippenger.pdf)]. The Complexity of this algorithm is $O(\frac{k}{\log(k)})$. For gas calculation we will use the formula $\frac{k}{\max(\log_2(k), 1)}$ the same way as in precompile for `alt_bn128` [10].

```rust
let k = (input_bytes+item_size-1)/item_size;
let gas_consumed = A + B*k + C * if k > 1 {k / (k as f32).log2().floor()} else {k};
```

A, B and C are constants calculated empirically.

For gas estimation, we can use the benchmark vectors for addition and multiplication for EIP-2537[[46](https://eips.ethereum.org/assets/eip-2537/bench_vectors)].

***Test cases:***

The same test cases as for the bls12381_g1_sum section.

Addition test cases:

- `group_order * P = 0`
- `(scalar + groupt_order) * P = scalar * P`
- `P + P + P .. + P = N*P`
- `0 * P = 0`
- `1 * P = P`
- Scalar is a MAX_INT

***Tests References:***

The EIP-2537 contains the same function, so we can reuse test vectors from Ethereum[[47](https://github.com/matter-labs/eip1962/tree/master/src/test/test_vectors/eip2537),[48](https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles)].

***Error cases:***

- The input length is not divided by 128
- The input is empty
- Too much memory is used
- Field elements encoded incorrectly (see Curve points encoded section)
- Any points not on the curve

***Annotation:***

```rust
/// Computes multiexp on BLS12-381 curve using Pippenger's algorithm 
///\sum_i si*pi should be equal result.
///
/// # Arguments
///
/// * `value` - sequence of (pi, si), where
///    pi is point (x:Fp, y:Fp) on BLS12-381, and si is u256.
///    BLS12-381 is Y^2 = X^3 + 4 curve over Fp.
///
///   `value` is encoded as packed, big-endian
///   `[(([u8; 48], [u8; 48]), u256)]` slice.
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory or the registers
/// use more memory than the limit, the function returns
/// `MemoryAccessViolation`.
///
/// If point coordinates are not on curve, point is not in the subgroup,
/// scalar is not in the field or  `value.len()%128!=0`, the function returns
/// `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes +
///  bls12381_g1_multiexp_base +
///  bls12381_g1_multiexp_element * num_elements + 
///  bls12381_g1_multiexp_element_div_log * num_elements/max(1, log(num_elements))`
pub fn bls12381_g1_multiexp(
        &mut self,
        value_len: u64,
        value_ptr: u64,
        register_id: u64,
) -> Result<()>;
```

#### ***bls12381_g2_multiexp***

***Description:***

The function takes as input the list of pairs $(p_i, s_i)$, where $p_i \in E'(F_{p^2})$ is a point on the curve and $s_i \in \mathbb{N}_0$ is a scalar. The function calculates $\sum s_i \cdot p_i$.

The multiplication on the scalar is the addition of that point a scalar number of times:

$$
s \cdot p = \underbrace{p + p + \ldots + p}_{s}
$$

The $E'(F_{p^2})$ curve,  points on the curve and the addition operation are defined in the BLS12-381 Curve Specification section.

Note:

- We take as input any points on the curve, not only from   $G_2$.
- The scalar is an arbitrary unsigned integer and can be bigger than the group order.

***Input:*** the sequence of pairs $(p_i, s_i)$, where $p_i \in E'(F_{p^2})$ is a point on the curve and $s_i \in \mathbb{N}_0$ is a scalar. 

Each point is encoded in decompress form as $(x\colon F_{p^2}, y\colon F_{p^2})$ and a scalar has a type `u256` and BigEndian encoded in 32 bytes. Expected `224*k` bytes as an input that is interpreted as byte concatenation of `k` slices, each slice is the concatenation of uncompressed point from $E'(F_{p^2})$ — `192` bytes and scalar — `32` bytes. More details are in the Curve Points Encoding section.

***Output:*** the output is 192 bytes — the one point $\in E'(F_{p^2})$ in decompressed form.

***Gas Estimation:***

This function should be calculated by Pippenger’s algorithm[[25](https://github.com/wborgeaud/python-pippenger/blob/master/pippenger.pdf)]. The Complexity of this algorithm is $O(\frac{k}{\log(k)})$. For gas calculation we will use the formula $\frac{k}{\max(\log_2(k), 1)}$ the same way as in precompile for `alt_bn128` [[10](https://github.com/near/NEPs/issues/98)].

```rust
let k = (input_bytes+item_size-1)/item_size;
let gas_consumed = A + B*k + C * if k > 1 {k / (k as f32).log2().floor()} else {k};
```

A, B and C are constants calculated empirically.

For gas estimation, we can use the benchmark vectors for addition and multiplication for EIP-2537[[46](https://eips.ethereum.org/assets/eip-2537/bench_vectors)].

***Test cases:***

The same as for **`bls12381_g1_multiexp`** only change points from $G_1$ and $E(F_p)$ into $G_2$ and $E'(F_{p^2})$.

***Tests References:***

The EIP-2537 contains the same function, so we can reuse test vectors from Ethereum[[47](https://github.com/matter-labs/eip1962/tree/master/src/test/test_vectors/eip2537), [48](https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles)].

***Error cases:***

- The input length is not divided by 224
- The input is empty
- Too much memory is used
- Field elements encoded incorrectly (see Curve points encoded section)
- Any points not on the curve

***Annotation:***

```rust
/// Computes multiexp on BLS12-381 curve using Pippenger's algorithm 
///\sum_i si*pi should be equal result.
///
/// # Arguments
///
/// * `value` - sequence of (pi, si), where
///    pi is point (x:Fp^2, y:Fp^2) on BLS12-381, and si is u256.
///    BLS12-381 is Y^2 = X^3 + 4(i + 1) curve over Fp^2.
///
///   `value` is encoded as packed, big-endian
///   `[(([u8; 96], [u8; 96]), u256)]` slice.
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory or the registers
/// use more memory than the limit, the function returns
/// `MemoryAccessViolation`.
///
/// If point coordinates are not on curve, point is not in the subgroup,
/// scalar is not in the field or  `value.len()%224!=0`, the function returns
/// `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes +
///  bls12381_g2_multiexp_base +
///  bls12381_g2_multiexp_element * num_elements + 
///  bls12381_g2_multiexp_element_div_log * num_elements/max(1, log(num_elements))`
pub fn bls12381_g2_multiexp(
        &mut self,
        value_len: u64,
        value_ptr: u64,
        register_id: u64,
) -> Result<()>;
```

#### bls12381_map_fp_to_g1

***Description:***

The function takes the element $a \in F_p$ and maps it to the $G_1 \subset E(F_p)$. The specification of the mapping function you can find in the specification for EIP-2537[[49](https://eips.ethereum.org/assets/eip-2537/field_to_curve)]. This function does NOT perform mapping of the byte string into $F_p$, it can be implemented in different ways and this can be performed effectively in contract.

***Input:*** the function takes as input `48` bytes — the element from $F_p$ (one unsigned integer $< p$). More details are in the Curve Points Encoding section.

***Output:*** the output is `96 bytes` — one point $\in G_1 \subset E(F_p)$ in decompressed format. More details are in the Curve Points Encoding section.

***Gas Estimation:***

The gas consumption is a constant calculated empirically.

***Test cases:***

- Correct $F_p$ element
- $a = 0$
- $a \ge p$
- Edge cases for inner algorithms for mapping[[49](https://eips.ethereum.org/assets/eip-2537/field_to_curve)]

***Tests References:*** The EIP-2537 contains the same function, so we can reuse test vectors from Ethereum[[47](https://github.com/matter-labs/eip1962/tree/master/src/test/test_vectors/eip2537),[48](https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles)].

***Error cases:***

- Incorrect input length
- $a \ge p$

***Annotation:***

```rust
/// Map elements from Fp to G1 subset of BLS12-381 curve
///
/// # Arguments
///
/// * `value` - 48 bytes, the element from Fp -- unsigned integer < p 
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory or the registers
/// use more memory than the limit, the function returns
/// `MemoryAccessViolation`.
///
/// If value_len != 48 or the value >= p the function return `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes +
///  bls12381_map_fp_to_g1_base`
pub fn bls12381_map_fp_to_g1(
        &mut self,
        value_len: u64,
        value_ptr: u64,
        register_id: u64,
) -> Result<()>;
```

#### bls12381_map_fp2_to_g2

***Description:***

The function takes the element $a \in F_{p^2}$ and maps it to the $G_2 \subset E'(F_{p^2})$. The specification of the mapping function you can find in the specification for EIP-2537[[49](https://eips.ethereum.org/assets/eip-2537/field_to_curve)]. This function does NOT perform mapping of the byte string into $F_{p^2}$, it can be implemented in different ways and this can be performed effectively in the contract.

***Input:*** the function takes as input `96 bytes` — the element from $F_{p^2}$ (two unsigned integers $< p$). More details are in the Curve Points Encoding section.

***Output:*** the output is `192 bytes` — one point $\in G_2 \subset E'(F_{p^2})$ in decompressed format. More details are in the Curve Points Encoding section.

***Gas Estimation:***

The gas consumption is a constant calculated empirically.

***Test cases:***

- Correct $F_{p^2}$ element
- $a = 0$
- One of the `a` value $\ge p$
- Edge cases for inner algorithms for mapping[[49](https://eips.ethereum.org/assets/eip-2537/field_to_curve)]

***Tests References:*** The EIP-2537 contains the same function, so we can reuse test vectors from Ethereum[[47](https://github.com/matter-labs/eip1962/tree/master/src/test/test_vectors/eip2537),[48](https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles)].

***Error cases:***

- Incorrect input length
- Value is not a valid extension field $F_{p^2}$ element

***Annotation:***

```rust
/// Map elements from Fp2 to G2 subset of E'(Fp2) BLS12-381 curve
///
/// # Arguments
///
/// * `value` - 96 bytes, the element from Fp2 -- two unsigned integer < p 
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory or the registers
/// use more memory than the limit, the function returns
/// `MemoryAccessViolation`.
///
/// If value_len != 96 or the value is not correct Fp2 element the function return `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes +
///  bls12381_map_fp2_to_g2_base`
pub fn bls12381_map_fp2_to_g2(
        &mut self,
        value_len: u64,
        value_ptr: u64,
        register_id: u64,
) -> Result<()>;
```

#### bls12381_pairing_check

***Description:***

The pairing function $e\colon G_1 \times G_2 \rightarrow G_T$, where $G_T \subset F_{q^{12}}$. The pairing function has the following properties:

- $e(P, Q + R) = e(P, Q) \cdot e(P, R)$
- $e(P + S, R) = e(P, R)\cdot e(S, R)$

The consequence:

$e([a]P, [b]Q) = e(P, Q)^{ab} = e([b]P, [a]Q)$

We need this function to verify BLS signature.

This function takes as input the sequence of pairs $(p_i, q_i)$, where $p_i \in G_1 \subset E(F_{p})$ and $q_i \in G_2 \subset E'(F_{p^2})$ and check:

$$
\sum e(p_i, q_i) = 1
$$

We don’t calculate the pairing function itself: the result will be in the huge field, and in all known applications only such a check is necessary.

***Input:*** the sequence of pairs $(p_i, q_i)$, where $p_i \in G_1 \subset E(F_{p})$ and $q_i \in G_2 \subset E'(F_{p^2})$. Each point is encoded in decompressed form. Expected `288*k` bytes as an input that is interpreted as byte concatenation of `k` slices, each slice is the concatenation of uncompressed point from $G_1 \subset E(F_p)$ — `96 bytes` and point from $G_2 \subset E'(F_{p^2})$ — `192 bytes`. More details are in the Curve Points Encoding section.

***Output:*** returns `bool` — the result of the pairing check. The `true` value means that the pairing result is equal to multiplicative identity and `false` otherwise.

***Gas Estimation:***

The algorithm has a linear complexity of the number of elements. The gas can be calculated by the next formula

```rust
let k = (input_bytes + item_size - 1)/item_size
let gas_consumed = A + B * k
```

A and B are constants calculated empirically.

Here you can find benchmark test vectors for EIP-2537[[46](https://eips.ethereum.org/assets/eip-2537/bench_vectors)].

***Test cases:***

- The correct input with different lengths with results true
- The correct input with different lengths with results false
- The first point on the curve but not in G1
- The second point on the curve but not in G2
- The input with incorrect length
- The points not on the curve
- Some points = 0
- The field elements are encoded incorrectly

***Tests References:*** The EIP-2537 contains the same function, so we can reuse test vectors from Ethereum[[47](https://github.com/matter-labs/eip1962/tree/master/src/test/test_vectors/eip2537),[48](https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles)].

***Error cases:***

- The input length is not divided by 288
- The input is empty
- Too much memory is used
- Field elements encoded incorrectly (see Curve points encoded section)
- Any points not on the curve
- Any points not in $G_1/G_2$

***Annotation:***

```rust
/// Computes pairing check on BLS12-381 curve.
/// \sum_i e(g_{1 i}, g_{2 i}) should be equal one (in additive notation), e(g1, g2) is pairing
///
/// # Arguments
///
/// * `value` - sequence of (g1:G1, g2:G2), where
///   G2 is subgroup point (x:Fp2, y:Fp2) on BLS12-381 twist,
///   BLS12-381 twist is Y^2 = X^3 + 4(i + 1) curve over Fp2
///   Fp2 is complex field element (re: Fp, im: Fp)
///   G1 is point (x:Fp, y:Fp) on BLS12-381,
///   BLS12-381 is Y^2 = X^3 + 4 curve over Fp
///
///   `value` is encoded a as packed, big-endian
///   `[(([u8; 48], [u8; 48]), ([u8; 96], [u8; 96]))]` slice.
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory than
/// the function returns `MemoryAccessViolation`.
///
/// If point coordinates are not on curve, point is not in the subgroup
// or data are wrong serialized, for example,
/// `value.len()%288!=0`, the function returns `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes + 
/// bls12381_pairing_base + bls12381_pairing_element * num_elements`
pub fn bls12381_pairing_check(&mut self, value_len: u64, value_ptr: u64) -> Result<u64> {
```

#### bls12381_decompress_g1

***Description:***  Function decompress compressed points from $E(F_p)$. The input is an arbitrary number of points $p_i \in E(F_p)$ in compressed format, and the output is the same number of points from $E(F_p)$ in decompressed format. More about the decompressed and compressed formats you can read in the Curve Points Encoding section.



***Input:***  the sequence of point $p_i \in E(F_p)$, each point encoded in compressed form. Expected `48*k` bytes as an input that is interpreted as byte concatenation of `k` slices, each slice is the compressed point from $E(F_p)$. More details are in the Curve Points Encoding section.

***Output:*** the sequence of point $p_i \in E(F_p)$, each point encoded in decompressed form. Expected `96*k` bytes as an output that is interpreted as byte concatenation of `k` slices, each slice is the decompressed point from $E(F_p)$. `k` the same as in input. More details are in the Curve Points Encoding section.

***Gas Estimation:*** The algorithm has a linear complexity of the number of elements. The gas can be calculated by the next formula

```rust
let k = (input_bytes + item_size - 1)/item_size
let gas_consumed = A + B * k
```

A and B are constants calculated empirically.

***Test cases:***

- the correct input with different length
- the input with incorrect size
- the points with the negative `y` coordinate
- 0 points
- points not on the curve
- incorrectly encoded points
- very long input

***Tests References:***

- Take the correct points on the curve from Ethereum tests[[47](https://github.com/matter-labs/eip1962/tree/master/src/test/test_vectors/eip2537),[48](https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles)] and check the correctness after decompression
- Randomly generate compressed points and check the equation correctness after decompression.

***Error cases:***

- The input length is not divided by 48
- The input is empty
- Too much memory is used
- Field elements encoded incorrectly (see Curve points encoded section)
- Any points not on the curve

***Annotation:***

```rust
/// Decompress points on BLS12-381 curve.
///
/// # Arguments
///
/// * `value` - sequence of pi points (x:Fp) on BLS-381 curve
///    BLS12-381 is Y^2 = X^3 + 4 curve over Fp.
///
///   `value` is encoded as packed `[[u8; 48]]` slice.
///
/// # Output
/// sequence of pi points (x: Fp; y: Fp) in decompress format: [([u8; 48], [u8; 48])]
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory or the registers
/// use more memory than the limit, the function returns `MemoryAccessViolation`.
///
/// If point coordinates are not on curve or `value.len()%48 != 0`,
/// the function returns `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes +
/// bls12381_g1_decompress_base + bls12381_g1_decompress_element * num_elements`
pub fn bls12381_decompress_g1(&mut self, 
                              value_len: u64, 
                              value_ptr: u64, 
                              register_id: u64) -> Result<()>;
```

#### bls12381_decompress_g2

***Description:***  Function decompress compressed points from $E'(F_{p^2})$. The input is an arbitrary number of points $p_i \in E'(F_{p^2})$ in compressed format, and the output is the same number of points from $E'(F_{p^2})$ in decompressed format. More about the decompressed and compressed formats you can read in the Curve Points Encoding section.



***Input:***  the sequence of point $p_i \in E'(F_{p^2})$, each point encoded in compressed form. Expected `96*k` bytes as an input that is interpreted as byte concatenation of `k` slices, each slice is the compressed point from $E'(F_{p^2})$. More details are in the Curve Points Encoding section.

***Output:*** the sequence of point $p_i \in E'(F_{p^2})$, each point encoded in decompressed form. Expected `192*k` bytes as an output that is interpreted as byte concatenation of `k` slices, each slice is the decompressed point from $E'(F_{p^2})$. `k` the same as in input. More details are in the Curve Points Encoding section.

***Gas Estimation:*** The algorithm has a linear complexity of the number of elements. The gas can be calculated by the next formula

```rust
let k = (input_bytes + item_size - 1)/item_size
let gas_consumed = A + B * k
```

A and B are constants calculated empirically.

***Test cases:***

- the correct input with different length
- the input with incorrect size
- the points with the negative `y` coordinate
- 0 points
- points not on the curve
- incorrectly encoded points
- very long input

***Tests References:***

- Take the correct points on the curve from Ethereum tests[[47](https://github.com/matter-labs/eip1962/tree/master/src/test/test_vectors/eip2537),[48]( https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles)] and check the correctness after decompression
- Randomly generate compressed points and check the equation correctness after decompression.

***Error cases:***

- The input length is not divided by 96
- The input is empty
- Too much memory is used
- Field elements encoded incorrectly (see Curve points encoded section)
- Any points not on the curve

***Annotation:***

```rust
/// Decompress points on twisted BLS12-381 curve.
///
/// # Arguments
///
/// * `value` - sequence of pi points (x:Fp2) on twisted BLS-381 curve
///    BLS12-381 is Y^2 = X^3 + (4 + i) curve over Fp2.
///
///   `value` is encoded as packed `[[u8; 96]]` slice.
///
/// # Output
/// sequence of pi points (x: Fp2; y: Fp2) in decompress format: [([u8; 96], [u8; 96])]
///
/// # Errors
///
/// If `value_len + value_ptr` points outside the memory or the registers
/// use more memory than the limit, the function returns `MemoryAccessViolation`.
///
/// If point coordinates are not on curve or `value.len()%96 != 0`,
/// the function returns `BLS12381InvalidInput`.
///
/// # Cost
///
/// `base + write_register_base + write_register_byte * num_bytes +
/// bls12381_g2_decompress_base + bls12381_g2_decompress_element * num_elements`
pub fn bls12381_decompress_g2(&mut self, 
                              value_len: u64, 
                              value_ptr: u64, 
                              register_id: u64) -> Result<()>;
```

## Reference Implementation

First of all, for integration with nearcore, we are interested in libraries in the Rust language. The existing BLS12-381 implementations on Rust:

1. ***Milagro Library*** [[29](https://github.com/sigp/incubator-milagro-crypto-rust/tree/057d238936c0cbbe3a59dfae6f2405db1090f474)].
2. ***BLST***  [[30](https://github.com/supranational/blst),[31](https://github.com/sean-sn/blst_eip2537)].
3. ***Matter labs EIP-1962 implementation*** [[32](https://github.com/matter-labs/eip1962)]
4. ***zCash origin implementation*** [[33](https://github.com/zcash/zcash/tree/master/src/rust/src)]
5. ***MCL Library*** [[34](https://github.com/herumi/bls)]
6. ***FileCoin implementation*** [[35](https://github.com/filecoin-project/bls-signatures)]
7. ***zkCrypto*** [[36](https://github.com/zkcrypto/pairing)]

To compile the list, we used the links from EIP-2537[[43](https://github.com/matter-labs-forks/EIPs/blob/bls12_381/EIPS/eip-2537.md)], pairing-curves specification[[44](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#name-cryptographic-libraries)], and an article with benchmarks[[45](https://hackmd.io/@gnark/eccbench)]. This list may be incomplete but should cover the core BLS12-381 implementations. In any case, to implement precompiles from that NEP we will need to modify any of that libraries.

In addition, there are implementations in other languages that are not so interesting to us in this context, but can be used as references:

1. C++, ETH2.0 Client, ***Chia library***[[37](https://github.com/Chia-Network/bls-signatures)]
2. Haskell, ***Adjoint Lib*** [[38](https://github.com/sdiehl/pairing)]
3. Go, ***Go-Ethereum*** [[39](https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles)]
4. JavaScript, ***Noble JS*** [[40](https://github.com/paulmillr/noble-bls12-381)]
5. Go, ***Matter Labs Go EIP-1962 implementation*** [[41](https://github.com/kilic/eip2537)]
6. C++, ***Matter Labs Go EIP-1962 implementation*** [[42](https://github.com/matter-labs-archive/eip1962_cpp)]

The draft implementation to nearcore you can find by this link[[54](near/nearcore#9317)]. This implementation is based on blst library[[30](https://github.com/supranational/blst)]. This library one of the fastest[[45](https://hackmd.io/@gnark/eccbench)] and audited[[55](https://research.nccgroup.com/wp-content/uploads/2021/01/NCC_Group_EthereumFoundation_ETHF002_Report_2021-01-20_v1.0.pdf)].

## Security Implications

The implementation security relies on the security of the chosen library, which supports operations with BLS curves.

In this NEP, we do not require a constant execution time for all operations. This is not a problem if you use precompiles to verify the BLS signature. These precompiles should not be used if you need a constant-time algorithm.

The BLS12-381 has more security bits than the already existing pairing-friendly curve BN254, as a result, the security of the projects which need the pairing-friendly curve will improve.

## Alternatives

In the nearcore the precompiles for another pairing-friendly curve alt-bn128 are already implemented[[10](https://github.com/near/NEPs/issues/98)]. For some projects[[20](https://zeropool.network/)] the alternative is just to use the supported curve. However, according to recent research, this curve contains less than 100 bits of security and is not recommended to use[[13](https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-02.html#name-for-100-bits-of-security)]. Moreover, projects with cross-chain interactions, such as Rainbow Bridge, must use the same curve as in a target protocol, and for Eth2.0 it is BLS12-381[[3](https://github.com/ethereum/consensus-specs/blob/master/specs/phase0/beacon-chain.md)]. As a result, there is no alternative to using another pairing-friendly curve.

Another alternative is to create one simple precompile in nearcore for BLS-signature verification. It was the first suggested solution[[26](https://github.com/near/NEPs/pull/446)]. However, this solution is not flexible enough[[28](https://github.com/near/NEPs/pull/446#pullrequestreview-1314601508)]: (1) projects can use different hash functions; (2) some projects can use for public keys G1 subgroup, another G2; (3) the specification for Eth2.0 continue to be in the draft and details can change, (4) in such implementation we can't support precompiles from EIP-2537.

The next alternative is to execute BLS12-381 operations off-chain. In that case, the applications which used the BLS curve will not be trustless anymore.

## Future possibilities

In the future, it is possible to support work with other curves, not only BLS12-381. In Ethereum, before EIP-2537[[15](https://eips.ethereum.org/EIPS/eip-2537)], EIP-1962 was proposed[[27](https://eips.ethereum.org/EIPS/eip-1962)]. In EIP-1962 was proposed to implement pairing-friendly elliptic curves in a generic format and support not only BLS curves but many others. However, this proposal wasn't accepted due to its large scope and complexity. I don't think it makes sense to implement every possible curve, but it could be a possible extension.

## Consequences

### Positive

- Projects, which used BN254 will be able to switch on BLS12-381 curve, and it will improve security.
- The trustless cross-chain interactions with blockchains that use BLS12-381 in protocols(such as Ethereum 2) will become possible.

### Neutral

### Negative

- The appearance of dependence on the library which supports BLS12-381 curves operations.

### Backward Compatibility

There are no backward compatibility questions.

## Changelog

The previous NEP for supporting BLS signature based on BLS12-381[[26](https://github.com/nearprotocol/neps/pull/446)]

## References

1. BLS 2002 [https://www.researchgate.net/publication/2894224_Constructing_Elliptic_Curves_with_Prescribed_Embedding_Degrees](https://www.researchgate.net/publication/2894224_Constructing_Elliptic_Curves_with_Prescribed_Embedding_Degrees)
2. ZCash protocol: [https://zips.z.cash/protocol/protocol.pdf](https://zips.z.cash/protocol/protocol.pdf)
3. Ethereum 2 specification: [https://github.com/ethereum/consensus-specs/blob/master/specs/phase0/beacon-chain.md](https://github.com/ethereum/consensus-specs/blob/master/specs/phase0/beacon-chain.md)
4. Dfinity: [https://internetcomputer.org/docs/current/references/ic-interface-spec#certificate](https://internetcomputer.org/docs/current/references/ic-interface-spec#certificate)
5. Tezos: [https://wiki.tezosagora.org/learn/futuredevelopments/layer2#zkchannels](https://wiki.tezosagora.org/learn/futuredevelopments/layer2#zkchannels)
6. Filecoin: [https://spec.filecoin.io/](https://spec.filecoin.io/)
7. Specification of pairing friendly curves with a list of applications in the table: [https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#name-adoption-status-of-pairing-](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#name-adoption-status-of-pairing-)
8. Specification of pairing friendly curves, the security level for BLS12-381: [https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#section-4.2.1](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#section-4.2.1)
9. BN2005: [https://eprint.iacr.org/2005/133](https://eprint.iacr.org/2005/133)
10. NEP-98 for BN254 precompile on NEAR: https://github.com/near/NEPs/issues/98
11. BLS12-381 for the Rest of Us: [https://hackmd.io/@benjaminion/bls12-381](https://hackmd.io/@benjaminion/bls12-381)
12. BN254 for the Rest of Us: [https://hackmd.io/@jpw/bn254](https://hackmd.io/@jpw/bn254)
13. Some analytics of different curve security: [https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-02.html#name-for-100-bits-of-security](https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-02.html#name-for-100-bits-of-security)
14. ZCash Transfer from bn254 to bls12-381: [https://electriccoin.co/blog/new-snark-curve/](https://electriccoin.co/blog/new-snark-curve/)
15. EIP-2537 Precompiles for Ethereum for BLS12-381: [https://eips.ethereum.org/EIPS/eip-2537](https://eips.ethereum.org/EIPS/eip-2537)
16. The article, where Tezos announce the support of BLS12-381 [https://medium.com/metastatedev/meanwhile-at-cryptium-labs-2-part-2-adding-the-pairing-equipped-elliptic-curve-bls12-381-to-tezos-cfce907e4be3](https://medium.com/metastatedev/meanwhile-at-cryptium-labs-2-part-2-adding-the-pairing-equipped-elliptic-curve-bls12-381-to-tezos-cfce907e4be3)
17. Article about Rainbow Bridge [https://near.org/blog/eth-near-rainbow-bridge](https://near.org/blog/eth-near-rainbow-bridge)
18. EIP-196. Precompiles for BN254: [https://eips.ethereum.org/EIPS/eip-196](https://eips.ethereum.org/EIPS/eip-196)
19. Intro into zkSNARKs: [https://media.consensys.net/introduction-to-zksnarks-with-examples-3283b554fc3b](https://media.consensys.net/introduction-to-zksnarks-with-examples-3283b554fc3b)
20. Zeropool project: [https://zeropool.network/](https://zeropool.network/)
21. Motivation for EIP-2537: [https://www.youtube.com/watch?v=al4YpfDVmS4&ab_channel=EthereumCatHerders](https://www.youtube.com/watch?v=al4YpfDVmS4&ab_channel=EthereumCatHerders)
22. Near blog post about Roll Ups: [https://near.org/blog/layer-2](https://near.org/blog/layer-2)
23. Ledger post about Roll Ups: [https://www.ledger.com/academy/what-are-blockchain-rollups](https://www.ledger.com/academy/what-are-blockchain-rollups)
24. Precompiles on Aurora: [https://doc.aurora.dev/evm/precompiles/](https://doc.aurora.dev/evm/precompiles/)
25. Pippenger Algorithm: [https://github.com/wborgeaud/python-pippenger/blob/master/pippenger.pdf](https://github.com/wborgeaud/python-pippenger/blob/master/pippenger.pdf)
26. NEP-446 proposal for BLS-signature verification precompile: [https://github.com/nearprotocol/neps/pull/446](https://github.com/nearprotocol/neps/pull/446)
27. EIP-1962 EC arithmetic and pairings with runtime definitions: [https://eips.ethereum.org/EIPS/eip-1962](https://eips.ethereum.org/EIPS/eip-1962)
28. Drawbacks of NEP-446: [https://github.com/near/NEPs/pull/446#pullrequestreview-1314601508](https://github.com/near/NEPs/pull/446#pullrequestreview-1314601508)
29. BLS12-381 Milagro: [https://github.com/sigp/incubator-milagro-crypto-rust/tree/057d238936c0cbbe3a59dfae6f2405db1090f474](https://github.com/sigp/incubator-milagro-crypto-rust/tree/057d238936c0cbbe3a59dfae6f2405db1090f474)
30. BLST: [https://github.com/supranational/blst](https://github.com/supranational/blst),
31. BLST EIP-2537 adaptation: [https://github.com/sean-sn/blst_eip2537](https://github.com/sean-sn/blst_eip2537)
32. EIP-1962 implementation matter labs Rust: https://github.com/matter-labs/eip1962
33. zCash origin rust implementation: [https://github.com/zcash/zcash/tree/master/src/rust/src](https://github.com/zcash/zcash/tree/master/src/rust/src)
34. MCL library: [https://github.com/herumi/bls](https://github.com/herumi/bls)
35. filecoin/bls-signature: [https://github.com/filecoin-project/bls-signatures](https://github.com/filecoin-project/bls-signatures)
36. zkCrypto: [https://github.com/zkcrypto/bls12_381](https://github.com/zkcrypto/bls12_381), [https://github.com/zkcrypto/pairing](https://github.com/zkcrypto/pairing)
37. BLS12-381 code bases for ETH2.0 client Chia library C++: [https://github.com/Chia-Network/bls-signatures](https://github.com/Chia-Network/bls-signatures)
38. Adjoint Lib: [https://github.com/sdiehl/pairing](https://github.com/sdiehl/pairing)
39. Ethereum Go implementation for EIP-2537: [https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles](https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles)
40. Noble JS implementation: [https://github.com/paulmillr/noble-bls12-381](https://github.com/paulmillr/noble-bls12-381)
41. EIP-1962 implementation matter labs Go: https://github.com/kilic/eip2537,
42. EIP-1962 implementation matter labs C++: https://github.com/matter-labs-archive/eip1962_cpp
43. EIP-2537 with links: [https://github.com/matter-labs-forks/EIPs/blob/bls12_381/EIPS/eip-2537.md](https://github.com/matter-labs-forks/EIPs/blob/bls12_381/EIPS/eip-2537.md)
44. Pairing-friendly curves specification, crypto libs: [https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#name-cryptographic-libraries](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#name-cryptographic-libraries)
45. Comparing different libs for pairing-friendly curves: [https://hackmd.io/@gnark/eccbench](https://hackmd.io/@gnark/eccbench)
46. Bench vectors from EIP2537: [https://eips.ethereum.org/assets/eip-2537/bench_vectors](https://eips.ethereum.org/assets/eip-2537/bench_vectors)
47. Metter Labs tests for EIP2537: [https://github.com/matter-labs/eip1962/tree/master/src/test/test_vectors/eip2537](https://github.com/matter-labs/eip1962/tree/master/src/test/test_vectors/eip2537)
48. Tests from Go Ethereum implementation: [https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles](https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles)
49. EIP-2537 Map To Curve specification: [https://eips.ethereum.org/assets/eip-2537/field_to_curve](https://eips.ethereum.org/assets/eip-2537/field_to_curve)
50. The current implementation of BN254: [https://github.com/near/nearcore/blob/master/runtime/near-vm-runner/src/logic/logic.rs](https://github.com/near/nearcore/blob/master/runtime/near-vm-runner/src/logic/logic.rs)
51. draft-irtf-cfrg-pairing-friendly-curves-11 [https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11#name-bls-curves-for-the-128-bit-](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11#name-bls-curves-for-the-128-bit-)  *(*[https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/bls.md](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/bls.md) → [https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04) → this ref*)*
52. Paper with BLS12-381: [https://eprint.iacr.org/2019/403.pdf](https://eprint.iacr.org/2019/403.pdf)
53. Zkcrypto points encoding: [https://github.com/zkcrypto/pairing/blob/0.14.0/src/bls12_381/README.md](https://github.com/zkcrypto/pairing/blob/0.14.0/src/bls12_381/README.md)
54. Draft PR for BLS12-381 operations in nearcore: https://github.com/near/nearcore/pull/9317
55. Audit for BLST library: [https://research.nccgroup.com/wp-content/uploads/2021/01/NCC_Group_EthereumFoundation_ETHF002_Report_2021-01-20_v1.0.pdf](https://research.nccgroup.com/wp-content/uploads/2021/01/NCC_Group_EthereumFoundation_ETHF002_Report_2021-01-20_v1.0.pdf)
