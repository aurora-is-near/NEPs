---
NEP: 488
Title: Host Functions for BLS12-381 Curve Operations
Authors: Olga Kuniavskaia <olga.kunyavskaya@aurora.dev>
Status: Draft
DiscussionsTo: https://github.com/nearprotocol/neps/pull/488
Type: Runtime Spec
Version: 0.0.1
Created: 2023-07-17
LastUpdated: 2023-11-21
---

## Summary

This NEP introduces host functions to perform operations on the BLS12-381 elliptic curve. It is a minimal set of functions needed to efficiently verify BLS signatures and zkSNARKs.

## Motivation

The primary aim of this NEP is to enable fast and efficient verification of BLS signatures and zkSNARKs based on 
BLS12-381[^1],[^11],[^52] elliptic curve on NEAR.

To efficiently verify zkSNARKs[^19], host functions for operations on the BN254 
elliptic curve(also known as Alt-BN128)[^9], [^12] have already been implemented on NEAR[^10]. 
For instance, the Zeropool[^20] project utilizes these host functions for verifying zkSNARKs on NEAR. 
However, recent research shows that the BN254 security level is lower than 100-bit[^13] and it is not recommended for use. 
BLS12-381, on the other hand, offers over 120 bits of security[^8] and is widely used[^2],[^3],[^4],[^5],[^6],[^7]  as a robust alternative. 
Supporting operations for BLS12-381 elliptic curve will significantly enhance the security of projects similar to Zeropool.

Another crucial objective is the verification of BLS signatures. 
Initially, host functions for BN254 in NEAR were designed for zkSNARK verification and 
are insufficient for BLS signature verifications. 
However, even if they were sufficient, it wouldn't work for us. 
Projects such as ZCash[^2], Ethereum[^3], Tezos[^5], and Filecoin[^6] incorporate BLS12-381 specifically within their protocols. 
If we aim for compatibility with these projects, we must also utilize this elliptic curve. 
For instance, to create a trustless bridge[^17] between Ethereum and NEAR, 
we must efficiently verify BLS signatures based on BLS12-381, as these are the signatures employed within Ethereum's protocol.

In this NEP, we propose to add the following host functions:

- ***bls12381_g1_sum —*** sum the signed points from $G_1$ on an elliptic curve. This function is useful for the aggregation of public keys in BLS Signature. It can be used for simple addition in $G_1$. Separate from the multiexp function due to the gas cost.
- ***bls12381_g2_sum —*** sum the signed points from $G_2$ on an elliptic curve. This function is useful for the aggregation of signatures in BLS Signature. It can be used for simple addition in $G_2$. Separate from the multiexp function due to the gas cost.
- ***bls12381_g1_multiexp —*** for points $g_i \in G_1$ and scalars $s_i$ calculate $\sum g_i s_i$. It can be used to multiply a group element by a scalar. 
- ***bls12381_g2_multiexp —*** for points $g_i \in G_2$ and scalars $s_i$ calculate $\sum g_i s_i$. It can be used to multiply a group element by a scalar.
- ***bls12381_map_fp_to_g1 —*** maps base field element into the $G_1$ point. It does not perform mapping of the byte string into field elements.
- ***bls12381_map_fp2_to_g2 —*** maps extension field element into the $G_2$ point. It does not perform mapping of the byte string into extension field elements. We require this function to efficiently map a message into a group element. We don't implement hash_to_field[^60] function, because it can be done inside a contract and different hashing algorithms can be used.
- ***bls12381_decompress_g1 —*** decompresses the points from $G_1$ provided in the compressed form. Some protocols provide points on the curve in the compressed form (e.g., the light client updates in Ethereum 2.0), and decompressing is a time-consuming operation. All the other functions in this NEP accept only decompressed points to be simple and to have optimized gas consumption.
- ***bls12381_decompress_g2 —*** decompresses the points from $G_2$ provided in the compressed form.
- ***bls12381_pairing_check —*** verifying that $\prod e(p_i, q_i) = 1$, where $e$ is a pairing operation and $p_i \in G_1 \land q_i \in G_2$. Used to verify BLS signatures or zkSNARKs. 

Functions required for verifying BLS signatures[^59]:

- bls12381_g1_sum
- bls12381_g2_sum
- bls12381_map_fp2_to_g2
- bls12381_decompress_g1
- bls12381_decompress_g2
- bls12381_pairing_check

Functions required for verifying zkSNARKs:

- bls12381_g1_sum
- bls12381_g1_multiexp
- bls12381_pairing_check

Both zkSNARKs and BLS signatures can be implemented alternatively by swapping G1 and G2. 
Therefore, all functions have been implemented for both G1 and G2.

An analogous proposal, EIP-2537[^15], exists in Ethereum. 
The functions here have been designed considering compatibility with Ethereum's proposal. 
This design approach aims to ensure future ease in supporting corresponding precompiles for Aurora[^24].

## Specification

### BLS12-381 Curve Specification

#### Elliptic Curve

**The field $F_p$** for some *prime* $p$ is a set of integer elements $\textbraceleft 0, 1, \ldots, p - 1 \textbraceright$ with two operations: multiplication $\cdot$ and addition $+$. These operations are performed as multiplication/addition for integers number and then taking the remainder modulo $p$.

**The elliptic curve $E(F_p)$**  is a set of all pairs $(x, y) \in F_p$:

$$
y^2 \equiv x^3 + Ax + B \mod p
$$

together with an imaginary point at infinity 0, where: $A, B \in F_p$, p is prime > 3, and $4A^3 + 27B^2 \not \equiv 0 \mod p$

In the case of BLS12-381 equation is $y^2 \equiv x^3 + 4 \mod p$[^15],[^51],[^14],[^11]

**Parameters for our case:**

- $A = 0$
- $B = 4$
- $p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab$

Let’s $P \in E(F_q)$ have coordinates (x, y), define **$-P$**  as a point on a curve with coordinates (x, -y).

**The addition operation for Elliptic Curve** is a function $+\colon E(F_p) \times E(F_p) \rightarrow E(F_p)$ defined with following rules: let’s P and Q $\in E(F_p)$

- if  $P \ne Q$ and $P \ne -Q$
  - draw a line passing through P and Q. This line intersects the curve at a third point R
  - reflect the point R about the x-axis by changing the sign of the y-coordinate. The resulting point is P+Q.
- if $P=Q$
  - draw a tangent line throw P for an elliptic curve. The line will intersect the curve at the second point R.
  - reflect the point R about the x-axis the same way to get point 2P
- $P = -Q$
  - $P + Q = P + (-P) = 0$ — the point on infinity
- Q = 0
  - $P + Q = P + 0 = P$

With the addition operation, Elliptic Curve forms a **group**.

#### Subgroups

**Subgroup** H is a subset of the group G with the following properties:

- $\forall h_1, h_2 \in H\colon h_1 + h_2 \in H$
- $0 \in H$
- $\forall h \in H \colon -h \in H$

Notation: $H \subseteq G$

Group/subgroup **order** is the number of elements in group/subgroup.

Notation: |G|  or #G, where G is group

For some technical reason (for `pairing` operation which we will define later), we will work not with the whole $E(F_p)$, but only with the two subgroups $G_1$ and $G_2$ with the same **order** $r$. $G_1$ is a subset of $E(F_p)$, $G_2$ is a subgroup of another group, which we will define later. The $r$ should be prime and $G1 \ne G2$

For our BLS12-381 Elliptic Curve, **the order r** of $G1$  and $G2$[^15],[^51]:

- $r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001$

#### Field extension

**The field extension $F_{p^k}$** is a set of all polynomials with degree < k and coefficients from $F_p$ and defined operations $\cdot$ , $+$

$$
a_{k - 1}x^{k - 1} + \ldots + a_1x + a_0 = A(x) \in F_{p^k} \vert a_i \in F_p
$$

The $+$ operation is defined as a regular addition for polynomials:

$$
A(x) + B(x) = C(x)
$$

$$
\sum a_i x^i + \sum b_i x^i = \sum c_i x^i
$$

$$
c_i = (a_i + b_i) \mod p
$$

The multiplication $\cdot$ is defined as a regular polynomials’ multiplication by modulo M(x), where M(x) is an ***irreducible*** polynomial of degree k with coefficients from $F_p$

$$
C(x) = A(x) \cdot B(x)\mod M(x)
$$

Notation: $F_{p^k} = F_{p}[x] / M(x)$

In BLS12-381 we will need $F_{p^{12}}$ and we will build this field not as an extension from $F_p$ directly, but first we will build $F_{p^2}$ as a quadratic extension of field $F_p$, second we will build $F_{p^6}$ as a cubic extension of $F_{p^2}$, and finally we will build  $F_{p^{12}}$ the quadratic extension of field $F_{p^6}$.

For defining these fields, we will need to set up three $M(x)$ irreducible polynomials[^51]:

- $F_{p^2} = F_p[u] / (u^2 + 1)$
- $F_{p^6} = F_{p^2}[v] / (v^3 - u - 1)$
- $F_{p^{12}} = F_{p^6}[w]/(w^2 - v)$

Our second subgroup of order r, which we will use, is a subgroup of the same Elliptic Curve but with elements from $F_{p^{12}}$.   $G_2 \subset E(F_{p^{12}})$, where $E: y^2 = x^3 + 4$

#### Twist

Store elements from $E(F_{p^{12}})$ takes a lot of memory. ***The twist*** operation transforms the origin curve $E(F_{p^{12}})$ into another curve under another space $E'(F_{p^2})$. It is important that the new curve also has a $G'_2$  subgroup with order r and we can easily transform it to origin $G_2$.

We want to have $\psi \colon E'(F_{p^2}) \rightarrow E(F_{p^{12}})$, such as

- $\forall a, b \in E'(F_{p^2}) \colon \psi(a + b) = \psi(a) + \psi(b)$
- $\forall a, b \in E'(F_{p^2}) \colon \psi(a) = \psi(b) \Rightarrow a = b$

It is called injective group homomorphism.

For BLS12-381 E’ is defined as[^51]:

$$
E'\colon y^2 = x^3 + 4(u + 1)
$$

In most cases we will work with points from $G_2' \subset E'(F_{p^2})$ and use for this subgroup just the notation $G_2$.

#### Generators

If in the group $G$ exists element g, such as $\textbraceleft g, 2g, 3g, \ldots, |G|g \textbraceright = G$, the group G called ***cyclic group*** and g called ***generator***

$G_1$ and $G_2$ are cyclic subgroups with the following generators[^15],[^51]:

$G_1$:

- $x = 0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb$
- $y = 0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1$

For $(x', y') \in G_2 \subset E'(F_{p^2}):$
$$x' = x_0 + x_1u$$

$$y' = y_0 + y_1u$$

$G_2$:

- $x_0 = 0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8$
- $x_1 = 0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e$
- $y_0 = 0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801$
- $y_1 = 0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be$


**Cofactor** is the ratio of the size of the whole group G to the size of subgroup H:

$$
|G|/|H|
$$

Cofactor $G_1\colon h = |E(F_p)|/r$[^51]

$$h = 0x396c8c005555e1568c00aaab0000aaab$$

Cofactor $G_2\colon h' = |E'(F_{p^2})|/r$[^51]

$$h' = 0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5$$

#### Pairing

Pairing is an operation, which we will need for digital signature verification. Pairing operation $e\colon G_1 \times G_2 \rightarrow G_T$, where $G_T \subset F_{p^{12}}$.

The main  pairing properties is:

- $e(P, Q + R) = e(P, Q) \cdot e(P, R)$
- $e(P  + S, R) = e(P, R)\cdot e(S, R)$

For calculating this function we will need the algorithm, called Miller Loop, and to effectively perform this algorithm we will need to know the key parameter for BLS curve $x$

$$ x = -0xd201000000010000$$

You can find this parameter in:

- [^15] section specification, pairing parameters, miller loop scalar
- [^51] section 4.2.1 Parameter t
- [^14] section BLS12-381, parameter u
- [^11] section Curve equation and parameters, parameter x

#### Summary

The  parameters for the BLS12-381:

Base field modulus $p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab$

$$
E\colon y^2 \equiv x^3 + 4
$$

$$
E'\colon y^2 \equiv x^3 + 4(u + 1)
$$

Main subgroup order $r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001$

$$
F_{p^2} = F_p[u] / (u^2 + 1)
$$

$$
F_{p^6} = F_{p^2}[v] / (v^3 - u - 1)
$$

$$
F_{p^{12}} = F_{p^6}[w] / (w^2 - v)
$$

Generator for G1:

- $x = 0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb$
- $y = 0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1$

Generator for G2:

- $x_0 = 0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8$
- $x_1 = 0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e$
- $y_0 = 0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801$
- $y_1 = 0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be$


Cofactor for G1:
$$h = 0x396c8c005555e1568c00aaab0000aaab$$

Cofactor for G2:
$$h' = 0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5$$

Key  BLS12-381 parameter used in Miller Loop:
$$x = -0xd201000000010000$$

All parameters were taken from[^15],[^51] and [^14], all of them consistent between sources.

### Map to curve specification

This section explains the functionality of the `bls12381_map_fp_to_g1` and `bls12381_map_fp2_to_g2` functions. 
They operate based on the specification RFC9380 "Hashing to Elliptic Curves"[^62].

These functions map the field element in $F_p$ or $F_{p^2}$ to the corresponding subgroup $G_1 \subset E(F_p)$ or $G_2 \subset E'(F_{p^2})$.
`bls12381_map_fp_to_g1`/`bls12381_map_fp2_to_g2` combine functions `map_to_curve` and `clear_cofactor` from RFC9380[^63].

```text
fn bls12381_map_fp_to_g1(u):
    let Q = map_to_curve(u);
    return clear_cofactor(Q);
```

We won't be implementing `hash_to_field` function as a host function because hashing can be performed through 
various methods, and this part is most likely subject to change. Additionally, executing this function within
the contract consumes approximately 2 TGas, which is acceptable for our goals.

Specific parameters for implementing `bls12381_map_fp_to_g1` and `bls12381_map_fp2_to_g2` you can find in RFC9380 in 
sections 8.8.1[^64] and 8.8.2[^65] respectively.

### Curve points encoding

#### Sign

The sign of the point on the elliptic curve is encoded as `u8` type in Rust with two possible values: `0` and `1`. `0` for positive sign, and `1` for negative sign. All other value of `u8` is not allowed and should be interpreted as incorrect.

#### Scalar

The scalar value is encoded as a little-endian `[u8;32]`. All possible bytes combination is allowed.

#### Fields elements Fp

The value from $F_p$ is encoded as a big-endian `[u8; 48]`. Only values less than `p` are allowed. If the value is equal to or bigger than `p` the error should be returned.

The rule of encoding is consistent with zkcrypto[^53], with implementation in milagro lib[^29].

#### Extension fields elements Fp2

The $q \in F_{p^{2}}$ could be written as $q = c_0 + c_1 v$, where $c_0, c_1 \in F_p$ The element from $F_{p^2}$ encoded in `[u8; 96]` as a bytes’ concatenation of $c_1$ and $c_0$. The $c_1$ and $c_0$ are encoded by the rule described in the previous section.

$q \in F_{p^2}$, $q = c_0 + c_1 v$ encoded as `[u8; 96]`:

- $c_1 \in F_p$ `[u8; 48]`
- $c_0 \in F_p$ `[u8; 48]`

The rule of encoding is consistent with zkcrypto[^53] and with implementation in milagro lib[^29].

#### Uncompressed points on curve E(Fp)

The points on the curve represent by affine coordinates: `(x: Fp, y: Fp)`. The elements from $E(F_p)$ encoded in `[u8; 96]` as bytes’ concatenation of `x` and `y` point coordinates, where $x, y \in F_p$. The $x, y$ are encoded according to the rules described in the section “Fields elements $F_p$” .

$E(F_p)$  is encoded as `[u8; 96]`:

- $x \in F_p$ `[u8; 48]`
- $y \in F_p$ `[u8; 48]`

*The second-highest bit* is used to mark a point on infinity, if the second-highest bit is set to 1 — it is an infinity point.
If the second-highest bit is set to 1, all others bits should be set to 0. Other encoding should throw an error.

Encoding point on infinity:

```bash
let x: [u8; 96] = [0; 96];
x[0] = x[0] | 0x40;
```

The rule of encoding is consistent with zkcrypto[^53] and with implementation in milagro lib[^29].

#### Compressed points on curve E(Fp)

The points on the curve represent by affine coordinates: `(x: Fp, y: Fp)`. The elements from $E(F_p)$ in compressed form are encoded in `[u8; 48]` as *big-endian* encoded $x \in F_p$. The $y$  coordinate can be detected by the formula: $y = \pm \sqrt{x^3 + 4}$.

*The highest bit* should be set as 1. This bit indicates that point is encoded in compressed form.

*The second-highest bit* is used to mark a point on infinity, if the second-highest bit is set to 1 — it is an infinity point.
If the second-highest bit is set to 1, all others except first two bits should be set to 0. Other encoding should throw an error.

To represent the sign of the $y$ *the third-highest bit* of x encoding is used. If the first bit = 0 the $y$ is positive, if the first bit = 1 the $y$ is negative. We will consider the number positive the smallest between $y$  and $-y = p - y$.

The $x \in F_p$ encoded as `[u8; 48]` bytes according to the rules from section  “Extension fields elements $F_{p}$” .

The point on $E(F_p)$ with negative $y$ coordinate encoded as `[u8; 48]` bytes:

```rust
let x: [u8; 48] = encodeFp(x)
x[0] = x[0] | 0x80;
x[0] = x[0] | 0x20;
```

For encoding point of infinity:

```rust
let x: [u8; 48] = [0; 48];
x[0] = x[0] | 0x80;
x[0] = x[0] | 0x40;
```

The rule of encoding is consistent with zkcrypto[^53] and with implementation in milagro lib[^29].

#### Uncompressed points on twisted curve E'(Fp2)

The points on the curve represent by affine coordinates: `(x: Fp2, y: Fp2)`. The elements from $E'(F_{p^2})$ encoded in `[u8; 192]` as bytes’ concatenation of `x` and `y` point coordinates, where $x, y \in F_{p^2}$. The $x, y$ are encoded according to the rules described in the section “Extension fields elements $F_{p^2}$” .

$E'(F_{p^2})$  is encoded as `[u8; 192]`:

- $x \in F_{p^2}$ `[u8; 96]`:
  - $c_1 \in F_p$ `[u8; 48]`
  - $c_0 \in F_p$ `[u8; 48]`
- $y \in F_{p^2}$ `[u8; 96]`:
  - $c_1 \in F_p$ `[u8; 48]`
  - $c_0 \in F_p$ `[u8; 48]`

*The second-highest bit* is used to mark a point on infinity, if the second-highest bit is set to 1 — it is an infinity point. 
If the second-highest bit is set to 1, all others bits should be set to 0. Other encoding should throw an error.

Encoding point on infinity:

```bash
let x: [u8; 192] = [0; 192];
x[0] = x[0] | 0x40;
```

The rule of encoding is consistent with zkcrypto[^53] and with implementation in milagro lib[^29].

#### Compressed points on twisted curve E'(Fp2)

The points on the curve represent by affine coordinates: `(x: Fp2, y: Fp2)`. The elements from $E'(F_{p^2})$ in compressed form are encoded in `[u8; 96]` as *big-endian* encoded $x \in F_{p^2}$. The $y$  coordinate can be detected by the formula: $y = \pm \sqrt{x^3 + 4(u + 1)}$.

*The highest bit* should be set as 1. This bit indicates that point is encoded in compressed form.

*The second-highest bit* is used to mark a point on infinity, if the second-highest bit is set to 1 — it is an infinity point.
If the second-highest bit is set to 1, all others except first two bits should be set to 0. Other encoding should throw an error.

To represent the sign of the $y$ *the third-highest bit* of x encoding is used. If the bit = 0 the $y$ is positive, if the bit = 1 the $y$ is negative. We will consider the number positive the smallest between $y$  and $-y$: first compare $c_1$ and second $c_0$.

The $x \in F_{p^2}$ encoded as `[u8; 96]` bytes according to the rules from section  “Extension fields elements $F_{p^2}$” .

The point on $E'(F_{p^2})$ with negative $y$ coordinate encoded as `[u8; 96]` bytes:

```rust
let x: [u8; 96] = encodeFp2(x);
x[0] = x[0] | 0x80;
x[0] = x[0] | 0x20;
```

Encoding point of infinity:

```rust
let x: [u8; 96] = [0; 96];
x[0] = x[0] | 0x80;
x[0] = x[0] | 0x40;
```

The rule of encoding is consistent with zkcrypto[^53] and with implementation in milagro lib[^29].

#### ERROR_CODE

Validating the input for the host functions within the contract can consume significant gas.
For instance, verifying if a point belongs to the subgroup is gas-consuming. 
If an error is returned by the near host function, the entire execution is reverted. 
To mitigate this, when the input verification is complex, the host function 
will successfully complete its work but return an ERROR_CODE. 
This enables users to handle error cases independently. It's important to note that host functions 
might terminate with an error if it's straightforward to avoid (e.g., incorrect input size).

The ERROR_CODE is encoded as a little-endian u64 and can hold the following values:

- 0: No error, execution was successful.
- 1: Execution finished with error due to:
  - Incorrect encoding (e.g., incorrectly set compression/decompression bit, coordinate >= p, etc.). 
  - A point not on the curve (where applicable). 
  - A point not in the expected subgroup (where applicable).


### Host functions

#### bls12381_g1_sum

***Description:***

The function calculates the sum of signed elements on the BLS12-381 curve. It accepts an arbitrary number of pairs $(s_i, p_i)$, where $p_i \in E(F_p)$ represents a point on the elliptic curve, and $s_i \in {0, 1}$ signifies the point's sign. The output is a single point from $E(F_p)$ equivalent to $\sum (-1)^{s_i}p_i$.

The operations, including the $E(F_p)$ curve, points on the curve, multiplication by -1, and the addition operation, are detailed in the BLS12-381 Curve Specification section.

Note: The function accepts points from the entire curve, not restricted to $G_1$.

***Input:***

The sequence of pairs $(s_i, p_i)$, where $p_i \in E(F_p)$ represents a point and $s_i \in {0, 1}$ denotes the sign. Each point is encoded in decompressed form as $(x\colon F_p, y\colon F_p)$, and the sign is encoded in one byte, taking only two allowed values: 0 or 1. Expect 97*k bytes as input, which are interpreted as byte concatenation of k slices, with each slice representing the point sign and the uncompressed point from $E(F_p)$. Further details are available in the Curve Points Encoding section.

***Output:*** 

The ERROR_CODE is returned. 

- ERROR_CODE = 0: the input is correct
  - <ins>Output:</ins> 96 bytes represent one point $\in E(F_p)$ in its decompressed form. In case of an empty input, it outputs a point on infinity (refer to the Curve Points Encoding section for more details).
- ERROR_CODE = 1:
  - Points or signs are incorrectly encoded (refer to Curve points encoded section).
  - Point is not on the curve.

***Gas Estimation:***

The algorithm has linear complexity concerning the number of elements. The gas estimation can be calculated using the following formula:

```rust
let k = input_bytes/item_size
let gas_consumed = A + B * k
```

Here, A and B represent empirically calculated constants.

Here, you can find benchmark test vectors for EIP-2537[^46]. Although it doesn't include a sum function, we can adapt the test vector for addition by duplicating it multiple times.

***Test cases:***

<ins>Tests for the sum of two points</ins>

This section aims to verify the correctness of summing two valid elements on the curve:

- Utilize points on the curve with known addition results for comparison, such as tests from EIP-2537[^47],[^48].
- Generate random points on the curve and verify the commutative property: P + Q = Q + P.
- Validate that the sum of random points from G1 remains in G1.
- Generate random points on the curve and use another library to cross-check the results.

Edge cases:

- Points not from G1.
- 0 + 0 = 0.
- P + 0 = 0 + P = P.
- P + (-P) = (-P) + P = 0.
- P + P (tangent to the curve).
- The sum of two points P and (-(P + P)) (tangent to the curve at point P).


<ins>Tests for inversion</ins>

This section aims to validate the correctness of point inversion:

- Generate random points on the curve and verify P - P = -P + P = 0.
- Generate random points on the curve and verify -(-P) = P.
- Generate random points from G1 and ensure that -P also belong to G1.
- Utilize an external implementation, generate random points on the curve, and compare results.

Edge cases:

- Point not from G1
- -0


<ins>Tests for incorrect data</ins>

This section aims to validate the handling of incorrect input data:

- Incorrect input length.
- Incorrect sign value (not 0 or 1).
- Erroneous coding of field elements, resulting in a correct point on the curve if only the suffix is considered.
- Erroneous coding of field elements resulting in a correct element on the curve modulo p.
- Erroneous coding of field elements with an incorrect extra bit in the decompressed encoding.
- Point not on the curve.
- Incorrect encoding of the point on infinity.
- Input is beyond memory bounds.

<ins>Tests for the sum of an arbitrary amount of points</ins>

This section focuses on validating the summation functionality with an arbitrary number of points:

- Generate random points on the curve and verify that the sum of the random permutation matches.
- Generate random points on the curve and utilize another library to validate results.
- Create points and cross-check the outcome with the multiexp function.
- Generate random points from $G_1$ and confirm that the sum is also from $G_1$.

- Edge cases:

- Empty input
- Sum with the maximum number of elements
- A single point

***Error cases (execution is terminated):***

- The input length is not divisible by 97.
- The input is beyond memory bounds.

***Annotation:***

```rust
pub fn bls12381_g1_sum(&mut self, 
                       value_len: u64, 
                       value_ptr: u64, 
                       register_id: u64) -> Result<u64>;
```

#### bls12381_g2_sum

***Description:***

The function computes the sum of the signed elements on the BLS12-381 curve. It accepts an arbitrary number of pairs $(s_i, p_i)$, where $p_i \in E'(F_{p^2})$ represents a point on the elliptic curve and $s_i \in {0, 1}$ is the point's sign. The output is a single point from $E'(F_{p^2})$ equal to $\sum (-1)^{s_i}p_i$.

The $E'(F_{p^2})$ curve, the points on the curve, the multiplication by -1, and the addition operation are all defined in the BLS12-381 Curve Specification section.

Note: The function accepts any points on the curve, not limited to $G_2$.

***Input:*** 

The sequence of pairs $(s_i, p_i)$, where $p_i \in E'(F_{p^2})$ is point and $s_i \in \textbraceleft 0, 1 \textbraceright$  represents a sign.  
Each point is encoded in decompressed form as $(x: F_{p^2}, y: F_{p^2})$, and the sign is encoded in one byte. The expected input size is 193*k bytes, interpreted as a byte concatenation of k slices, 
each slice representing the point sign alongside the uncompressed point from $E'(F_{p^2})$. 
More details are available in the Curve Points Encoding section.

***Output:***

The ERROR_CODE is returned.

- ERROR_CODE = 0: the input is correct
  - <ins>Output:</ins> 192 bytes represent one point $\in E'(F_{p^2})$ in its decompressed form. In case of an empty input, it outputs a point on infinity (refer to the Curve Points Encoding section for more details).
- ERROR_CODE = 1:
  - Points or signs are incorrectly encoded (refer to Curve points encoded section).
  - Point is not on the curve.

***Gas Estimation:***

The algorithm has linear complexity concerning the number of elements. The gas estimation can be calculated using the following formula:

```rust
let k = input_bytes/item_size
let gas_consumed = A + B * k
```

Here, A and B represent empirically calculated constants.

Here, you can find benchmark test vectors for EIP-2537[^46]. Although it doesn't include a sum function, we can adapt the test vector for addition by duplicating it multiple times.

***Test cases:***

The test cases are identical to those of `bls12381_g1_sum`, with the only alteration being the substitution of points from $G_1$ and $E(F_p)$ with points from $G_2$ and $E'(F_{p^2})$.

***Error cases (execution is terminated):***

- The input length is not divisible by 193.
- The input is beyond memory bounds.

***Annotation:***

```rust
pub fn bls12381_g2_sum(&mut self, 
                       value_len: u64, 
                       value_ptr: u64, 
                       register_id: u64) -> Result<u64>;
```

#### ***bls12381_g1_multiexp***

***Description:***

The function accepts a list of pairs $(p_i, s_i)$, where $p_i \in E(F_p)$ represents a point on the curve, and $s_i \in \mathbb{N}_0$ denotes a scalar. It calculates $\sum s_i \cdot p_i$.

The scalar multiplication operation signifies the addition of that point a scalar number of times:

$$
s \cdot p = \underbrace{p + p + \ldots + p}_{s}
$$

The $E(F_p)$ curve, points on the curve, and the addition operation are defined in the BLS12-381 Curve Specification section.

Please note:

- The function accepts any points on the curve, not solely from $G_1$.
- The scalar is an arbitrary unsigned integer and can exceed the group order.

***Input:*** The sequence of pairs $(p_i, s_i)$, where $p_i \in E(F_p)$ represents a point on the curve, and $s_i \in \mathbb{N}_0$ is a scalar. The expected input size is 128*k bytes, interpreted as byte concatenation of k slices. Each slice comprises the concatenation of an uncompressed point from $E(F_p)$— 96 bytes, along with a scalar— 32 bytes. Further details are available in the Curve Points Encoding section.

***Output:***

The ERROR_CODE is returned.

- ERROR_CODE = 0: the input is correct
  - <ins>Output:</ins> 96 bytes represent one point $\in E(F_p)$ in its decompressed form. In case of an empty input, it outputs a point on infinity (refer to the Curve Points Encoding section for more details).
- ERROR_CODE = 1:
  - Points are incorrectly encoded (refer to Curve points encoded section).
  - Point is not on the curve.

***Gas Estimation:***

For simplicity, we will use the linear formula for gas calculation:

```rust
let k = input_bytes / item_size
let gas_consumed = A + B * k
```

Here, A and B represent empirically calculated constants.

Pippenger’s algorithm[^25] can be employed to enhance gas efficiency. For gas estimation, the benchmark vectors for addition and multiplication in EIP-2537[^46] can be utilized.

***Test cases:***

<ins>Tests for multiplication</ins>

- Tests with known answers for multiplication from EIP-2537[^47],[^48].
- Random small scalar n and point P:
  - Check results with the sum function: `P + P + P + .. + P = n*P`.
  - Compare with results from another library.
- Random scalar n and point P:
  - Verify against results from another library.
  - Implement multiplication by using the sum function and the double-and-add algorithm[^61].

Edge cases:

- `group_order * P = 0`
- `(scalar + groupt_order) * P = scalar * P`
- `P + P + P .. + P = N*P`
- `0 * P = 0`
- `1 * P = P`
- Scalar is a MAX_INT

<ins>Tests for sum of two points</ins>

These are identical test cases to those in the `bls12381_g1_sum` section.

- Generate random points P and Q, then compare the results with the sum function.

<ins>Tests for the sum of an arbitrary amount of points</ins>

- Random number of points, random point values; compare results with the sum function.
- Empty input.
- Input of maximum size.

<ins>Tests for the multiexp of an arbitrary amount of points</ins>

- Tests with known answers from EIP-2537[^47],[^48]
- Random number of points, scalars, and points:
  - Check with results from another library.
  - Check with raw implementation based on the sum function and the double-and-add algorithm.- Empty input
- Maximum number of scalars and points.

<ins>Tests for error cases</ins>

The same test cases as those in the `bls12381_g1_sum` section will be applied.

***Error cases (execution is terminated):***

- The input length is not divisible by 128.
- The input is beyond memory bounds.

***Annotation:***

```rust
pub fn bls12381_g1_multiexp(
        &mut self,
        value_len: u64,
        value_ptr: u64,
        register_id: u64,
) -> Result<u64>;
```

#### ***bls12381_g2_multiexp***

***Description:***

The function takes a list of pairs $(p_i, s_i)$ as input, where $p_i \in E'(F_{p^2})$ represents a point on the curve, and $s_i \in \mathbb{N}_0$ denotes a scalar. The function computes $\sum s_i \cdot p_i$.

This scalar multiplication operation involves adding the point $p$ to itself a specified number of times:

$$
s \cdot p = \underbrace{p + p + \ldots + p}_{s}
$$

The $E'(F_{p^2})$ curve, points on the curve, and the addition operation are defined in the BLS12-381 Curve Specification section.

Please note:

- The function accepts any points on the curve, not solely from $G_2$.
- The scalar is an arbitrary unsigned integer and can exceed the group order.

***Input:*** the sequence of pairs $(p_i, s_i)$, where $p_i \in E'(F_{p^2})$ is a point on the curve and $s_i \in \mathbb{N}_0$ is a scalar. 

Expected `224*k` bytes as an input that is interpreted as byte concatenation of `k` slices, each slice is the concatenation of uncompressed point from $E'(F_{p^2})$ — `192` bytes and scalar — `32` bytes. More details are in the Curve Points Encoding section.

***Output:*** 

The ERROR_CODE is returned.

- ERROR_CODE = 0: the input is correct
  - <ins>Output:</ins> 192 bytes represent one point $\in E'(F_{p^2})$ in its decompressed form. In case of an empty input, it outputs a point on infinity (refer to the Curve Points Encoding section for more details).
- ERROR_CODE = 1:
  - Points are incorrectly encoded (refer to Curve points encoded section).
  - Point is not on the curve.

***Gas Estimation:***

For simplicity, we will use the linear formula for gas calculation:

```rust
let k = input_bytes / item_size
let gas_consumed = A + B * k
```

Here, A and B represent empirically calculated constants.

Pippenger’s algorithm[^25] can be employed to enhance gas efficiency. For gas estimation, the benchmark vectors for addition and multiplication in EIP-2537[^46] can be utilized.

***Test cases:***

The test cases are identical to those for `bls12381_g1_multiexp`, except that the points from $G_1$ and $E(F_p)$ are replaced with points from $G_2$ and $E'(F_{p^2})$

***Error cases (execution is terminated):***

- The input length is not divisible by 224.
- The input is beyond memory bounds.
 
***Annotation:***

```rust
pub fn bls12381_g2_multiexp(
        &mut self,
        value_len: u64,
        value_ptr: u64,
        register_id: u64,
) -> Result<u64>;
```

#### bls12381_map_fp_to_g1

***Description:***

The function takes the element $a \in F_p$ and maps it to $G_1 \subset E(F_p)$. You can find the specification of this mapping function in the section titled 'Map to curve specification.' Importantly, this function does NOT perform the mapping of the byte string into $F_p$. The implementation of this function may vary and can be effectively executed within the contract.

***Input:*** 

The function expects 48 bytes as input, representing an element from $F_p$ (a single unsigned integer $< p$). Additional information is available in the Curve Points Encoding section.

***Output:*** 

The ERROR_CODE is returned.

- ERROR_CODE = 0: the input is correct
  - <ins>Output:</ins> `96` bytes - represents a single point $\in G_1 \subset E(F_p)$ in decompressed format. Further information is available in the Curve Points Encoding section.
- ERROR_CODE = 1: $a \ge p$.

***Gas Estimation:***

The gas consumption is a constant calculated empirically.

***Test cases:***

<ins>Tests for general cases </ins>

- Validate the results for known answers from EIP-2537[^47],[^48].
- Generate a random point $a$ from $F_p$:
  - Verify the result using another library.
  - Check that the resulting point lies on the curve in $G_1$.
  - Compare the results for $a$ and $-a$; they should share the same x-coordinates and have opposite y-coordinates.

Edge cases:

- $a = 0$
- $a = p - 1$

<ins>Tests for error cases </ins>

- Input length not equal to 48 bytes: 
  - Empty input
  - 96 bytes
  - Input is beyond memory bounds.
- $a = p$
- Random number $\ge p$

***Error cases (execution is terminated):***

- Incorrect input length

***Annotation:***

```rust
pub fn bls12381_map_fp_to_g1(
        &mut self,
        value_len: u64,
        value_ptr: u64,
        register_id: u64,
) -> Result<u64>;
```

#### bls12381_map_fp2_to_g2

***Description:***

The function takes the element $a \in F_{p^2}$ and maps it to $G_2 \subset E'(F_{p^2})$. You can find the mapping function's specifications in the "Map to Curve Specification" section. It's important to note that this function does NOT map the byte string into $F_{p^2}$. The implementation of this function may vary and can be effectively executed within the contract.

***Input:*** the function takes as input `96 bytes` — the element from $F_{p^2}$ (two unsigned integers $< p$). Additional details can be found in the Curve Points Encoding section.

***Output:*** 

The ERROR_CODE is returned.

- ERROR_CODE = 0: the input is correct
  - <ins>Output:</ins> `192` bytes - represents a single point $\in G_2 \subset E'(F_{p^2})$ in decompressed format. More details are in the Curve Points Encoding section.
- ERROR_CODE = 1: the value is not a valid extension field $F_{p^2}$ element

***Gas Estimation:***

The gas consumption is a constant calculated empirically.

***Test cases:***

<ins>Tests for general cases </ins>

- Validate the results for known answers from EIP-2537[^47],[^48]
- Generate a random point $a$ from $F_{p^2}$:
  - Verify the result with another library.
  - Check that result point on curve in G2.
  - Compare results for $a$ and $-a$; they should have the same x-coordinates and opposite y-coordinates.

Edge cases:

- $a = (0, 0)$
- $a = (p - 1, p - 1)$

<ins>Tests for error cases </ins>

- Input length not equal to 96 bytes::
  - Empty input
  - 192 bytes
  - Input is beyond memory bounds.
- $a = (0, p)$
- $a = (p, 0)$
- (random number $\ge p$, 0)
- (0, random number $\ge p$)

***Error cases (execution is terminated):***

- Incorrect input length

***Annotation:***

```rust
pub fn bls12381_map_fp2_to_g2(
        &mut self,
        value_len: u64,
        value_ptr: u64,
        register_id: u64,
) -> Result<u64>;
```

#### bls12381_pairing_check

***Description:***

The pairing function $e\colon G_1 \times G_2 \rightarrow G_T$, where $G_T \subset F_{q^{12}}$, exhibits the following properties:

- $e(P, Q + R) = e(P, Q) \cdot e(P, R)$
- $e(P + S, R) = e(P, R)\cdot e(S, R)$

Consequently:

$e([a]P, [b]Q) = e(P, Q)^{ab} = e([b]P, [a]Q)$

This function is necessary to verify BLS signatures/zkSNARKs.

This function takes as input the sequence of pairs $(p_i, q_i)$, where $p_i \in G_1 \subset E(F_{p})$ and $q_i \in G_2 \subset E'(F_{p^2})$ and validate:

$$
\prod e(p_i, q_i) = 1
$$

We don’t calculate the pairing function itself: the result will be in the huge field, and in all known applications only this validation check is necessary.

***Input:*** A sequence of pairs $(p_i, q_i)$, where $p_i \in G_1 \subset E(F_{p})$ and $q_i \in G_2 \subset E'(F_{p^2})$. Each point is encoded in decompressed form. An expected input size of 288*k bytes is anticipated, interpreted as byte concatenation of k slices. Each slice comprises the concatenation of an uncompressed point from $G_1 \subset E(F_p)$ (occupying 96 bytes) and a point from $G_2 \subset E'(F_{p^2})$ (occupying 192 bytes). Additional details can be found in the Curve Points Encoding section.

***Output:***

The ERROR_CODE is returned.

- ERROR_CODE = 0: the input is correct
  - <ins>Output:</ins> 1 byte with two possible values: 1 if the pairing result equals the multiplicative identity, and 0 otherwise.
- ERROR_CODE = 1:
  - Points encoded incorrectly (refer to the Curve Points Encoded section).
  - Point not on the curve.
  - Point not in $G_1/G_2$.

For an empty input, the function returns ERROR_CODE = 0.

***Gas Estimation:***

The algorithm has linear complexity concerning the number of elements. The gas estimation can be calculated using the following formula:

```rust
let k = input_bytes/item_size
let gas_consumed = A + B * k
```

Here, A and B represent empirically calculated constants.

Here you can find benchmark test vectors for EIP-2537[^46].

***Test cases:***

<ins>Tests for one pair</ins>

- Generate a random point $P \in G_1$: verify $e(P, 0) = 1$
- Generate a random point $Q \in G_2$: verify $e(0, Q) = 1$
- Generate random points $P \ne 0 \in G_1$ and $Q \ne 0 \in G_2$: verify $e(P, Q) \ne 1$  

<ins>Tests for two pairs</ins>

- Generate random points $P \in G_1$, $Q \in G_2$ and random scalars $s_1, s_2$:
  - $e(P, Q) \cdot e(P, -Q) = 1$
  - $e(P, Q) \cdot e(-P, Q) = 1$
  - $e(s_1P, s_2Q) \cdot e(-s_2P, s_1Q) = 1$
  - $e(s_1P, s_2Q) \cdot e(s_2P, -s_1Q) = 1$

- $g_1 \in G_1$, $g_2 \in G_2$ are generators defined in section 'BLS12-381 Curve Specification', r is the order of $G_1$ and $G_2$,  and $p_1, p_2, q_1, q_2$ are randomly generated scalars:
  - if $p_1 \cdot q_1 + p_2 \cdot q_2 \not \equiv 0 (\mod r)$, verify $e(p_1 g_1, q_1 g_2) \cdot e(p_2 g_1, q_2 g_2) \ne 1$
  - if $p_1 \cdot q_1 + p_2 \cdot q_2 \equiv 0 (\mod r)$, verify $e(p_1 g_1, q_1 g_2) \cdot e(p_2 g_1, q_2 g_2) = 1$

<ins>Tests for an arbitrary number of pairs</ins>

- Empty input
- Test with the maximum number of pairs
- Tests using known answers from EIP-2537[^47],[^48]
- For all possible values of 'n', generate random scalars $p_1 \cdots p_n$ and $q_1 \cdots q_n$ such that $\sum p_i \cdot q_i \not \equiv 0 (\mod r)$:
  - Verify $\prod e(p_i g_1, q_i g_2) \ne 1$
- For all possible values of 'n', generate random scalars $p_1 \cdots p_{n - 1}$ and $q_1 \cdots q_{n - 1}$:
  - Verify $(\prod e(p_i g_1, q_i g_2)) \cdot e(-(\sum p_i q_i) g_1, g_2) = 1$
  - Verify $(\prod e(p_i g_1, q_i g_2)) \cdot e(g_1, -(\sum p_i q_i) g_2) = 1$

<ins>Tests for error cases</ins>

- The first point is on the curve but not in G1.
- The second point is on the curve but not in G2.
- The input length is not divisible by 288.
- The first point is not on the curve.
- The second point is not on the curve.
- Input length exceeds the memory limit.
- Incorrect encoding of the infinity point.
- Incorrect encoding of a curve point:
  - Incorrect decompression bit.
  - Coordinates greater than or equal to 'p'.

***Error cases (execution is terminated):***

- The input length is not divisible by 288.
- The input is beyond memory bounds.

***Annotation:***

```rust
pub fn bls12381_pairing_check(&mut self, 
                              value_len: u64, 
                              value_ptr: u64, 
                              register_id: u64) -> Result<u64>;
```

#### bls12381_decompress_g1

***Description:***  The function decompresses compressed points from $E(F_p)$. It takes an arbitrary number of points $p_i \in E(F_p)$ in compressed format as input and outputs the same number of points from $E(F_p)$ in decompressed format. Further details about the decompressed and compressed formats are available in the Curve Points Encoding section.

***Input:*** A sequence of points $p_i \in E(F_p)$, with each point encoded in compressed form. An expected input size of 48*k bytes is anticipated, interpreted as the byte concatenation of k slices. Each slice represents the compressed point from $E(F_p)$. Additional details can be found in the Curve Points Encoding section.

***Output:***

The ERROR_CODE is returned.

- ERROR_CODE = 0: the input is correct
  - <ins>Output:</ins> The sequence of points $p_i \in E(F_p)$, with each point encoded in decompressed form. An expected output of 96*k bytes, interpreted as the byte concatenation of k slices. Each slice represents the decompressed point from $E(F_p)$. k is the same as in the input. More details are available in the Curve Points Encoding section.
- ERROR_CODE = 1:
  - Points are incorrectly encoded (refer to the Curve points encoded section).
  - Point is not on the curve.

***Gas Estimation:*** 

The algorithm has linear complexity concerning the number of elements. The gas estimation can be calculated using the following formula:

```rust
let k = input_bytes/item_size
let gas_consumed = A + B * k
```

Here, A and B represent empirically calculated constants.

***Test cases:***

<ins>Tests for decompressing a single point</ins>

- Generate random points on the curve from G1 and not from G1:
  - Check that the uncompressed point lies on the curve.
  - Compare the result with another library.
- Generate random points with a negative y:
  - Take the inverse and compare the y-coordinate.
  - Compare the result with another library.
- Decompress a point on infinity.

<ins>Tests for decompression of an arbitrary number of points</ins>

- Empty input.
- Maximum number of points.
- Generate a random number of points on the curve and compare the result with another library.

<ins>Tests for error cases</ins>

- The input length is not divisible by 48.
- The input is beyond memory bounds. 
- Point is not on the curve. 
- Incorrect decompression bit. 
- Incorrectly encoded infinity point. 
- Point with a coordinate larger than 'p'.

***Error cases (execution is terminated):***

- The input length is not divisible by 48.
- The input is beyond memory bounds.

***Annotation:***

```rust
pub fn bls12381_decompress_g1(&mut self, 
                              value_len: u64, 
                              value_ptr: u64, 
                              register_id: u64) -> Result<u64>;
```

#### bls12381_decompress_g2

***Description:*** The function decompresses compressed points from $E'(F_{p^2})$. It takes an arbitrary number of points $p_i \in E'(F_{p^2})$ in compressed format as input and outputs the same number of points from $E'(F_{p^2})$ in decompressed format. For more information about the decompressed and compressed formats, refer to the Curve Points Encoding section.

***Input:*** A sequence of points $p_i \in E'(F_{p^2})$, with each point encoded in compressed form. The expected input size is 96*k bytes, interpreted as the byte concatenation of k slices. Each slice represents the compressed point from $E'(F_{p^2})$. Additional details are available in the Curve Points Encoding section.

***Output:***

The ERROR_CODE is returned.

- ERROR_CODE = 0: the input is correct
  - <ins>Output:</ins> the sequence of point $p_i \in E'(F_{p^2})$, with each point encoded in decompressed form. The expected output is 192*k bytes, interpreted as the byte concatenation of k slices. `k` corresponds to the value specified in the input section. Each slice represents the decompressed point from $E'(F_{p^2})$. For more details, refer to the Curve Points Encoding section.
- ERROR_CODE = 1:
  - Points are incorrectly encoded (refer to Curve points encoded section). 
  - Point is not on the curve.

***Gas Estimation:*** 

The algorithm has linear complexity concerning the number of elements. The gas estimation can be calculated using the following formula:

```rust
let k = input_bytes/item_size
let gas_consumed = A + B * k
```

Here, A and B represent empirically calculated constants.

***Test cases:***

The same test cases as `bls12381_decompress_g1`, but with points from $G_2$, and the input length should be divisible by 96.

***Error cases (execution is terminated):***

- The input length is not divisible by 96.
- The input is beyond memory bounds.

***Annotation:***

```rust
pub fn bls12381_decompress_g2(&mut self, 
                              value_len: u64, 
                              value_ptr: u64, 
                              register_id: u64) -> Result<u64>;
```

#### General comments for all functions

In all functions, input is fetched from memory, beginning at `value_ptr` and extending to `value_ptr + value_len`. 
If `value_len` is `u64::MAX`, input will come from the register.

Execution ends only if there's an incorrect input length, 
input extends beyond memory bounds, or gas limits are reached. 
Otherwise, execution completes successfully, providing the `ERROR_CODE`.

If the `ERROR_CODE` equals 0, the output data will be written to 
the register with the `register_id` identifier. 
Otherwise, nothing will be written to the register.


## Reference Implementation

Primarily, concerning integration with nearcore, our interest lies in Rust language libraries. The current implementations of BLS12-381 in Rust are:

1. ***Milagro Library*** [^29].
2. ***BLST***  [^30][^31].
3. ***Matter labs EIP-1962 implementation*** [^32]
4. ***zCash origin implementation*** [^33]
5. ***MCL Library*** [^34]
6. ***FileCoin implementation*** [^35]
7. ***zkCrypto*** [^36]

To compile the list, we used links from EIP-2537[^43], the pairing-curves specification[^44], and an article containing benchmarks[^45]. This list might be incomplete, but it should encompass the primary BLS12-381 implementations.

In addition, there are implementations in other languages that are less relevant to us in this context but can serve as references.

1. C++, ETH2.0 Client, ***Chia library***[^37]
2. Haskell, ***Adjoint Lib***[^38]
3. Go, ***Go-Ethereum***[^39]
4. JavaScript, ***Noble JS***[^40]
5. Go, ***Matter Labs Go EIP-1962 implementation***[^41]
6. C++, ***Matter Labs Go EIP-1962 implementation***[^42]

One of the possible libraries to use is the blst library[^30]. 
This library exhibits good performance[^45] and has undergone several audits[^55]. 
You can find the draft implementation in nearcore, which is based on this library, through this link[^54].

## Security Implications

The implementation's security depends on the chosen library's security, supporting operations with BLS curves.

Within this NEP, a constant execution time for all operations isn't mandated. This isn't an issue when employing host functions for BLS signature/zkSNARKs verification. However, refrain from using these host functions if a constant-time algorithm is necessary.

BLS12-381 offers more security bits compared to the already existing pairing-friendly curve BN254. Consequently, the security of projects requiring the pairing-friendly curve will be enhanced.

## Alternatives

In nearcore, host functions for another pairing-friendly curve, BN254, have already been implemented[^10]. Some projects[^20] might consider utilizing the supported curve as an alternative. However, recent research indicates that this curve provides less than 100 bits of security and is not recommended for use[^13]. Furthermore, projects involved in cross-chain interactions, like Rainbow Bridge, are mandated to employ the same curve as the target protocol, which, in the case of Ethereum, is currently BLS12-381[^3]. Consequently, there is no viable alternative to employing a different pairing-friendly curve.

An alternative approach involves creating a single straightforward host function in nearcore for BLS signature verification. This was the initially proposed solution[^26]. However, this solution lacks flexibility[^28] for several reasons: (1) projects may utilize different hash functions; (2) some projects might employ the G1 subgroup for public keys, while others use G2; (3) the specifications for Ethereum 2.0 remain in draft, subject to potential changes; (4) instead of a more varied and adaptable set of functions (inspired by EIP-2537's precompiles), we are left with a single large function; (5) there will be no support for zkSNARKs verification.

Another alternative is to perform BLS12-381 operations off-chain. In this scenario, applications utilizing the BLS curve will no longer maintain trustlessness.

## Future possibilities

In the future, there might be support for working with various curves beyond just BLS12-381. In Ethereum, prior to EIP-2537[^15], there was a proposal, EIP-1962[^27], to introduce pairing-friendly elliptic curves in a versatile format, accommodating not only BLS curves but numerous others as well. However, this proposal wasn't adopted due to its extensive scope and complexity. Implementing every conceivable curve might not be practical, but it remains a potential extension worth considering.

Another potential extension could involve supporting hash_to_field or hash_to_curve operations[^58]. Enabling their support would optimize gas usage for encoding messages into elements on the curve, which could benefit BLS signatures. However, implementing the hash_to_field operation requires supporting multiple hashing algorithms simultaneously and doesn't demand a significant amount of gas for implementation within the contract. Therefore, these functions exceed the scope of this proposal.

Additionally, a potential expansion might encompass supporting not only affine coordinates but also other coordinate systems, such as homogeneous or Jacobian projective coordinates.

## Consequences

### Positive

- Projects currently utilizing BN254 will have the capability to transition to the BLS12-381 curve, thereby enhancing their security.
- Trustless cross-chain interactions with blockchains employing BLS12-381 in protocols (like Ethereum 2.0) will become feasible.

### Neutral

### Negative

- There emerges a dependency on a library that supports operations with BLS12-381 curves.
- We'll have to continually maintain operations with BLS12-381 curves, even if vulnerabilities are discovered, and it becomes unsafe to use these curves.

### Backward Compatibility

There are no backward compatibility questions.

## Changelog

The previous NEP for supporting BLS signature based on BLS12-381[^26]

[^1]: BLS 2002 [https://www.researchgate.net/publication/2894224_Constructing_Elliptic_Curves_with_Prescribed_Embedding_Degrees](https://www.researchgate.net/publication/2894224_Constructing_Elliptic_Curves_with_Prescribed_Embedding_Degrees)
[^2]: ZCash protocol: [https://zips.z.cash/protocol/protocol.pdf](https://zips.z.cash/protocol/protocol.pdf)
[^3]: Ethereum 2 specification: [https://github.com/ethereum/consensus-specs/blob/master/specs/phase0/beacon-chain.md](https://github.com/ethereum/consensus-specs/blob/master/specs/phase0/beacon-chain.md)
[^4]: Dfinity: [https://internetcomputer.org/docs/current/references/ic-interface-spec#certificate](https://internetcomputer.org/docs/current/references/ic-interface-spec#certificate)
[^5]: Tezos: [https://wiki.tezosagora.org/learn/futuredevelopments/layer2#zkchannels](https://wiki.tezosagora.org/learn/futuredevelopments/layer2#zkchannels)
[^6]: Filecoin: [https://spec.filecoin.io/](https://spec.filecoin.io/)
[^7]: Specification of pairing friendly curves with a list of applications in the table: [https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#name-adoption-status-of-pairing-](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#name-adoption-status-of-pairing-)
[^8]: Specification of pairing friendly curves, the security level for BLS12-381: [https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#section-4.2.1](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#section-4.2.1)
[^9]: BN2005: [https://eprint.iacr.org/2005/133](https://eprint.iacr.org/2005/133)
[^10]: NEP-98 for BN254 host functions on NEAR: [https://github.com/near/NEPs/issues/98](https://github.com/near/NEPs/issues/98)
[^11]: BLS12-381 for the Rest of Us: [https://hackmd.io/@benjaminion/bls12-381](https://hackmd.io/@benjaminion/bls12-381)
[^12]: BN254 for the Rest of Us: [https://hackmd.io/@jpw/bn254](https://hackmd.io/@jpw/bn254)
[^13]: Some analytics of different curve security: [https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-02.html#name-for-100-bits-of-security](https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-02.html#name-for-100-bits-of-security)
[^14]: ZCash Transfer from bn254 to bls12-381: [https://electriccoin.co/blog/new-snark-curve/](https://electriccoin.co/blog/new-snark-curve/)
[^15]: EIP-2537 Precompiles for Ethereum for BLS12-381: [https://eips.ethereum.org/EIPS/eip-2537](https://eips.ethereum.org/EIPS/eip-2537)
[^17]: Article about Rainbow Bridge [https://near.org/blog/eth-near-rainbow-bridge](https://near.org/blog/eth-near-rainbow-bridge)
[^19]: Intro into zkSNARKs: [https://media.consensys.net/introduction-to-zksnarks-with-examples-3283b554fc3b](https://media.consensys.net/introduction-to-zksnarks-with-examples-3283b554fc3b)
[^20]: Zeropool project: [https://zeropool.network/](https://zeropool.network/)
[^24]: Precompiles on Aurora: [https://doc.aurora.dev/evm/precompiles/](https://doc.aurora.dev/evm/precompiles/)
[^25]: Pippenger Algorithm: [https://github.com/wborgeaud/python-pippenger/blob/master/pippenger.pdf](https://github.com/wborgeaud/python-pippenger/blob/master/pippenger.pdf)
[^26]: NEP-446 proposal for BLS-signature verification: [https://github.com/nearprotocol/neps/pull/446](https://github.com/nearprotocol/neps/pull/446)
[^27]: EIP-1962 EC arithmetic and pairings with runtime definitions: [https://eips.ethereum.org/EIPS/eip-1962](https://eips.ethereum.org/EIPS/eip-1962)
[^28]: Drawbacks of NEP-446: [https://github.com/near/NEPs/pull/446#pullrequestreview-1314601508](https://github.com/near/NEPs/pull/446#pullrequestreview-1314601508)
[^29]: BLS12-381 Milagro: [https://github.com/sigp/incubator-milagro-crypto-rust/tree/057d238936c0cbbe3a59dfae6f2405db1090f474](https://github.com/sigp/incubator-milagro-crypto-rust/tree/057d238936c0cbbe3a59dfae6f2405db1090f474)
[^30]: BLST: [https://github.com/supranational/blst](https://github.com/supranational/blst),
[^31]: BLST EIP-2537 adaptation: [https://github.com/sean-sn/blst_eip2537](https://github.com/sean-sn/blst_eip2537)
[^32]: EIP-1962 implementation matter labs Rust: https://github.com/matter-labs/eip1962
[^33]: zCash origin rust implementation: [https://github.com/zcash/zcash/tree/master/src/rust/src](https://github.com/zcash/zcash/tree/master/src/rust/src)
[^34]: MCL library: [https://github.com/herumi/bls](https://github.com/herumi/bls)
[^35]: filecoin/bls-signature: [https://github.com/filecoin-project/bls-signatures](https://github.com/filecoin-project/bls-signatures)
[^36]: zkCrypto: [https://github.com/zkcrypto/bls12_381](https://github.com/zkcrypto/bls12_381), [https://github.com/zkcrypto/pairing](https://github.com/zkcrypto/pairing)
[^37]: BLS12-381 code bases for ETH2.0 client Chia library C++: [https://github.com/Chia-Network/bls-signatures](https://github.com/Chia-Network/bls-signatures)
[^38]: Adjoint Lib: [https://github.com/sdiehl/pairing](https://github.com/sdiehl/pairing)
[^39]: Ethereum Go implementation for EIP-2537: [https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles](https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles)
[^40]: Noble JS implementation: [https://github.com/paulmillr/noble-bls12-381](https://github.com/paulmillr/noble-bls12-381)
[^41]: EIP-1962 implementation matter labs Go: https://github.com/kilic/eip2537,
[^42]: EIP-1962 implementation matter labs C++: https://github.com/matter-labs-archive/eip1962_cpp
[^43]: EIP-2537 with links: [https://github.com/matter-labs-forks/EIPs/blob/bls12_381/EIPS/eip-2537.md](https://github.com/matter-labs-forks/EIPs/blob/bls12_381/EIPS/eip-2537.md)
[^44]: Pairing-friendly curves specification, crypto libs: [https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#name-cryptographic-libraries](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-09#name-cryptographic-libraries)
[^45]: Comparing different libs for pairing-friendly curves: [https://hackmd.io/@gnark/eccbench](https://hackmd.io/@gnark/eccbench)
[^46]: Bench vectors from EIP2537: [https://eips.ethereum.org/assets/eip-2537/bench_vectors](https://eips.ethereum.org/assets/eip-2537/bench_vectors)
[^47]: Metter Labs tests for EIP2537: [https://github.com/matter-labs/eip1962/tree/master/src/test/test_vectors/eip2537](https://github.com/matter-labs/eip1962/tree/master/src/test/test_vectors/eip2537)
[^48]: Tests from Go Ethereum implementation: [https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles](https://github.com/ethereum/go-ethereum/tree/master/core/vm/testdata/precompiles)
[^51]: draft-irtf-cfrg-pairing-friendly-curves-11 [https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11#name-bls-curves-for-the-128-bit-](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11#name-bls-curves-for-the-128-bit-)  *(*[https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/bls.md](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/bls.md) → [https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04) → this ref*)*
[^52]: Paper with BLS12-381: [https://eprint.iacr.org/2019/403.pdf](https://eprint.iacr.org/2019/403.pdf)
[^53]: Zkcrypto points encoding: [https://github.com/zkcrypto/pairing/blob/0.14.0/src/bls12_381/README.md](https://github.com/zkcrypto/pairing/blob/0.14.0/src/bls12_381/README.md)
[^54]: Draft PR for BLS12-381 operations in nearcore: https://github.com/near/nearcore/pull/9317
[^55]: Audit for BLST library: [https://research.nccgroup.com/wp-content/uploads/2021/01/NCC_Group_EthereumFoundation_ETHF002_Report_2021-01-20_v1.0.pdf](https://research.nccgroup.com/wp-content/uploads/2021/01/NCC_Group_EthereumFoundation_ETHF002_Report_2021-01-20_v1.0.pdf)
[^58]: hash_to_curve and hash_to_field function: [https://datatracker.ietf.org/doc/html/rfc9380#name-hash_to_field-implementatio](https://datatracker.ietf.org/doc/html/rfc9380#name-hash_to_field-implementatio)
[^59]: Implementation of BLS-signature based on these host functions: [https://github.com/olga24912/bls-signature-verificaion-poc/blob/main/src/lib.rs](https://github.com/olga24912/bls-signature-verificaion-poc/blob/main/src/lib.rs)
[^60]: hash_to_field specification: [https://datatracker.ietf.org/doc/html/rfc9380#name-hash_to_field-implementatio](https://datatracker.ietf.org/doc/html/rfc9380#name-hash_to_field-implementatio)
[^61]: double-and-add algorithm: [https://en.wikipedia.org/wiki/Exponentiation_by_squaring](https://en.wikipedia.org/wiki/Exponentiation_by_squaring)
[^62]: RFC 9380 Hashing to Elliptic Curves specification: [https://www.rfc-editor.org/rfc/rfc9380](https://www.rfc-editor.org/rfc/rfc9380)
[^63]: map_to_curve and clear_cofactor functions: [https://datatracker.ietf.org/doc/html/rfc9380#name-encoding-byte-strings-to-el](https://datatracker.ietf.org/doc/html/rfc9380#name-encoding-byte-strings-to-el)
[^64]: Specification of parameters for BLS12-381 G1: [https://datatracker.ietf.org/doc/html/rfc9380#name-bls12-381-g1](https://datatracker.ietf.org/doc/html/rfc9380#name-bls12-381-g1)
[^65]: Specification of parameters for BLS12-381 G2: [https://datatracker.ietf.org/doc/html/rfc9380#name-bls12-381-g2](https://datatracker.ietf.org/doc/html/rfc9380#name-bls12-381-g2)
